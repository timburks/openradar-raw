apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "25289979"
    labels:
        datastore_id: "4940944436625408"
data:
    classification: Crash/Hang/Data Loss
    created: "2016-03-22T13:38:01.48895Z"
    description: "Summary:\r\nAttached code snippet crashes.\r\n\r\nOn the other hand, being able to call blocks in a NSInvocation-like manner allows writing generic library code that handles blocks of different signatures. Would be great to have a separate public API for doing this that would not interfere with normal message sending.\r\n\r\nNote that block may be taking a selector as a first argument. In this case block type encoding will be very similar to the method type encoding: \"#8@?0:4\" vs \"#8@0:4\" in attached example.\r\n\r\nSteps to Reproduce:\r\nCompile and run attached code snippet\r\n\r\nExpected Results:\r\nFirst two NSLog's should print the same result. App should not crash. It should be possible to send messages to block objects. Sending messages to blocks should not be confused with calling blocks that take a selector as a first argument.\r\n\r\nActual Results:\r\nBlock is called instead of sending message to the block object. App crashes inside the block code\r\n\r\nVersion:\r\niOS 8.4.1 (12H321), iOS 9.2.1 (13D15)\r\n\r\nNotes:\r\n\r\n\r\nConfiguration:\r\niPhone 6s, iPhone 5c\r\n\r\n// Attached code\r\n@import Foundation;\r\n#import <objc/runtime.h>\r\n\r\nstruct block_literal\r\n{\r\n    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock\r\n    int flags;\r\n    int reserved;\r\n    void (*invoke)(void *, ...);\r\n    struct block_descriptor {\r\n        unsigned long int reserved;                 // NULL\r\n        unsigned long int size;                     // sizeof(struct Block_literal_1)\r\n        // optional helper functions\r\n        void (*copy_helper)(void *dst, void *src);  // IFF (1<<25)\r\n        void (*dispose_helper)(void *src);          // IFF (1<<25)\r\n        // required ABI.2010.3.16\r\n        const char *signature;                      // IFF (1<<30)\r\n    } *descriptor;\r\n};\r\n\r\nchar const * block_signature(id x) {\r\n    struct block_literal* def = (__bridge struct block_literal*)x;\r\n    if (def == NULL) {\r\n        return NULL;\r\n    }\r\n    \r\n    if (!(def->flags & (1 << 30))) {\r\n        return NULL;\r\n    }\r\n    \r\n    if (def->flags & (1 << 25)) {\r\n        return def->descriptor->signature;\r\n    } else {\r\n        return *(char const * const *)&def->descriptor->copy_helper;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    {\r\n        void (^block)(id x) = ^(id x){\r\n        \tNSLog(@\"%@\", x); // Crash\r\n        };\r\n        NSLog(@\"%@\", [block class]);\r\n        NSMethodSignature* sign = [block methodSignatureForSelector:@selector(class)];\r\n        NSInvocation* invocation = [NSInvocation invocationWithMethodSignature:sign];\r\n        [invocation setTarget:block];\r\n        [invocation setSelector:@selector(class)];\r\n        [invocation invoke]; // This invokes the block, rather then sending a message to the block object\r\n        Class k = nil;\r\n        [invocation getReturnValue:&k];\r\n        NSLog(@\"%@\", k);\r\n    }\r\n\r\n    // This is a very cool functionality that is useful for library writers.\r\n\t// But unfortunately undocumented.\r\n\t{\r\n        CGAffineTransform (^block)(id x, int y, CGSize z) = ^(id x, int y, CGSize z){\r\n            NSLog(@\"%@,%d,%f\", x, y, z.width);\r\n            CGAffineTransform t = { 1, 2, 3, 4, 5, 6 };\r\n            return t;\r\n        };\r\n    \r\n        NSMethodSignature* sign = [NSMethodSignature signatureWithObjCTypes:block_signature(block)];\r\n        NSInvocation* invocation = [NSInvocation invocationWithMethodSignature:sign];\r\n        [invocation setTarget:block];\r\n        void* x = (__bridge void*)@\"Foo\";\r\n        int y = 42;\r\n        CGSize z = { 320, 480 };\r\n        [invocation setArgument:&x atIndex:1];\r\n        [invocation setArgument:&y atIndex:2];\r\n        [invocation setArgument:&z atIndex:3];\r\n        [invocation invoke];\r\n        CGAffineTransform t;\r\n        [invocation getReturnValue:&t];\r\n        NSLog(@\"%@\", NSStringFromCGAffineTransform(t));\r\n    }\r\n    \r\n    // Mind this case as well\r\n    {\r\n        Class (^blockThatLooksLikeASelector)(SEL sel) = ^(SEL sel){ NSLog(@\"%@\", NSStringFromSelector(sel)); return [NSString class]; };\r\n        char const * s1 = block_signature(blockThatLooksLikeASelector);\r\n        Class k = object_getClass(blockThatLooksLikeASelector);\r\n        Method m = class_getInstanceMethod(k, @selector(class));\r\n        char const * s2 = method_getTypeEncoding(m);\r\n        NSLog(@\"\\n%s\\n%s\", s1, s2);\r\n    }\r\n}"
    email: pohilets@gmail.com
    modified: "2016-03-22T13:38:01.48916Z"
    number: "25289979"
    number_intvalue: 25289979
    originated: 22-Mar-2016
    parent_number: '&{NULL_VALUE}'
    product: iOS SDK
    product_version: ""
    reproducible: Always
    resolved: ""
    status: Open
    title: NSInvocation crashes when sending a message to the block object
