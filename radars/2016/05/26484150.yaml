apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "26484150"
    labels:
        datastore_id: "5008441995165696"
data:
    classification: Crash
    created: "2016-05-26T01:19:10.17656Z"
    description: "Summary:\r\n\r\nTo insert or delete some items the collection view must know how many items it had before and after. That means insert\\delete operations will trigger data source methods to get those numbers. Typically, the collection view knows how many items it has by the moment we insert\\delete. Because it invokes data source methods starting from the moment when we lay it out. So usually it will query the data source only once on insert\\delete: to get the updated numbers after the items were inserted\\removed.\r\n\r\nBut, if we created a collection view from scratch and immediately tried to insert\\delete data, the collection view would trigger the data source methods twice! First time to get the numbers before the change, and second time to see how they have changed. That means there's no way to change the number of items returned by the data source methods in between of those two queries, which leads to NSInternalInconsistencyException.\r\n\r\nCalling reloadData before the update doesn't invoke data source methods immediately, but rather invalidates some collection view's internal state and queries for the data only when necessary. That's quite obviously made for optimization purposes.\r\n\r\nThe only reliable way to force the collection view to read the current number of items before the insertion/deletion is either:\r\n\r\n1) [collectionView performBatchUpdates:^{  // Invokes initial numbedOfItemsInSection if needed.\r\n      // Now update the model here.\r\n      [collectionView insertItemsAtIndexPaths:_index_paths_];\r\n    } completion:nil];\r\n    or \r\n2) [collectionView numberOfItemsInSection:_section_];  // Force the initial data source call.\r\n    [collectionView insertItemsAtIndexPaths:_index_paths_];\r\n\r\nSteps to Reproduce:\r\nCompile and run the following code:\r\n\r\n@interface ViewController : UIViewController<UICollectionViewDataSource>\r\n@end\r\n\r\n@implementation ViewController {\r\n  NSUInteger _numberOfItems;\r\n}\r\n\r\n- (void)viewDidLoad {\r\n  [super viewDidLoad];\r\n  UICollectionView *collectionView =\r\n      [[UICollectionView alloc] initWithFrame:self.view.bounds\r\n                                  collectionViewLayout:[UICollectionViewFlowLayout new]];\r\n  collectionView.dataSource = self;\r\n\r\n  NSArray<NSIndexPath *> *insertion = @[[NSIndexPath indexPathForItem:0 inSection:0]];\r\n  _numberOfItems += insertion.count;\r\n  [collectionView insertItemsAtIndexPaths:insertion];  // CRASH\r\n}\r\n\r\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section {\r\n  return _numberOfItems;\r\n}\r\n\r\n@end\r\n\r\nExpected Results:\r\nUICollectionView performs the insertion and doesn't throw NSInternalInconsistencyException.\r\nOR the official documentation describes this issue and provides some recommendations how to bypass it.\r\n\r\nActual Results:\r\n2016-05-25 17:46:29.844 UICollectionView Tweaks[29712:7489886] *** Assertion failure in -[UICollectionView _endItemAnimationsWithInvalidationContext:tentativelyForReordering:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3512.60.7/UICollectionView.m:4625\r\n2016-05-25 17:46:29.847 UICollectionView Tweaks[29712:7489886] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of items in section 0.  The number of items contained in an existing section after the update (1) must be equal to the number of items contained in that section before the update (1), plus or minus the number of items inserted or deleted from that section (1 inserted, 0 deleted) and plus or minus the number of items moved into or out of that section (0 moved in, 0 moved out).'\r\n*** First throw call stack:\r\n(\r\n\t0   CoreFoundation                      0x0000000106e78d85 __exceptionPreprocess + 165\r\n\t1   libobjc.A.dylib                     0x00000001068eadeb objc_exception_throw + 48\r\n\t2   CoreFoundation                      0x0000000106e78bea +[NSException raise:format:arguments:] + 106\r\n\t3   Foundation                          0x0000000106533d5a -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 198\r\n\t4   UIKit                               0x0000000107abe077 -[UICollectionView _endItemAnimationsWithInvalidationContext:tentativelyForReordering:] + 15363\r\n\t5   UIKit                               0x0000000107aba2ca -[UICollectionView _updateRowsAtIndexPaths:updateAction:] + 350\r\n\t6   UICollectionView Tweaks             0x00000001063e53f9 -[ViewController insertItemsIntoCollectionView] + 217\r\n\t7   UICollectionView Tweaks             0x00000001063e4efc -[ViewController viewDidLoad] + 92\r\n\t8   UIKit                               0x00000001073ca984 -[UIViewController loadViewIfRequired] + 1198\r\n\t9   UIKit                               0x00000001073cacd3 -[UIViewController view] + 27\r\n\t10  UIKit                               0x00000001072a0fb4 -[UIWindow addRootViewControllerViewIfPossible] + 61\r\n\t11  UIKit                               0x00000001072a169d -[UIWindow _setHidden:forced:] + 282\r\n\t12  UIKit                               0x00000001072b3180 -[UIWindow makeKeyAndVisible] + 42\r\n\t13  UICollectionView Tweaks             0x00000001063e56e3 -[AppDelegate application:didFinishLaunchingWithOptions:] + 483\r\n\t14  UIKit                               0x00000001072269ac -[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 272\r\n\t15  UIKit                               0x0000000107227c0d -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 3415\r\n\t16  UIKit                               0x000000010722e568 -[UIApplication _runWithMainScene:transitionContext:completion:] + 1769\r\n\t17  UIKit                               0x000000010722b714 -[UIApplication workspaceDidEndTransaction:] + 188\r\n\t18  FrontBoardServices                  0x0000000109cca8c8 __FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 24\r\n\t19  FrontBoardServices                  0x0000000109cca741 -[FBSSerialQueue _performNext] + 178\r\n\t20  FrontBoardServices                  0x0000000109ccaaca -[FBSSerialQueue _performNextFromRunLoopSource] + 45\r\n\t21  CoreFoundation                      0x0000000106d9e301 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17\r\n\t22  CoreFoundation                      0x0000000106d9422c __CFRunLoopDoSources0 + 556\r\n\t23  CoreFoundation                      0x0000000106d936e3 __CFRunLoopRun + 867\r\n\t24  CoreFoundation                      0x0000000106d930f8 CFRunLoopRunSpecific + 488\r\n\t25  UIKit                               0x000000010722af21 -[UIApplication _run] + 402\r\n\t26  UIKit                               0x000000010722ff09 UIApplicationMain + 171\r\n\t27  UICollectionView Tweaks             0x00000001063e54df main + 111\r\n\t28  libdyld.dylib                       0x000000010966a92d start + 1\r\n)\r\nlibc++abi.dylib: terminating with uncaught exception of type NSException"
    email: anthony@shoumikh.in
    modified: "2016-05-26T01:19:10.17675Z"
    number: "26484150"
    number_intvalue: 26484150
    originated: 5/25/2016
    parent_number: '&{NULL_VALUE}'
    product: iOS
    product_version: 9.3.2
    reproducible: Always
    resolved: ""
    status: Open
    title: insertItemsAtIndexPaths throws NSInternalInconsistencyException when called right after UICollectionView view was created.
