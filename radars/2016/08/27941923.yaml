apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "27941923"
    labels:
        datastore_id: "5062699696259072"
data:
    classification: Bug
    created: "2016-08-22T02:01:24.5132Z"
    description: "Summary:\r\n\r\nLooks like a more general case of rdar://26484150\r\n\r\nConsider the following snippet:\r\n\r\n- (void)whateverMethod {\r\n  [_collectionView reloadData];\r\n  _numberOfItems += 1;\r\n  [_collectionView insertItemsAtIndexPaths:@[ [NSIndexPath indexPathForItem:0 inSection:0] ]];\r\n}\r\n\r\n- (NSInteger)collectionView:(UICollectionView *)collectionView\r\n     numberOfItemsInSection:(NSInteger)section {\r\n  return _numberOfItems;\r\n}\r\n\r\ninsertItemsAtIndexPaths: throws NSInternalInconsistencyException.\r\n\r\nThe reason is reloadData effectively does nothing, but just invalidates some internal collection view's state that will trigger data source methods when it's considered inevitable, but never earlier.\r\n\r\nSince collection view's state is already invalid (meaning it knows nothing about the current numberOfItems after reloadData) by the time we call insertItemsAtIndexPath, the latter must ask the data source twice for the numberOfItemsInSection:. First time it expects to get the number of items before the insertions, and the second time - after. We've already modified the model at that point to a new number of items, so it gets same number each time and throws NSInconsistencyException.\r\n\r\nThe easiest way to fix such cases would be wrapping the model modifications and corresponding insert/deleteItemsAtIndexPath with performBatchUpdates: even when we technically donâ€™t do multiple updates.\r\nThat causes the collection view to get the current number of items synchronously from the data source before executing the updates block. Like this:\r\n\r\n[_collectionView performBatchUpdates:^{\r\n  _numberOfItems += 1;\r\n  [_collectionView insertItemsAtIndexPaths:@[ [NSIndexPath indexPathForItem:0 inSection:0] ]];\r\n}\r\nanimated:YES];\r\n\r\nExpected Results:\r\nUICollectionView performs the insertion and doesn't throw NSInternalInconsistencyException.\r\nOR the official documentation describes this issue and provides some recommendations how to bypass it.\r\n\r\nActual Results:\r\n2016-08-21 18:52:37.381 iOS Polygon[22971:15295480] *** Assertion failure in -[UICollectionView _endItemAnimationsWithInvalidationContext:tentativelyForReordering:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3512.60.7/UICollectionView.m:4625\r\n2016-08-21 18:52:37.386 iOS Polygon[22971:15295480] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of items in section 0.  The number of items contained in an existing section after the update (11) must be equal to the number of items contained in that section before the update (11), plus or minus the number of items inserted or deleted from that section (1 inserted, 0 deleted) and plus or minus the number of items moved into or out of that section (0 moved in, 0 moved out).'\r\n*** First throw call stack:\r\n(\r\n\t0   CoreFoundation                      0x0000000102236d85 __exceptionPreprocess + 165\r\n\t1   libobjc.A.dylib                     0x0000000101ca8deb objc_exception_throw + 48\r\n\t2   CoreFoundation                      0x0000000102236bea +[NSException raise:format:arguments:] + 106\r\n\t3   Foundation                          0x00000001018f1d5a -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 198\r\n\t4   UIKit                               0x0000000102e7c077 -[UICollectionView _endItemAnimationsWithInvalidationContext:tentativelyForReordering:] + 15363\r\n\t5   UIKit                               0x0000000102e782ca -[UICollectionView _updateRowsAtIndexPaths:updateAction:] + 350\r\n\t6   iOS Polygon                         0x00000001017a273a -[ViewController viewWillTransitionToSize:withTransitionCoordinator:] + 314\r\n\t7   UIKit                               0x0000000102797bd9 +[UIViewController _performWithoutDeferringTransitions:] + 110\r\n\t8   UIKit                               0x00000001027b06e2 -[UIViewController(AdaptiveSizing) _window:viewWillTransitionToSize:withTransitionCoordinator:] + 1059\r\n\t9   UIKit                               0x0000000102666ef7 __59-[UIWindow _rotateToBounds:withAnimator:transitionContext:]_block_invoke + 175\r\n\t10  UIKit                               0x0000000102666d16 -[UIWindow _rotateToBounds:withAnimator:transitionContext:] + 424\r\n\t11  UIKit                               0x0000000102669c54 -[UIWindow _rotateWindowToOrientation:updateStatusBar:duration:skipCallbacks:] + 2047\r\n\t12  UIKit                               0x000000010266a74d -[UIWindow _setRotatableClient:toOrientation:updateStatusBar:duration:force:isRotating:] + 842\r\n\t13  UIKit                               0x0000000102669280 -[UIWindow _setRotatableViewOrientation:updateStatusBar:duration:force:] + 184\r\n\t14  UIKit                               0x0000000102667ed1 __57-[UIWindow _updateToInterfaceOrientation:duration:force:]_block_invoke + 107\r\n\t15  UIKit                               0x0000000102667d09 -[UIWindow _updateToInterfaceOrientation:duration:force:] + 486\r\n\t16  CoreFoundation                      0x0000000102200c8c __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 12\r\n\t17  CoreFoundation                      0x00000001022009cb _CFXRegistrationPost + 427\r\n\t18  CoreFoundation                      0x0000000102200732 ___CFXNotificationPost_block_invoke + 50\r\n\t19  CoreFoundation                      0x00000001022491e2 -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 1986\r\n\t20  CoreFoundation                      0x00000001020f8679 _CFXNotificationPost + 633\r\n\t21  Foundation                          0x0000000101833cd9 -[NSNotificationCenter postNotificationName:object:userInfo:] + 66\r\n\t22  UIKit                               0x000000010293830c -[UIDevice setOrientation:animated:] + 326\r\n\t23  UIKit                               0x000000010260e96f __54-[UIApplication _handleDeviceOrientationChangedEvent:]_block_invoke + 87\r\n\t24  UIKit                               0x000000010260e8e8 -[UIApplication _handleDeviceOrientationChangedEvent:] + 124\r\n\t25  UIKit                               0x000000010260e7f8 -[UIApplication handleEvent:withNewEvent:] + 1672\r\n\t26  UIKit                               0x000000010260ed17 -[UIApplication sendEvent:] + 88\r\n\t27  UIKit                               0x00000001026013e5 _UIApplicationHandleEvent + 476\r\n\t28  GraphicsServices                    0x0000000105af41cb _PurpleEventCallback + 749\r\n\t29  GraphicsServices                    0x0000000105af3cd3 PurpleEventCallback + 35\r\n\t30  CoreFoundation                      0x000000010215c579 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 41\r\n\t31  CoreFoundation                      0x000000010215c4e9 __CFRunLoopDoSource1 + 473\r\n\t32  CoreFoundation                      0x0000000102151c60 __CFRunLoopRun + 2272\r\n\t33  CoreFoundation                      0x00000001021510f8 CFRunLoopRunSpecific + 488\r\n\t34  GraphicsServices                    0x0000000105af2ad2 GSEventRunModal + 161\r\n\t35  UIKit                               0x00000001025edf09 UIApplicationMain + 171\r\n\t36  iOS Polygon                         0x00000001017a2a0f main + 111\r\n\t37  libdyld.dylib                       0x0000000104a2892d start + 1\r\n\t38  ???                                 0x0000000000000001 0x0 + 1\r\n)\r\nlibc++abi.dylib: terminating with uncaught exception of type NSException"
    email: anthony@shoumikh.in
    modified: "2016-08-22T02:01:24.51341Z"
    number: "27941923"
    number_intvalue: 27941923
    originated: 8/21/2016
    parent_number: '&{NULL_VALUE}'
    product: iOS
    product_version: 9.3.2
    reproducible: Always
    resolved: ""
    status: Open
    title: insertItemsAtIndexPaths throws NSInternalInconsistencyException when called after UICollectionView reloadData.
