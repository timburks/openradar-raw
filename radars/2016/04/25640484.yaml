apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "25640484"
    labels:
        datastore_id: "6174390861430784"
data:
    classification: Feature Request
    created: "2016-04-09T07:45:27.70543Z"
    description: "Summary:\r\nSecTrustEvaluate, in an application, dispatches to securityd to perform the path building and evaluation under a given policy (e.g. TLS). securityd leverages SecCertificatePath's to explore the certificate graph, attempting to score the most preferable chain along the way. Provided that at least one certificate chain validates, SecTrustEvaluate will return success.\r\n\r\nHowever, applications have no means to extend the policy settings provided to the SecTrustRef. That is, consider the Apple-provided SSL/TLS policy: it will always check for id-kp-serverAuth in the leaf (if EKU is present and requesting TLS server validation) and validate the hostname (if requesting TLS server validation). Unfortunately, it won't check to see if the EKUs are consistent along the certificate path (and non-standard behaviour that Microsoft, Mozilla, and Google have adopted as a security mitigation for reducing the scope of authority of sub-CAs), nor is the application able to influence the selection of intermediates or cross-certificates (for example, if a sub-CA is revoked due to bad acting, or a root CA still trusted by iOS being used for insecure purposes)\r\n\r\nCompare this to the NSS (libpkix or mozilla::pkix) APIs. An NSS caller is allowed to supply a chain callback, which, during the path building/evaluation, will be invoked with a 'candidate chain'. The candidate chain is one that complies with all of the policies built in to NSS / requested by the caller using the stable API - but the caller is given an opportunity to reject this. If an application rejects the candidate chain, NSS will continue exploring other nodes within the certificate graph.\r\n\r\nAlternatively, compare this with CryptoAPI from Microsoft. While CryptoAPI provides significantly more extensive opportunities (including the ability to permanently extend the set of policies used to validate, and/or override the default Microsoft implementation), perhaps most relevant to this feature request is the ability to install a custom \"Revocation Provider\", which can make determinations about individual certificates or entire certificate chains. This offers a somewhat more robust API, in that it can prevent unnecessary exploration of the path graph if an intermediate is known to be rejected. \r\n\r\nYou can see examples of how these APIs are used by applications such as Chrome, which uses them to integrate CRLSets and ensure the appropriate blacklisting of known-revoked intermediates.\r\n\r\nCryptoAPI implementation - https://chromium.googlesource.com/chromium/src/+/5332a63125aa1dead5af575d57a63c17013db1a6/net/cert/cert_verify_proc_win.cc#620 ( see https://msdn.microsoft.com/en-us/library/ms995348.aspx for general MSDN documentation on how this implementation works)\r\n\r\nNSS implementation - https://chromium.googlesource.com/chromium/src/+/56139459f834b6b4ac3aad37b466d9ae997ff15c/net/cert/cert_verify_proc_nss.cc#355 invoked by https://chromium.googlesource.com/chromium/src/+/56139459f834b6b4ac3aad37b466d9ae997ff15c/net/cert/cert_verify_proc_nss.cc#872\r\n\r\nSteps to Reproduce:\r\n1. Attempt to verify a certificate which has multiple paths to possible trust anchors\r\n2. Attempt to revoke one or more of these paths\r\n\r\nExpected Results:\r\nExpected: Applications can influence path building and the chain returned (provided that the underlying implementation is happy with the path)\r\n\r\nActual Results:\r\nActual: Application has no influence, and can only apply policies on the final path.\r\n\r\nApplications can attempt to work around this by doing something heinously gross ( e.g. https://chromium.googlesource.com/chromium/src/+/bedc26167ab5402cf9e4a51afeeeb90ababb9da0/net/cert/cert_verify_proc_mac.cc#566 ), but even that is not a reliable solution.\r\n\r\nVersion:\r\n9.3.1 (13E238)\r\n\r\nNotes:\r\nIdeally, a combination of both API approaches would be provided. The Microsoft approach is quite useful for revocation, but unfortunately unsuitable for applying application-level policies (such as the enforcement of EKU constraints). The NSS approach is quite useful for that use case, but unfortunately is invoked significantly more often, because there is no way to surface back to NSS which of the certificates in the candidate chains was unacceptable.\r\n\r\nThat is, consider a path graph in https://chromium.googlesource.com/chromium/src/+/56139459f834b6b4ac3aad37b466d9ae997ff15c/net/data/ssl/scripts/generate-multi-root-test-chains.sh#7 - if C is revoked (while evaluating the trust path of A->B->C->D), there's no point in exploring (A->B->C->E), and instead, the client should attempt to discover the path of (A->B->F->E)\r\n\r\nConfiguration:\r\niPhone 6s"
    email: rsleevi@chromium.org
    modified: "2016-04-09T07:45:27.70561Z"
    number: "25640484"
    number_intvalue: 25640484
    originated: 4/9/2016
    parent_number: '&{NULL_VALUE}'
    product: iOS SDK
    product_version: 9.3.1
    reproducible: ""
    resolved: ""
    status: Open
    title: 'Feature: The ability to provide a caller-supplied callback function during SecTrustEvaluate'
