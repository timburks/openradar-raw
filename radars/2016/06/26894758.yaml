apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "26894758"
    labels:
        datastore_id: "5594463170723840"
data:
    classification: Serious Bug
    created: "2016-06-20T17:19:28.43405Z"
    description: "Summary:\r\nBackground: a new system call, abort_with_payload, was introduced in macOS 10.12. Along with a wrapper function, abort_with_reason, and variants that can target another process, terminate_with_payload and terminate_with_reason, it allows a process to be killed while providing diagnostic information that can be included in a crash report.\r\n\r\ndyld uses this new abort_with_payload system call from dyld::halt() when it encounters a fatal error. Prior to macOS 10.12, dyld would execute an int3 instruction (on x86 and x86-64, or the ARM equivalent on ARM) to raise a user trap, which would show up in user space to a parent process waiting for its child to exit as SIGTRAP. (10.11.2 dyld-360.18/src/dyldStartup.s _dyld_fatal_error.) The exit status is visible to the parent process via a wait-family call such as waitpid().\r\n\r\nHaving a process that exits by abnormal means be reaped with a “killed by signal” status is desirable. This is not a normal exit status, it indicates fairly unambiguously that something went wrong in the process.\r\n\r\nabort_with_payload causes the process to exit with an observed exit status of 1. Thus, processes that experience a dyld fatal error do not show up as “killed by signal.” 1 is a normal exit status ordinarily used to indicate an error, so this exit status is indistinguishable from a typical “process error” condition. The parent process has no reason to believe that the process didn’t start, do some of its own processing, and decide to exit with this status on its own.\r\n\r\nPlease revise the abort_with_payload and terminate_with_payload system calls to not cause processes to exit with an apparent normal exit status. I recommend making them appear to exit with SIGABRT for abort_with_payload, and SIGKILL for terminate_with_payload. SIGABRT best matches the intent of an in-process abort as would occur when calling abort(). SIGKILL best represents the idea of an uncatchable kill originating from out-of-process.\r\n\r\nIf it makes more sense to do so, making both abort_with_payload and terminate_with_payload exit with SIGKILL would also be viable, because SIGKILL represents the “uncatchable” concept, and both of these syscalls result in a termination that’s not catchable in-process as a signal.\r\n\r\nSteps to Reproduce:\r\nTrigger a dyld fatal error and observe the exit status. An easy way to do this is to set DYLD_INSERT_LIBRARIES to a path that doesn’t exist and to try to launch something. Because dyld ignores environment variables for restricted processes, it’s best to test this with an unsigned executable. This can also be done with a simple executable on the system if SIP is disabled or if a copy of the executable is made in a non-restricted location.\r\n\r\nEither compile and run the attached test program:\r\n\r\n$ clang++ -std=c++11 dyld_fatal_error_test.cc -o dyld_fatal_error_test\r\n$ ./dyld_fatal_error_test\r\n\r\nor run any executable with DYLD_INSERT_LIBRARIES set to a value that causes a dyld fatal error (here, a copy of /usr/bin/true is made in /tmp to exclude it from SIP enforcement):\r\n\r\n$ cp /usr/bin/true /tmp/true\r\n$ DYLD_INSERT_LIBRARIES=/var/empty/NoDirectory/NoFile /tmp/true\r\n\r\nExpected Results:\r\n$ ./dyld_fatal_error_test\r\ndyld: could not load inserted library '/var/empty/NoDirectory/NoFile' because image not found\r\n\r\npid 12345 terminated by signal 6 (Abort trap: 6)\r\n\r\nor\r\n\r\n$ DYLD_INSERT_LIBRARIES=/var/empty/NoDirectory/NoFile /tmp/true\r\ndyld: could not load inserted library '/var/empty/NoDirectory/NoFile' because image not found\r\n\r\nAbort trap: 6\r\n$ echo $?\r\n134\r\n\r\nActual Results:\r\n$ ./dyld_fatal_error_test\r\ndyld: could not load inserted library '/var/empty/NoDirectory/NoFile' because image not found\r\n\r\npid 12345 exited with code 1\r\n\r\nor\r\n\r\n$ DYLD_INSERT_LIBRARIES=/var/empty/NoDirectory/NoFile /tmp/true\r\ndyld: could not load inserted library '/var/empty/NoDirectory/NoFile' because image not found\r\n\r\n$ echo $?\r\n1\r\n\r\nVersion:\r\n10.12dp1 16A201w\r\n\r\n--\r\n\r\ndyld_fatal_error_test.cc\r\n\r\n// clang++ -std=c++11 dyld_fatal_error_test.cc -o dyld_fatal_error_test\r\n\r\n#include <err.h>\r\n#include <mach-o/dyld.h>\r\n#include <stdint.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/wait.h>\r\n#include <unistd.h>\r\n\r\n#include <string>\r\n\r\nnamespace {\r\n\r\nstd::string ExecutablePath() {\r\n  uint32_t executable_length = 0;\r\n  _NSGetExecutablePath(nullptr, &executable_length);\r\n  std::string executable_path(executable_length - 1, std::string::value_type());\r\n  int rv = _NSGetExecutablePath(&executable_path[0], &executable_length);\r\n  if (rv != 0) {\r\n    errx(EXIT_FAILURE, \"_NSGetExecutablePath\");\r\n  }\r\n\r\n  return executable_path;\r\n}\r\n\r\n}  // namespace\r\n\r\nint main(int argc, char* argv[]) {\r\n  if (argc == 2 && strcmp(argv[1], \"child\") == 0) {\r\n    return EXIT_SUCCESS;\r\n  }\r\n\r\n  std::string executable_path = ExecutablePath();\r\n  int rv = setenv(\"DYLD_INSERT_LIBRARIES\", \"/var/empty/NoDirectory/NoFile\", 1);\r\n  if (rv == -1) {\r\n    err(EXIT_FAILURE, \"setenv\");\r\n  }\r\n\r\n  pid_t pid = fork();\r\n  if (pid == -1) {\r\n    err(EXIT_FAILURE, \"fork\");\r\n  }\r\n\r\n  if (pid == 0) {\r\n    // Child\r\n    execl(executable_path.c_str(), argv[0], \"child\", nullptr);\r\n    err(EXIT_FAILURE, \"execl\");\r\n  }\r\n\r\n  int status;\r\n  pid_t waitpid_rv = waitpid(pid, &status, 0);\r\n  if (waitpid_rv == -1) {\r\n    err(EXIT_FAILURE, \"waitpid\");\r\n  }\r\n\r\n  if (WIFEXITED(status)) {\r\n    printf(\"pid %d exited with code %d\\n\", pid, WEXITSTATUS(status));\r\n  } else if (WIFSIGNALED(status)) {\r\n    int sig = WTERMSIG(status);\r\n    printf(\"pid %d terminated by signal code %d (%s)%s\\n\",\r\n           pid,\r\n           sig,\r\n           strsignal(sig),\r\n           WCOREDUMP(status) ? \" (core dumped)\" : \"\");\r\n  } else {\r\n    printf(\"pid %d unknown status 0x%x\\n\", pid, status);\r\n  }\r\n\r\n  return EXIT_SUCCESS;\r\n}"
    email: mark@chromium.org
    modified: "2016-07-06T17:13:40.68636Z"
    number: "26894758"
    number_intvalue: 26894758
    originated: "2016-06-20"
    parent_number: "26829150"
    product: OS X
    product_version: 10.12dp1 16A201w
    reproducible: Always
    resolved: ""
    status: Duplicate/26829150
    title: dyld fatal errors via abort_with_payload are indistinguishable from normal process exit(1)
