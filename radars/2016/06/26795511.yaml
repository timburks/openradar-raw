apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "26795511"
    labels:
        datastore_id: "5494662156517376"
data:
    classification: Bug
    created: "2016-06-14T19:12:43.67988Z"
    description: "Summary:\r\nIf we insertItemsAtIndexPath into a UICollectionView which has been just created with CGRectZero frame (actually, CGSizeZero bounds.size), the collection view calls cellForItemAtIndexPath for absolutely all items in a data source. That means no cells get reused and therefore it can potentially allocate enormous amount of memory before it even went on screen.\r\n\r\nIn case of the flow layout, UICollectionViewFlowLayoutDelegate's sizeForItemAtIndexPath is never called either to get a proper cell size and see it's actually off bounds.\r\n\r\nlayoutAttributesForItemAtIndexPath on the layout object does get called and returns CGRectZero frame for all items. That's probably why the collection view thinks all items are visible and so creates cells for each of them.\r\n\r\nTo resolve this the collection view should never call cellForItemAtIndexPath until it has beed laid out and got any real initial bounds size instead of CGSizeZero.\r\n\r\nAs a workaround we could set a flag in layoutSubviews (for UICollectionView subclasses) or viewDidLayoutSubviews (for view controllers) and then call insertItemsAtIndexPath only after that flag is set, meaning the collection view had a chance to layout for the first time.\r\n\r\nSteps to Reproduce:\r\nCompile and run the following code:\r\n\r\n#define LOAD_ALL_CELLS YES  // Change to NO to load only visible cells as it should be.\r\n\r\n@interface ViewController : UIViewController<UICollectionViewDelegate, UICollectionViewDataSource>\r\n@end\r\n\r\n@implementation ViewController {\r\n    UICollectionView *_collectionView;\r\n    NSUInteger _numberOfItems;\r\n}\r\n\r\n- (void)viewDidLoad\r\n{\r\n    [super viewDidLoad];\r\n    UIView *view = self.view;\r\n\r\n    // Let's setup a collection view with bounds.size equal either CGSizeZero or something else.\r\n    // When bounds.size is CGRectZero the collection view will create cells for absolutely all items\r\n    // in a data source on insertItemsAtIndexPaths no matter if they're evetually visible or not.\r\n    // It doesn't ask the UICollectionViewFlowLayoutDelegate for the size of items either.\r\n    CGPoint origin = view.bounds.origin;\r\n    CGSize size = LOAD_ALL_CELLS ? CGSizeZero : view.bounds.size;\r\n    _collectionView = [[UICollectionView alloc] initWithFrame:(CGRect){.origin = origin, .size = size}\r\n                                         collectionViewLayout:[UICollectionViewFlowLayout new]];\r\n\r\n    // Following with some typical workflow.\r\n    _collectionView.translatesAutoresizingMaskIntoConstraints = NO;\r\n    _collectionView.delegate = self;\r\n    _collectionView.dataSource = self;\r\n    [_collectionView registerClass:[UICollectionViewCell class]\r\n        forCellWithReuseIdentifier:NSStringFromClass([UICollectionViewCell class])];\r\n    [view addSubview:_collectionView];\r\n    [NSLayoutConstraint activateConstraints:@[\r\n      [view.leadingAnchor constraintEqualToAnchor:_collectionView.leadingAnchor],\r\n      [view.topAnchor constraintEqualToAnchor:_collectionView.topAnchor],\r\n      [view.trailingAnchor constraintEqualToAnchor:_collectionView.trailingAnchor],\r\n      [view.bottomAnchor constraintEqualToAnchor:_collectionView.bottomAnchor],\r\n    ]];\r\n\r\n    // Now let's load some data.\r\n    NSArray<NSIndexPath *> *indexPaths = @[\r\n      [NSIndexPath indexPathForItem:0 inSection:0],\r\n      [NSIndexPath indexPathForItem:1 inSection:0],\r\n      [NSIndexPath indexPathForItem:2 inSection:0],\r\n    ];\r\n    [_collectionView numberOfItemsInSection:0];  // See rdar://26484150 on why this is needed.\r\n    _numberOfItems = indexPaths.count;  // Modify the model before inserting items.\r\n\r\n    // The following loads exactly _numberOfItems distinct cells if LOAD_ALL_CELLS == YES.\r\n    [_collectionView insertItemsAtIndexPaths:indexPaths];\r\n}\r\n\r\n- (NSInteger)collectionView:(UICollectionView *)collectionView\r\n     numberOfItemsInSection:(NSInteger)section {\r\n    return _numberOfItems;\r\n}\r\n\r\n// When collectionView.bounds is CGRectZero this method is called for absolutely ALL items.\r\n// Generated cells are all unique, so enormous amount of memory can be allocated.\r\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView\r\n                  cellForItemAtIndexPath:(NSIndexPath *)indexPath {\r\n    UICollectionViewCell *cell =\r\n        [collectionView dequeueReusableCellWithReuseIdentifier:NSStringFromClass([UICollectionViewCell class])\r\n                                                  forIndexPath:indexPath];\r\n    cell.backgroundColor = [UIColor blueColor];\r\n    return cell;\r\n}\r\n\r\n// When collectionView.bounds is CGRectZero this method is never called.\r\n- (CGSize)collectionView:(UICollectionView *)collectionView\r\n                  layout:(UICollectionViewLayout*)collectionViewLayout\r\n  sizeForItemAtIndexPath:(NSIndexPath *)indexPath {\r\n    return collectionView.bounds.size;\r\n}\r\n\r\n@end\r\n\r\nExpected Results:\r\nUICollectionView doesn't create cells for all items in a data source when it's initial bounds.size is CGSizeZero on insertItemsAtIndexPath.\r\n\r\nIdeally it should only ask for the number of items in affected sections on insertItemsAtIndexPath and never try to load cells if it wasn't laid out itself just yet.\r\n\r\nActual Results:\r\nUICollectionView creates cells for absolutely all items in a data source and therefore consumes an enormous amount of memory."
    email: anthony@shoumikh.in
    modified: "2016-06-14T19:12:43.68006Z"
    number: "26795511"
    number_intvalue: 26795511
    originated: 6/14/2016
    parent_number: '&{NULL_VALUE}'
    product: iOS
    product_version: 9.3.2
    reproducible: Always
    resolved: ""
    status: Open
    title: UICollectionView calls cellForItemAtIndexPath for absolutely all items in a data source on insertItemsAtIndexPath when created with CGSizeZero bounds size.
