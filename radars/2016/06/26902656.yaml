apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "26902656"
    labels:
        datastore_id: "4603855673229312"
data:
    classification: Serious Bug
    created: "2016-06-20T22:11:12.25275Z"
    description: "Summary:\r\n10.12dp1 seems to impose new rules on inheritance of task exception ports through the exec family of calls. Based on experimentation, it seems that task exception ports are cleared on exec unless the invoker is signed by Apple or the invoker and invokee are signed with the same team ID.\r\n\r\nThis is a bit frustrating for my crash reporting platform, which relies on the inheritance of exception ports. Only our release builds are ever signed. Ordinary developer builds are never signed, and in fact, most of our developers don’t even have their own signing identities.\r\n\r\nThis scheme would be more workable if task exception port inheritance were permitted in cases where the invoker and invokee are the same executable, even if unsigned. Because the signing requirement seems to be based on establishing equivalent identity (through the use of the team ID), it should also be possible to establish equivalent identity based on the invoker and invokee being identical executables.\r\n\r\nThe attached test program prints its task exception ports, re-execs itself, prints its task exception ports again, and then calls abort(). When run on 10.11, the set of exception ports are identical in both cases, and the abort() crash is handled by the appropriate task-level handler, normally ReportCrash. This also happens when signed and run on 10.12, but when unsigned and run on 10.12, the re-execed process has its task exception ports cleared, and no task-level handler is invoked for the abort() crash. (Instead, a host-level handler is).\r\n\r\nIn the example, I show the system’s crash reporter being used as the exception handler for brevity. In my actual environment, I provide my own exception handler, and not having crashes delivered to it is a big deal.\r\n\r\nThis is notably a problem in developer builds which are never signed. I envision that it’s also a problem in any instance where users build their own shells and wind up having any child process of their shell inadvertently lose access to the user-level ReportCrash. Furthermore, I am skeptical that this approach provides any real improved security when it’s possible to retain exception ports on exec from Apple-signed executables that can easily run user code such as Python. It’s incongruous to deny this longstanding ability to native code.\r\n\r\nSteps to Reproduce:\r\n$ clang++ -std=c++11 exec_exception_ports.cc -o exec_exception_ports\r\n$ ./exec_exception_ports\r\n$ codesign --sign 'your signing identity' exec_exception_ports\r\n$ ./exec_exception_ports\r\n\r\nExpected Results:\r\nWhether unsigned or signed, exec_exception_ports should produce output similar to:\r\n\r\n$ ./exec_exception_ports\r\n2 task exception handlers:\r\nmask 0x7fe: no handler\r\nmask 0x3800: port 0xb03, behavior 0x80000003, flavor 7\r\nre-execing\r\n2 task exception handlers:\r\nmask 0x7fe: no handler\r\nmask 0x3800: port 0x10b, behavior 0x80000003, flavor 7\r\nAbort trap: 6\r\n\r\nThe abort crash should be handled by the task-level exception handler, in this case the EXC_CORPSE_NOTIFY handler in the user com.apple.ReportCrash launch agent job. This produces a crash report in ~/Library/Logs/DiagnosticReports.\r\n\r\nActual Results:\r\nWhen unsigned, exec_exception_ports produces output like this:\r\n\r\n$ ./exec_exception_ports\r\n2 task exception handlers:\r\nmask 0x7fe: no handler\r\nmask 0x3800: port 0xb03, behavior 0x80000003, flavor 7\r\nre-execing\r\n2 task exception handlers:\r\nmask 0x7fe: no handler\r\nmask 0x3800: no handler\r\nAbort trap: 6\r\n\r\nThis indicates that although a task EXC_CORPSE_NOTIFY handler was registered, it has been cleared in the re-execed process. There is no task-level exception handler to pick up the abort crash, so no crash report is produced in ~/Library/Logs/DiagnosticReports. The host exception handler in the system com.apple.ReportCrash.Root launch daemon job will pick it up, producing a crash report in /Library/Logs/DiagnosticReports.\r\n\r\nIt’s a problem that there isn’t a way to inherit a user exception port at the task level across an exec. It ought to be possible to do this when equivalent identity is established, and having the same executable exec itself should be sufficient to establish equivalent identity.\r\n\r\nVersion:\r\n10.12dp1 16A201w\r\n\r\n--\r\nexec_exception_ports.cc\r\n\r\n// clang++ -std=c++11 exec_exception_ports.cc -o exec_exception_ports\r\n\r\n#include <err.h>\r\n#include <mach-o/dyld.h>\r\n#include <mach/mach.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n#include <string>\r\n\r\nnamespace {\r\n\r\nstd::string ExecutablePath() {\r\n  uint32_t executable_length = 0;\r\n  _NSGetExecutablePath(nullptr, &executable_length);\r\n  std::string executable_path(executable_length - 1, std::string::value_type());\r\n  int rv = _NSGetExecutablePath(&executable_path[0], &executable_length);\r\n  if (rv != 0) {\r\n    errx(EXIT_FAILURE, \"_NSGetExecutablePath\");\r\n  }\r\n\r\n  return executable_path;\r\n}\r\n\r\n}  // namespace\r\n\r\nint main(int argc, char* argv[]) {\r\n  const size_t kMaxPorts = 32;\r\n  mach_msg_type_number_t count = kMaxPorts;\r\n  exception_mask_t masks[kMaxPorts];\r\n  exception_handler_t ports[kMaxPorts];\r\n  exception_behavior_t behaviors[kMaxPorts];\r\n  thread_state_flavor_t flavors[kMaxPorts];\r\n\r\n  const exception_mask_t kExceptionMask =\r\n      EXC_MASK_ALL | EXC_MASK_CRASH | EXC_MASK_CORPSE_NOTIFY;\r\n  kern_return_t kr = task_get_exception_ports(mach_task_self(),\r\n                                              kExceptionMask,\r\n                                              masks,\r\n                                              &count,\r\n                                              ports,\r\n                                              behaviors,\r\n                                              flavors);\r\n\r\n  if (kr != KERN_SUCCESS) {\r\n    errx(EXIT_FAILURE,\r\n         \"task_get_exception_ports: %s (0x%x)\",\r\n         mach_error_string(kr),\r\n         kr);\r\n  }\r\n\r\n  printf(\"%d task exception handler%s%s\\n\",\r\n         count,\r\n         count == 1 ? \"\" : \"s\",\r\n         count == 0 ? \"\" : \":\");\r\n  for (size_t i = 0; i < count; ++i) {\r\n    if (ports[i] == MACH_PORT_NULL) {\r\n      printf(\"mask 0x%x: no handler\\n\", masks[i]);\r\n    } else {\r\n      printf(\"mask 0x%x: port 0x%x, behavior 0x%x, flavor %d\\n\",\r\n             masks[i],\r\n             ports[i],\r\n             behaviors[i],\r\n             flavors[i]);\r\n    }\r\n  }\r\n  const char kReexecArg[] = \"exec\";\r\n\r\n  if (!(argc == 2 && strcmp(argv[1], kReexecArg) == 0)) {\r\n    std::string executable_path = ExecutablePath();\r\n\r\n    printf(\"re-execing\\n\");\r\n    execl(executable_path.c_str(), argv[0], kReexecArg, nullptr);\r\n    err(EXIT_FAILURE, \"execl\");\r\n  } else {\r\n    abort();\r\n  }\r\n\r\n  return EXIT_SUCCESS;\r\n}"
    email: mark@chromium.org
    modified: "2016-07-12T13:21:22.25042Z"
    number: "26902656"
    number_intvalue: 26902656
    originated: "2016-06-20"
    parent_number: "19362779"
    product: OS X
    product_version: 10.12dp1 16A201w
    reproducible: ""
    resolved: ""
    status: Duplicate/19362779
    title: 'xnu: Allow same-executable inheritance of task exception ports through exec even when unsigned'
