apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "28943305"
    labels:
        datastore_id: "6176285663428608"
data:
    classification: Serious Bug
    created: "2016-10-25T20:21:31.25347Z"
    description: "NSNetServiceBrowser and NSNetService each have a delegate. In the normal Cocoa pattern, they do not take references to their delegates, they merely hold a weak reference. They apparently use a zeroing weak reference (__weak), whose purpose is to clear the delegate pointers in NSNetServiceBrowser and NSNetService objects should their delegates be deallocated first.\r\n\r\nIt appears that when NSNetServiceBrowser or NSNetService are deallocated prior to the delegate, the fact that they have been deallocated and thus no longer maintain references to their delegates is not recorded anywhere. Consequently, during deallocation of the delegates, the Objective-C runtime attempts to clear the delegate pointers in NSNetServiceBrowser and NSNetService, which are invalid because those objects no longer exist and the memory that hosted them may have been repurposed.\r\n\r\nWhen this occurs, the Objective-C runtime may detect that the delegate field of the NSNetServiceBrowser or NSNetService object does not contain a pointer to the object being deallocated, but has instead been overwritten with something else. In this case, it log a warning like this:\r\n\r\nobjc[76391]: __weak variable at 0x100107110 holds 0x5555555555555555 instead of 0x100102760. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nThe attached test program exhibits this problem. When run, it allocates an NSNetServiceBrowser object and an NSNetService object, both of which are told to use the same newly-allocated delegate object. The three objects are then released, the delegate being released last. Upon release of the delegate, the attempts to clear the weak pointers in the other two objects will look to freed memory. Whether the memory has been repurposed or not is a factor of what else happens in the process, so when run as-is, the test case will only exhibit the problem (as evidenced by the objc_weak_error being logged) intermittently. To exhibit the problem with certainty, set the MallocScribble environment variable, which causes free() to overwrite freed blocks with a 0x55 pattern.\r\n\r\n$ clang -g weaksauce.m -o weaksauce -framework Foundation\r\n$ MallocScribble=1 ./weaksauce\r\nweaksauce(76587,0x7fffd1ada3c0) malloc: enabling scribbling to detect mods to free blocks\r\nobjc[76587]: __weak variable at 0x7fd669d05460 holds 0x5555555555555555 instead of 0x7fd669d03710. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nobjc[76587]: __weak variable at 0x7fd669d060b0 holds 0x5555555555550004 instead of 0x7fd669d03710. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nWhen MallocScribble is not set, the test program spins a run loop for a second before releasing the delegate to give the rest of the program something to do, which in many cases results in the memory for at least one of these objects being repurposed and having something written to it.\r\n\r\n$ ./weaksauce\r\nobjc[76634]: __weak variable at 0x7fd07c40b770 holds 0x7fffce91b218 instead of 0x7fd07c408a50. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nNote that the test program will tolerate being compiled both with and without ARC (-fobjc-arc). I have shown it here without ARC for clarity, because it allows |browser| and |service| to retain their values after deallocation, which allows their values to be inspected in the debugger in main()’s frame. This helps correlate the pointers in the objc_weak_error message to their previous uses.\r\n\r\nExpanding on this in the debugger:\r\n\r\n$ lldb weaksauce\r\n(lldb) target create \"weaksauce\"\r\nCurrent executable set to 'weaksauce' (x86_64).\r\n(lldb) env MallocScribble=1\r\n(lldb) b objc_weak_error\r\nBreakpoint 1: where = libobjc.A.dylib`objc_weak_error, address = 0x000000000002025a\r\n(lldb) r\r\nProcess 76625 launched: '…/weaksauce' (x86_64)\r\nweaksauce(76625,0x7fffd1ada3c0) malloc: enabling scribbling to detect mods to free blocks\r\nobjc[76625]: __weak variable at 0x1002046d0 holds 0x5555555555555555 instead of 0x1002005c0. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nProcess 76625 stopped\r\n* thread #1: tid = 0x4b2bd, 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\r\n    frame #0: 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error\r\nlibobjc.A.dylib`objc_weak_error:\r\n->  0x7fffc84e8261 <+0>: pushq  %rbp\r\n    0x7fffc84e8262 <+1>: movq   %rsp, %rbp\r\n    0x7fffc84e8265 <+4>: popq   %rbp\r\n    0x7fffc84e8266 <+5>: retq   \r\n(lldb) bt\r\n* thread #1: tid = 0x4b2bd, 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\r\n  * frame #0: 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error\r\n    frame #1: 0x00007fffc84d7a5b libobjc.A.dylib`weak_clear_no_lock + 141\r\n    frame #2: 0x00007fffc84d797c libobjc.A.dylib`objc_object::clearDeallocating_slow() + 104\r\n    frame #3: 0x00007fffc84d1103 libobjc.A.dylib`objc_destructInstance + 153\r\n    frame #4: 0x00007fffc84d1059 libobjc.A.dylib`object_dispose + 22\r\n    frame #5: 0x00000001000018e3 weaksauce`main(argc=1, argv=0x00007fff5fbff9a8) + 371 at weaksauce.m:37\r\n    frame #6: 0x00007fffc8dbb255 libdyld.dylib`start + 1\r\n    frame #7: 0x00007fffc8dbb255 libdyld.dylib`start + 1\r\n(lldb) frame sel 5\r\nframe #5: 0x00000001000018e3 weaksauce`main(argc=1, argv=0x00007fff5fbff9a8) + 371 at weaksauce.m:37\r\n   34  \t    }\r\n   35  \t\r\n   36  \t#if !__has_feature(objc_arc)\r\n-> 37  \t    [delegate release];\r\n   38  \t#endif\r\n   39  \t  }\r\n   40  \t\r\n(lldb) frame variable \r\n(int) argc = 1\r\n(char **) argv = 0x00007fff5fbff9a8\r\n(Delegate *) delegate = 0x00000001002005c0\r\n(NSNetServiceBrowser *) browser = 0x00000001002046c0\r\n(NSNetService *) service = 0x0000000100207020\r\n(lldb) c\r\nProcess 76625 resuming\r\nobjc[76625]: __weak variable at 0x100207030 holds 0x5555555555550004 instead of 0x1002005c0. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nProcess 76625 stopped\r\n* thread #1: tid = 0x4b2bd, 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\r\n    frame #0: 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error\r\nlibobjc.A.dylib`objc_weak_error:\r\n->  0x7fffc84e8261 <+0>: pushq  %rbp\r\n    0x7fffc84e8262 <+1>: movq   %rsp, %rbp\r\n    0x7fffc84e8265 <+4>: popq   %rbp\r\n    0x7fffc84e8266 <+5>: retq   \r\n(lldb) bt\r\n* thread #1: tid = 0x4b2bd, 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\r\n  * frame #0: 0x00007fffc84e8261 libobjc.A.dylib`objc_weak_error\r\n    frame #1: 0x00007fffc84d7a5b libobjc.A.dylib`weak_clear_no_lock + 141\r\n    frame #2: 0x00007fffc84d797c libobjc.A.dylib`objc_object::clearDeallocating_slow() + 104\r\n    frame #3: 0x00007fffc84d1103 libobjc.A.dylib`objc_destructInstance + 153\r\n    frame #4: 0x00007fffc84d1059 libobjc.A.dylib`object_dispose + 22\r\n    frame #5: 0x00000001000018e3 weaksauce`main(argc=1, argv=0x00007fff5fbff9a8) + 371 at weaksauce.m:37\r\n    frame #6: 0x00007fffc8dbb255 libdyld.dylib`start + 1\r\n    frame #7: 0x00007fffc8dbb255 libdyld.dylib`start + 1\r\n(lldb) c\r\nProcess 76625 resuming\r\nProcess 76625 exited with status = 0 (0x00000000) \r\n(lldb) q\r\n\r\nGiven the known values stored in |delegate| (0x1002005c0), |browser| (0x1002046c0) and |service| (0x100207020) during this run, a more complete understanding of these messages is possible:\r\n\r\nobjc[76625]: __weak variable at 0x1002046d0 holds 0x5555555555555555 instead of 0x1002005c0. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\nobjc[76625]: __weak variable at 0x100207030 holds 0x5555555555550004 instead of 0x1002005c0. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nThe first message refers to an instance variable within |browser| at offset 0x10 (0x1002046d0 - 0x1002046c0), which was expected to contain a pointer to |delegate|, but was instead found with the value 0x5555555555555555, the MallocScribble free() pattern, because |browser| has already been deallocated. The second message is the same, but it refers to an instance variable within |service| at offset 0x10 (0x100207030 - 0x100207020). Note that in the second message, the observed value is 0x5555555555550004, an indication that malloc() has already given this memory out to another caller after the preceding free(), and that a new value has already been written to it.\r\n\r\n--\r\nSteps to Reproduce\r\n\r\n$ clang -g weaksauce.m -o weaksauce -framework Foundation\r\n$ MallocScribble=1 ./weaksauce\r\n\r\nExpected Results\r\n\r\nNo output other than a message from libmalloc saying that MallocScribble has been enabled:\r\n\r\n$ MallocScribble=1 ./weaksauce\r\nweaksauce(76756,0x7fffd1ada3c0) malloc: enabling scribbling to detect mods to free blocks\r\n$ \r\n\r\n--\r\nActual Results\r\n\r\nobjc_weak_error messages are logged, indicating that the objc_weak system has attempted to access freed memory indicated by the MallocScribble free() pattern, 0x55:\r\n\r\n$ MallocScribble=1 ./weaksauce\r\nweaksauce(76756,0x7fffd1ada3c0) malloc: enabling scribbling to detect mods to free blocks\r\nobjc[76756]: __weak variable at 0x7f8879c08ff0 holds 0x5555555555555555 instead of 0x7f8879c08a50. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\nobjc[76756]: __weak variable at 0x7f8879c0b770 holds 0x5555555555550004 instead of 0x7f8879c08a50. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.\r\n\r\n$ \r\n\r\n--\r\nmacOS Version/Build\r\n\r\n10.12.1 16B2555\r\nXcode 8.0 8A218a"
    email: mark@chromium.org
    modified: "2016-10-25T20:21:31.25366Z"
    number: "28943305"
    number_intvalue: 28943305
    originated: "2016-10-25"
    parent_number: '&{NULL_VALUE}'
    product: macOS
    product_version: 10.12.1 16B2555
    reproducible: Always
    resolved: ""
    status: Open
    title: NSNetServiceBrowser and NSNetService’s delegates are not properly __weak, objc_weak_error observed
