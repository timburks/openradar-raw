apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB13408735
    labels:
        datastore_id: "5537986653454336"
data:
    classification: Suggestion
    created: "2023-11-25T00:11:11.267628Z"
    description: "It is a common pattern to have a nested UI where the upper level shows a list of items and the lower level shows a list of items related to the selected item in the upper level. For example, the Notes app shows a list of folders and then shows a list of notes after a folder is selected. This can be modeled in SwiftData as a “parent” `PersistentModel` that has a one-to-many relationship to a “child” `PersistentModel`.\r\n\r\nThe UI showing the list of children needs to be able to filter/sort the list of children. Naïvely, we could just access the array of children on the parent and use Swift’s standard `.filter` and `.sorted` on the array. However, this is inefficient because the children are actually Core Data faults that need to be realized one by one.\r\n\r\nInstead, it would be more efficient to use `Query`/`FetchDescriptor` to filter/sort in a single SQLite query without having to realize faults one by one. For example:\r\n```\r\nstruct ChildrenView: View {\r\n  @Query\r\n  private var children: [Child]\r\n\r\n  init(parent: Parent) {\r\n    let parentID = parent.persistentModelID\r\n    _children = Query(\r\n      filter: #Predicate {\r\n        $0.parent?.persistentModelID == parentID &&\r\n        …\r\n      },\r\n      sort: …\r\n    )\r\n  }\r\n\r\n  …\r\n}\r\n```\r\n\r\nThere are a couple issues with this approach: inconvenience, and relying on implementation details of the `@Query` macro. First, notice how the filter needs to explicitly match the parent ID. This requires the child model to explicitly specify a relationship to the parent. The explicit inverse relationship and the explicit matching are inconvenient. Second, notice how we are setting a private property that was generated by the `@Query` macro. Technically, we could explicitly define a `Query<Child, [Child]>` property without using the macro to avoid this; but that would be inconvenient because we would always need to write `children.wrappedValue` whenever we wanted to access the value.\r\n\r\nInstead, it would be great if we could filter/sort via the parent directly. A possible design would be to introduce a new collection type, say `ManyRelationship`, that could be used as the relationship type instead of `Array`. This new type could have a `.query` method that allows the caller to filter/sort using a single SQLite query. For example:\r\n```\r\n@Model\r\nstruct Parent {\r\n  var children = ManyRelationship<Child>()\r\n}\r\n\r\nstruct ChildrenView: View {\r\n  private var children: ManyRelationship<Child>\r\n\r\n  init(parent: Parent) {\r\n    self.children = parent.children.query(\r\n      filter: #Predicate {\r\n        …\r\n      },\r\n      sort: …\r\n    )\r\n  }\r\n\r\n  var body: some View {\r\n    List(children) { child in\r\n      …\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis would be very convenient for developers! (It would also avoid the inaccuracy of specifying an unordered many relationship as an `Array`.)"
    email: darren.mo@me.com
    modified: "2023-11-25T00:11:11.267768Z"
    number: FB13408735
    number_intvalue: 13408735
    originated: "2023-11-24"
    parent_number: '&{NULL_VALUE}'
    product: SwiftData
    product_version: iOS 17.2 Seed 3 (21C5046c)
    reproducible: ""
    resolved: ""
    status: Open
    title: Provide convenient API to efficiently filter/sort relationship
