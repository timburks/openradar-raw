apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "10962421"
    labels:
        datastore_id: "1567402"
data:
    classification: Enhancement
    created: "2012-03-01T15:07:56.511503Z"
    description: "NSRect/CGRect (and similar structs like NSPoint and NSSize) are error-prone and can be tough to use due to the multitude of coordinate spaces we deal with. Many new Cocoa programmers don't understand the difference between bounds/frame and tend to resort to trial and error to pick the right one. In cases where frame and bounds happen to be numerically similar, an error can persist in code for a long time.\r\n\r\nMy understanding is that NSRect and friends are structs mainly for efficiency reasons which were a big deal back when this stuff could be expected to run on a 25MHz 68040. This is probably less important today.\r\n\r\nI propose a new class, let's call it NSRectangle, which would encompass the functionality of NSRect but would hold not only its origin and size but also its coordinate system. An NSRectangle object could be passed around from one view to another or from one window to another without needing to do any manual conversions, as the object would hold enough information to do them on its own. Something painful and error prone like lining up a window with an NSView's on-screen location would become a simple matter of initializing the window with [view frameRectangle] (assuming -frameRectangle is an equivalent to -frame which returns an NSRectangle object).\r\n\r\nThere are obviously a lot of compatibility concerns which would require keeping the old structs around pretty much indefinitely. However, I think these new classes could still bring a lot of benefit and supersede the structs in a lot of cases.\r\n\r\n01-Mar-2012 03:30 PM Michael Ash:\r\nHere are some code examples of how this class might work and be used:\r\n\r\n    // position a subview in the bottom middle of this view\r\n    NSRectangle *frame = [self frameRectangle];\r\n    [frame setHeight: [frame height] / 2];\r\n    [frame setOriginX: [frame width] * 3 / 4];\r\n    [frame setWidth: [frame width] / 2];\r\n    [subview setFrameRectangle: frame];\r\n    \r\n    // position a window directly over this view\r\n    NSRectangle *frame = [self frameRectangle];\r\n    NSWindow *window = [[NSWindow alloc] initWithFrameRectangle: frame ...];\r\n    [window orderFront: nil];\r\n    \r\n    // position a window next to this view on the right\r\n    NSRectangle *frame = [self frameRectangle];\r\n    [frame setOriginX: [frame maxX]];\r\n    [frame setWidth: 42]; // 42 pixels in VIEW COORDINATES, may be different in screen coordinates, but we may want to size the window relative to view coordinates anyway\r\n    NSWindow *window = [[NSWindow alloc] initWithFrameRectangle: frame ...];\r\n    [window orderFront: nil];\r\n    \r\n    // position a window next to this view on the right, sized in screen coords\r\n    NSRectangle *frame = [self frameRectangle];\r\n    [frame setOriginX: [frame maxX]];\r\n    [frame setWidth: 42 inCoordinateSystem: [NSScreen coordinateSystem]];\r\n    NSWindow *window = [[NSWindow alloc] initWithFrameRectangle: frame ...];\r\n    [window orderFront: nil];\r\n    \r\n    // create a 200x200 window with origin at 100,100 on the screen\r\n    NSRectangle *rect = [NSRectangle rectangleWithRect: NSMakeRect(100, 100, 200, 200) inCoordinateSystem: [NSScreen coordinateSystem]];\r\n    NSWindow *window = [[NSWindow alloc] initWithFrameRectangle: rect ...];\r\n\r\n    // create a 200x200 window with origin at 100,100 relative to a view\r\n    NSRectangle *rect = [NSRectangle rectangleWithRect: NSMakeRect(100, 100, 200, 200) inCoordinateSystem: [view coordinateSystem]];\r\n    NSWindow *window = [[NSWindow alloc] initWithFrameRectangle: rect ...];\r\n    \r\n    // handling events\r\n    // NSPointObj is a hypothetical class version of the NSPoint struct\r\n    \r\n    // see if a mouse event is within this view\r\n    NSPointObj *loc = [theEvent location];\r\n    if([[self frameRectangle] containsPoint: loc])\r\n        ...\r\n    \r\n    // see if a mouse event is within various views\r\n    NSPointObj *loc = [theEvent location];\r\n    if(([[view1 frameRectangle] containsPoint: loc])\r\n        ...\r\n    else if(([[view2 frameRectangle] containsPoint: loc])\r\n        ...\r\n    else if(([[view3 frameRectangle] containsPoint: loc])\r\n        ...\r\n    // NOTE: view1, view2, and view3 don't need to be siblings for this to work\r\n    // in fact, they don't even need to be in the same window!"
    email: mike@mikeash.com
    modified: "2012-03-01T20:31:08.525996Z"
    number: "10962421"
    number_intvalue: 10962421
    originated: 01-Mar-2012 10:02 AM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X SDK
    product_version: any
    reproducible: Always
    resolved: ""
    status: Open
    title: Create NS/CGRect class which knows its own coordinate space
