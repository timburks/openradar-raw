apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "47395179"
    labels:
        datastore_id: "4984945948753920"
data:
    classification: ""
    created: "2019-02-07T17:17:38.86013Z"
    description: "The first frame in a AVAssetWriter session using the HEVC codec is excessively large, unless kVTCompressionPropertyKey_DataRateLimits is set.\r\n\r\n- (void)testHEVC {\r\n    NSURL *const outputUrl = [[[NSURL fileURLWithPath:NSTemporaryDirectory()]\r\n                               URLByAppendingPathComponent:[[NSUUID UUID] UUIDString]]\r\n                              URLByAppendingPathExtension:@\"mp4\"];\r\n    NSURL *const url = [[NSBundle bundleForClass:[self class]] URLForResource:@\"test-video\" withExtension:@\"mov\"];\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    AVAssetTrack *const videoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] firstObject];\r\n    NSError *error = nil;\r\n    AVAssetReader *const assetReader = [AVAssetReader assetReaderWithAsset:asset error:&error];\r\n    XCTAssertNil(error);\r\n    AVAssetWriter *const assetWriter = [AVAssetWriter assetWriterWithURL:outputUrl fileType:AVFileTypeMPEG4 error:&error];\r\n    XCTAssertNil(error);\r\n\r\n    NSInteger bitRate = 2.5e6;\r\n    AVAssetWriterInput *const input = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo\r\n                                                                     outputSettings:@{\r\n                                                                                      AVVideoCodecKey: AVVideoCodecTypeHEVC,\r\n                                                                                      AVVideoWidthKey: @(1280),\r\n                                                                                      AVVideoHeightKey: @(720),\r\n                                                                                      AVVideoCompressionPropertiesKey: @{\r\n                                                                                              AVVideoAverageBitRateKey: @(bitRate),\r\n                                                                                              // (NSString *)kVTCompressionPropertyKey_DataRateLimits: @[@(bitRate * 5.f / 8.f), @5]\r\n                                                                                              }\r\n                                                                                      }];\r\n\r\n    AVAssetReaderOutput *const output = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack\r\n                                                                         outputSettings:@{\r\n                                                                                          (id)kCVPixelBufferPixelFormatTypeKey:\r\n                                                                                              @(kCVPixelFormatType_32BGRA),\r\n                                                                                          }];\r\n\r\n    [assetReader addOutput:output];\r\n    [assetWriter addInput:input];\r\n\r\n    XCTAssertNil(assetReader.error);\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    [assetReader startReading];\r\n    [assetWriter startWriting];\r\n\r\n    [assetWriter startSessionAtSourceTime:kCMTimeZero];\r\n\r\n    const dispatch_queue_t queue = dispatch_queue_create(\"transcode\", DISPATCH_QUEUE_SERIAL);\r\n    const dispatch_semaphore_t transcode = dispatch_semaphore_create(0);\r\n    [input requestMediaDataWhenReadyOnQueue:queue usingBlock:^{\r\n        while ([input isReadyForMoreMediaData]) {\r\n            const CMSampleBufferRef sampleBuffer = [output copyNextSampleBuffer];\r\n\r\n            XCTAssertNil(assetReader.error);\r\n            XCTAssertNil(assetWriter.error);\r\n\r\n            if (sampleBuffer) {\r\n                [input appendSampleBuffer:sampleBuffer];\r\n                CFRelease(sampleBuffer);\r\n            } else {\r\n                [input markAsFinished];\r\n                dispatch_semaphore_signal(transcode);\r\n            }\r\n        }\r\n    }];\r\n\r\n    dispatch_semaphore_wait(transcode, DISPATCH_TIME_FOREVER);\r\n\r\n    const dispatch_semaphore_t write = dispatch_semaphore_create(0);\r\n    [assetWriter finishWritingWithCompletionHandler:^{\r\n        dispatch_semaphore_signal(write);\r\n    }];\r\n\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    dispatch_semaphore_wait(write, DISPATCH_TIME_FOREVER);\r\n\r\n    NSLog(@\"Wrote to %@\", outputUrl);\r\n}"
    email: cellsworth@gmail.com
    modified: "2019-02-07T17:17:38.860276Z"
    number: "47395179"
    number_intvalue: 47395179
    originated: 1/18/2019
    parent_number: '&{NULL_VALUE}'
    product: AVFoundation
    product_version: iOS 12.1
    reproducible: Always
    resolved: ""
    status: Open
    title: Encoding with HEVC creates excessively large first frame
