apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "7402900"
    labels:
        datastore_id: "5058259308249088"
data:
    classification: Bug
    created: "2019-10-23T15:22:25.328481Z"
    description: "To support bidirectional text in user interfaces, Unicode isolates (U+2068 and U+2069) need to be added around any string parameters (otherwise, a formatted string can incorrectly flip the direction of the text if a string parameter's text direction is not the same as the user interface direction).\r\n\r\nIn the \"What's New in International User Interfaces\" session at WWDC 2016:\r\n\r\nhttps://developer.apple.com/videos/play/wwdc2016/232\r\nhttps://asciiwwdc.com/2016/sessions/232\r\n\r\nString.localizedStringWithFormat() is documented to automatically add these Unicode isolates around any string parameter.\r\n\r\nIt's important to note isolates must be added *both* for right-to-left string parameters (like Arabic and Hebrew) as well as left-to-right string parameters (like English and Japanese), or otherwise UIs in Arabic which display English string parameters will be incorrectly flipped.\r\n\r\n=== Expected Behavior ===\r\n\r\nString.localizedStringWithFormat() should add Unicode isolates around any string parameter both for right-to-left string parameters (Arabic, Hebrew) and left-to-right string parameters (English, Japanese).\r\n\r\n=== Actual Behavior ===\r\n\r\nString.localizedStringWithFormat() only adds Unicode isolates around string parameters for right-to-left string parameters (Arabic, Hebrew). Result: UIs in Arabic and Hebrew are incorrectly flipped for any localized string which starts with a parameter containing left-to-right string content (English, Japanese).\r\n\r\n=== Steps To Reproduce ===\r\n\r\nCompile and run the attached repro case in main.swift:\r\n\r\n% swiftc -o repro main.swift\r\n% ./repro\r\n\r\nNote that the output adds U+2068 and U+2069 around right-to-left string parameters (Arabic, Hebrew, and Aramaic) but fails to add U+2068 and U+2069 around left-to-right string parameters (English, Japanese).\r\n\r\nThis reproduces both with String.localizedStringWithFormat() as well as String.init(format:, locale:, arguments:), across English, Arabic, and Japanese locales.\r\n\r\n% cat main.swift\r\ncat main.swift\r\nimport Foundation\r\n\r\nfunc escapeUnicodeScalars(_ s: String) -> String {\r\n    return s.unicodeScalars.map { $0.escaped(asASCII: true) }.reduce(\"\", +)\r\n}\r\n\r\nfunc formatStringWithUnicodeIsolates(_ s: String, _ l: Locale?) {\r\n    let formatted : String\r\n    if let l = l {\r\n        print(\"=== String(format: \\\"%@\\\", locale: \", l.identifier, \", \\\"\", s, \"\\\") ===\", separator: \"\")\r\n        formatted = String(format: \"%@\", locale: l, s)\r\n    } else {\r\n        print(\"=== String.localizedStringWithFormat(\\\"%@\\\", \\\"\", s, \"\\\") ===\", separator: \"\")\r\n        formatted = String.localizedStringWithFormat(\"%@\", s)\r\n    }\r\n    print(escapeUnicodeScalars(formatted), \"\\n\", separator: \"\")\r\n}\r\n\r\nlet rtlArabic = \"\\u{0645}\"\r\nlet rtlHebrew = \"\\u{05D0}\"\r\nlet rtlCypriot = \"\\u{10800}\"\r\nlet ltr = \"abc\"\r\nlet neutral = \"123\"\r\nlet cjk = \"\\u{6F22}\"\r\n\r\nlet ar_AR = Locale(identifier: \"ar_AR\")\r\nlet en_US = Locale(identifier: \"en_US\")\r\nlet ja_JP = Locale(identifier: \"ja_JP\")\r\n\r\nfor string in [rtlArabic, rtlHebrew, rtlCypriot, ltr, neutral, cjk] {\r\n    for locale in [nil, ar_AR, en_US, ja_JP] {\r\n        formatStringWithUnicodeIsolates(string, locale)\r\n    }\r\n}\r\n\r\n% swiftc -o repro main.swift\r\n% ./repro\r\n=== String.localizedStringWithFormat(\"%@\", \"م\") ===\r\n\\u{2068}\\u{0645}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: ar_AR, \"م\") ===\r\n\\u{2068}\\u{0645}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: en_US, \"م\") ===\r\n\\u{2068}\\u{0645}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: ja_JP, \"م\") ===\r\n\\u{2068}\\u{0645}\\u{2069}\r\n\r\n=== String.localizedStringWithFormat(\"%@\", \"א\") ===\r\n\\u{2068}\\u{05D0}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: ar_AR, \"א\") ===\r\n\\u{2068}\\u{05D0}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: en_US, \"א\") ===\r\n\\u{2068}\\u{05D0}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: ja_JP, \"א\") ===\r\n\\u{2068}\\u{05D0}\\u{2069}\r\n\r\n=== String.localizedStringWithFormat(\"%@\", \"\U00010800\") ===\r\n\\u{2068}\\u{00010800}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: ar_AR, \"\U00010800\") ===\r\n\\u{2068}\\u{00010800}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: en_US, \"\U00010800\") ===\r\n\\u{2068}\\u{00010800}\\u{2069}\r\n\r\n=== String(format: \"%@\", locale: ja_JP, \"\U00010800\") ===\r\n\\u{2068}\\u{00010800}\\u{2069}\r\n\r\n=== String.localizedStringWithFormat(\"%@\", \"abc\") ===\r\nabc\r\n\r\n=== String(format: \"%@\", locale: ar_AR, \"abc\") ===\r\nabc\r\n\r\n=== String(format: \"%@\", locale: en_US, \"abc\") ===\r\nabc\r\n\r\n=== String(format: \"%@\", locale: ja_JP, \"abc\") ===\r\nabc\r\n\r\n=== String.localizedStringWithFormat(\"%@\", \"123\") ===\r\n123\r\n\r\n=== String(format: \"%@\", locale: ar_AR, \"123\") ===\r\n123\r\n\r\n=== String(format: \"%@\", locale: en_US, \"123\") ===\r\n123\r\n\r\n=== String(format: \"%@\", locale: ja_JP, \"123\") ===\r\n123\r\n\r\n=== String.localizedStringWithFormat(\"%@\", \"漢\") ===\r\n\\u{6F22}\r\n\r\n=== String(format: \"%@\", locale: ar_AR, \"漢\") ===\r\n\\u{6F22}\r\n\r\n=== String(format: \"%@\", locale: en_US, \"漢\") ===\r\n\\u{6F22}\r\n\r\n=== String(format: \"%@\", locale: ja_JP, \"漢\") ===\r\n\\u{6F22}"
    email: foxden@gmail.com
    modified: "2019-10-23T15:22:25.328678Z"
    number: "7402900"
    number_intvalue: 7402900
    originated: "2019-10-23"
    parent_number: '&{NULL_VALUE}'
    product: Foundation
    product_version: All
    reproducible: 100%
    resolved: ""
    status: Open
    title: String.localizedStringWithFormat fails to add Unicode isolates around left-to-right parameters
