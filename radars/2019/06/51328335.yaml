apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "51328335"
    labels:
        datastore_id: "4987454423564288"
data:
    classification: ""
    created: "2019-06-01T09:41:21.787254Z"
    description: "In macOS Mavericks, the responsive scrolling architecture for NSScrollView was introduced which allows a smart way for generating overdraws and decouples handling of the incoming scroll events from the main event loop into a separate one. See WWDC 2013 / Session 215.\r\n\r\nBecause of the different event model, the scroll events no longer go through the scrollWheel(with:) method. In fact, if that method gets overridden in the NSScrollView (or the document view) subclass, the responsive scrolling architecture is disabled and the scrolling falls back to the legacy model.\r\n\r\nAfter the responsive scrolling event loop is entered, it is not possible to access the scroll events. Moreover, it’s not possible to control this event loop in any way. However, in certain situations, it would be helpful to be able to programmatically cancel the scrolling. For example if the command modifier key is pressed, it would be reasonable to perform magnification instead of scrolling as it’s done in the prominent graphics and diagramming applications like Sketch, OmniGraffle or MindNode.\r\n\r\nCurrently, it’s possible to take a different route for handling the scroll events only for the initial event which arrives in scrollWheel(with:). If the scrolling is in progress and the command key is pressed, there is no way to cancel the scrolling happening on the separate event handling loop in order to handle the upcoming events differently.\r\n\r\nSteps:\r\n1. Run the Mac app from attached Xcode project.\r\n2. Move the mouse to the scroll view, press and hold the command key and begin scrolling on a trackpad using two fingers.\r\n3. Without lifting the fingers, release the command key and continue the scroll gesture.\r\n4. Press and hold the command key again and continue the scroll gesture.\r\n\r\nExpected:\r\n1. The Mac app is launched.\r\n2. The scroll view is not scrolled but rather the messages for handling the scroll event in a different way are printed.\r\n3. The actual scrolling starts and goes on.\r\n4. The scrolling stops and the messages for handling the scroll event in a different way are printed again.\r\n\r\nActual:\r\n1. ✔︎\r\n2. ✔︎\r\n3. ✔︎\r\n4. The scrolling does not stop and there is no API to achieve it.\r\n\r\nIf I’m missing an already available API for achieving what I’ve described above, I’d be glad the hear about it. Thanks.\r\n\r\nSome further information can be found in my question on Stack Overflow: https://stackoverflow.com/questions/46785553/nsscrollview-magnify-with-cmdscroll-interaction-with-preserved-responsive-scro\r\n\r\n---------------------------------------------------------------------------------------------------------------------\r\n\r\nThe excerpt from the attached code:\r\n\r\ninternal final class CanvasView: NSView {\r\n    \r\n    // ======================================================= //\r\n    // MARK: - Configuration\r\n    // ======================================================= //\r\n    \r\n    override var acceptsFirstResponder: Bool {\r\n        return true\r\n    }\r\n    \r\n    override static var isCompatibleWithResponsiveScrolling: Bool {\r\n        return true\r\n    }\r\n    \r\n    // ======================================================= //\r\n    // MARK: - Event Handling\r\n    // ======================================================= //\r\n    \r\n    override func scrollWheel(with event: NSEvent) {\r\n        if event.modifierFlags.contains(.command) {\r\n            print(\"Handling scroll event as magnification (time=\\(event.timestamp))\")\r\n        } else {\r\n            print(\"Passing initial scroll event to super to trigger responsive scrolling\")\r\n            super.scrollWheel(with: event)\r\n        }\r\n    }\r\n    \r\n    private var _previousFlagsChangedEvent: NSEvent?\r\n    \r\n    override func flagsChanged(with event: NSEvent) {\r\n        let commandWasPressed = _previousFlagsChangedEvent?.modifierFlags.contains(.command) ?? false\r\n        let commandIsPressed = event.modifierFlags.contains(.command)\r\n        \r\n        defer { _previousFlagsChangedEvent = event }\r\n        \r\n        switch (commandWasPressed, commandIsPressed) {\r\n        case (false, true):\r\n            // Transition: scrolling -> magnification\r\n            //\r\n            // The scrolling which is being tracked on the separate loop has to be stopped in order\r\n            // to route the next scroll events through scrollWheel(with:) again.\r\n            print(\"Pressed CMD\")\r\n        case (true, false):\r\n            // Transition: magnification -> scrolling\r\n            //\r\n            // Since the next scroll event goes though scrollWheel(with:) the scrolling is correctly\r\n            // picked up.\r\n            print(\"Unpressed CMD\")\r\n        default:\r\n            break\r\n        }\r\n    }\r\n    \r\n    // ======================================================= //\r\n    // MARK: - Drawing\r\n    // ======================================================= //\r\n    \r\n    override func draw(_ dirtyRect: NSRect) {\r\n        NSColor.white.set()\r\n        dirtyRect.fill()\r\n        \r\n        let phrases = Array(repeating: \"Buttery smooth scrolling\", count: 500)\r\n        let string = phrases.joined(separator: \". \")\r\n        \r\n        NSString(string: string).draw(\r\n            in: bounds,\r\n            withAttributes: [\r\n                NSAttributedString.Key.foregroundColor: NSColor.lightGray\r\n            ]\r\n        )\r\n    }\r\n    \r\n}"
    email: kubanek.l@gmail.com
    modified: "2019-06-01T09:43:43.042038Z"
    number: "51328335"
    number_intvalue: 51328335
    originated: 01.06.2019
    parent_number: '&{NULL_VALUE}'
    product: macOS + SDK
    product_version: 10.14.5
    reproducible: Always
    resolved: no
    status: Open
    title: Enrich NSScrollView responsive scrolling API to allow for programatic cancellation
