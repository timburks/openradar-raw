apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "51204940"
    labels:
        datastore_id: "5031500554698752"
data:
    classification: Bug
    created: "2019-05-29T02:01:27.440706Z"
    description: "Summary:\r\n\r\nWhen using AVVideoMaxKeyFrameIntervalDurationKey in conjunction with AVVideoAverageBitRateKey, the resulting bitrate drops as keyframe interval decreases.\r\n\r\nThis is unlike kVTCompressionPropertyKey_DataRateLimits, which holds the same bitrate regardless of keyframe interval setting. Use of the latter is undesirable as it omits B-frames.\r\n\r\nSteps to Reproduce:\r\nSee attached code.\r\n\r\nBitrate is verified by the following ffprobe command:\r\n\r\nffprobe -v error $file -select_streams v:0 -show_entries stream=bit_rate -of default=noprint_wrappers=1\r\n\r\nExpected Results:\r\nAverage bitrate is maintained.\r\n\r\nActual Results:\r\nAverage bitrate is missed.\r\n\r\nVersion/Build:\r\niOS 12.3\r\n\r\nConfiguration:\r\nN/A\r\n\r\n-----\r\n\r\n- (void)test {\r\n    NSArray *const bitRates = @[\r\n                                @(2e6),\r\n                                @(3e6),\r\n                                @(4e6),\r\n                                @(5e6),\r\n                                @(7e6),\r\n                                @(9e6),\r\n                                @(12e6),\r\n                                @(15e6)\r\n                                ];\r\n\r\n    NSArray *const urls = @[\r\n                            [[NSBundle bundleForClass:[self class]] URLForResource:@\"file1\" withExtension:@\"mp4\"],\r\n                            [[NSBundle bundleForClass:[self class]] URLForResource:@\"file2\" withExtension:@\"mp4\"],\r\n                            [[NSBundle bundleForClass:[self class]] URLForResource:@\"file3\" withExtension:@\"mp4\"],\r\n                            ];\r\n\r\n    NSArray *const keyFrameIntervals = @[\r\n                                         @(0.f),\r\n                                         @(1.f),\r\n                                         @(2.f),\r\n                                         @(3.f),\r\n                                         @(4.f),\r\n                                         @(5.f),\r\n                                         ];\r\n\r\n    for (NSURL *url in urls) {\r\n        for (NSNumber *bitRate in bitRates) {\r\n            for (NSNumber *keyFrameInterval in keyFrameIntervals) {\r\n                for (NSNumber *drl in @[@1, @2, @3]) {\r\n                    [self testUrl:url bitRate:[bitRate floatValue] keyFrameInterval:[keyFrameInterval integerValue] drl:[drl integerValue]];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n- (void)testUrl:(NSURL *)url bitRate:(CGFloat)bitRate keyFrameInterval:(NSInteger)keyFrameInterval drl:(NSInteger)drl {\r\n\r\n    NSString *extension = nil;\r\n    if (drl == 1) {\r\n        extension = @\"avg\";\r\n    } else if (drl == 2) {\r\n        extension = @\"drl\";\r\n    } else if (drl == 3) {\r\n        extension = @\"both\";\r\n    }\r\n\r\n    NSString *filename = [NSString stringWithFormat:@\"test-%@-%ld-bps-%ld-s-%@\",\r\n                          [[url URLByDeletingPathExtension] lastPathComponent],\r\n                          (long)bitRate,\r\n                          (long)keyFrameInterval,\r\n                          extension];\r\n\r\n    NSURL *const outputUrl = [[[NSURL fileURLWithPath:NSTemporaryDirectory()]\r\n                               URLByAppendingPathComponent:filename]\r\n                              URLByAppendingPathExtension:@\"mp4\"];\r\n\r\n    if ([[NSFileManager defaultManager]fileExistsAtPath:outputUrl.path]) {\r\n        [[NSFileManager defaultManager] removeItemAtURL:outputUrl error:nil];\r\n    }\r\n\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    AVAssetTrack *const videoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] firstObject];\r\n    NSError *error = nil;\r\n    AVAssetReader *const assetReader = [AVAssetReader assetReaderWithAsset:asset error:&error];\r\n    XCTAssertNil(error);\r\n    AVAssetWriter *const assetWriter = [AVAssetWriter assetWriterWithURL:outputUrl fileType:AVFileTypeMPEG4 error:&error];\r\n    XCTAssertNil(error);\r\n\r\n    NSMutableDictionary *const compressionProperties = [NSMutableDictionary new];\r\n    compressionProperties[AVVideoProfileLevelKey] = AVVideoProfileLevelH264High41;\r\n    compressionProperties[AVVideoMaxKeyFrameIntervalDurationKey] = @(keyFrameInterval);\r\n\r\n    if (drl == 1 || drl == 3) {\r\n        compressionProperties[AVVideoAverageBitRateKey] = @(bitRate);\r\n    } else if (drl == 2 || drl == 3) {\r\n        compressionProperties[(id)kVTCompressionPropertyKey_DataRateLimits] = @[@(bitRate / 8.f), @1];\r\n    }\r\n\r\n    AVAssetWriterInput *const input = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo\r\n                                                                     outputSettings:@{\r\n                                                                                      AVVideoCodecKey: AVVideoCodecTypeH264,\r\n                                                                                      AVVideoWidthKey: @(videoTrack.naturalSize.width),\r\n                                                                                      AVVideoHeightKey: @(videoTrack.naturalSize.height),\r\n                                                                                      AVVideoCompressionPropertiesKey: compressionProperties\r\n                                                                                      }];\r\n\r\n    AVAssetReaderOutput *const output = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack\r\n                                                                         outputSettings:@{\r\n                                                                                          (id)kCVPixelBufferPixelFormatTypeKey:\r\n                                                                                              @(kCVPixelFormatType_32BGRA),\r\n                                                                                          }];\r\n\r\n    [assetReader addOutput:output];\r\n    [assetWriter addInput:input];\r\n\r\n    XCTAssertNil(assetReader.error);\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    [assetReader startReading];\r\n    [assetWriter startWriting];\r\n\r\n    [assetWriter startSessionAtSourceTime:kCMTimeZero];\r\n\r\n    const dispatch_queue_t queue = dispatch_queue_create(\"transcode\", DISPATCH_QUEUE_SERIAL);\r\n    const dispatch_semaphore_t transcode = dispatch_semaphore_create(0);\r\n    [input requestMediaDataWhenReadyOnQueue:queue usingBlock:^{\r\n        while ([input isReadyForMoreMediaData]) {\r\n            const CMSampleBufferRef sampleBuffer = [output copyNextSampleBuffer];\r\n\r\n            XCTAssertNil(assetReader.error);\r\n            XCTAssertNil(assetWriter.error);\r\n\r\n            if (sampleBuffer) {\r\n                [input appendSampleBuffer:sampleBuffer];\r\n                CFRelease(sampleBuffer);\r\n            } else {\r\n                [input markAsFinished];\r\n                dispatch_semaphore_signal(transcode);\r\n            }\r\n        }\r\n    }];\r\n\r\n    dispatch_semaphore_wait(transcode, DISPATCH_TIME_FOREVER);\r\n\r\n    const dispatch_semaphore_t write = dispatch_semaphore_create(0);\r\n    [assetWriter finishWritingWithCompletionHandler:^{\r\n        dispatch_semaphore_signal(write);\r\n    }];\r\n\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    dispatch_semaphore_wait(write, DISPATCH_TIME_FOREVER);\r\n\r\n    NSLog(@\"Wrote to %@\", outputUrl);\r\n}"
    email: cellsworth@gmail.com
    modified: "2019-05-29T02:01:27.440884Z"
    number: "51204940"
    number_intvalue: 51204940
    originated: "2019-05-28"
    parent_number: '&{NULL_VALUE}'
    product: AVFoundation
    product_version: ""
    reproducible: Always
    resolved: ""
    status: Open
    title: AVVideoAverageBitRateKey drops when AVVideoMaxKeyFrameIntervalDurationKey set
