apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "51127979"
    labels:
        datastore_id: "5011185493606400"
data:
    classification: Bug
    created: "2019-05-25T00:47:18.075283Z"
    description: "Summary:\r\n\r\nWhen used in the form @[(targetBitrate / 8.f), @1], where targetBitrate is the desired average bitrate in bits per second, the kVTCompressionPropertyKey_DataRateLimits setting can produce anything from an average bitrate of 80% to 150% of the target, depending on content and target bitrate. According to these docs, an average is expected to be maintained: https://developer.apple.com/library/archive/qa/qa1958/_index.html\r\n\r\nAVVideoAverageBitRateKey, in comparison, seems to do a much better job adhering, especially at higher bitrates.\r\n\r\nSteps to Reproduce:\r\nSee attached code.\r\n\r\nBitrates are derived by the following command:\r\nffprobe -v error $FILE -select_streams v:0 -show_entries stream=bit_rate -of default=noprint_wrappers=1\r\n\r\nExpected Results:\r\nTarget bitrates are roughly respected\r\n\r\nActual Results:\r\nTarget bitrates are often missed, in either direction.\r\n\r\nVersion/Build:\r\niOS 12.3\r\n\r\nConfiguration:\r\nN/A\r\n\r\n-----\r\n\r\n- (void)test {\r\n    NSArray *const bitRates = @[\r\n                                @(2e6),\r\n                                @(3e6),\r\n                                @(5e6),\r\n                                @(7e6),\r\n                                @(9e6),\r\n                                @(12e6),\r\n                                @(15e6)\r\n                                ];\r\n\r\n    NSArray *const urls = @[\r\n                            [[NSBundle bundleForClass:[self class]] URLForResource:@\"file1\" withExtension:@\"mp4\"],\r\n                            [[NSBundle bundleForClass:[self class]] URLForResource:@\"file2\" withExtension:@\"mp4\"],\r\n                            [[NSBundle bundleForClass:[self class]] URLForResource:@\"file3\" withExtension:@\"mp4\"],\r\n                            ];\r\n\r\n    for (NSURL *url in urls) {\r\n        for (NSNumber *bitRate in bitRates) {\r\n            [self testUrl:url bitRate:[bitRate floatValue]];\r\n        }\r\n    }\r\n}\r\n\r\n- (void)testUrl:(NSURL *)url bitRate:(CGFloat)bitRate {\r\n    NSString *filename = [NSString stringWithFormat:@\"test-%@-%ld-bps-drl\", [[url URLByDeletingPathExtension] lastPathComponent], (long)bitRate];\r\n\r\n    NSURL *const outputUrl = [[[NSURL fileURLWithPath:NSTemporaryDirectory()]\r\n                               URLByAppendingPathComponent:filename]\r\n                              URLByAppendingPathExtension:@\"mp4\"];\r\n\r\n    if ([[NSFileManager defaultManager]fileExistsAtPath:outputUrl.path]) {\r\n        [[NSFileManager defaultManager] removeItemAtURL:outputUrl error:nil];\r\n    }\r\n\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    AVAssetTrack *const videoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] firstObject];\r\n    NSError *error = nil;\r\n    AVAssetReader *const assetReader = [AVAssetReader assetReaderWithAsset:asset error:&error];\r\n    XCTAssertNil(error);\r\n    AVAssetWriter *const assetWriter = [AVAssetWriter assetWriterWithURL:outputUrl fileType:AVFileTypeMPEG4 error:&error];\r\n    XCTAssertNil(error);\r\n\r\n    AVAssetWriterInput *const input = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo\r\n                                                                     outputSettings:@{\r\n                                                                                      AVVideoCodecKey: AVVideoCodecTypeH264,\r\n                                                                                      AVVideoWidthKey: @(videoTrack.naturalSize.width),\r\n                                                                                      AVVideoHeightKey: @(videoTrack.naturalSize.height),\r\n                                                                                      AVVideoCompressionPropertiesKey: @{\r\n//                                                                                              AVVideoAverageBitRateKey: @(bitRate),\r\n                                                                                              (NSString *)kVTCompressionPropertyKey_DataRateLimits: @[\r\n                                                                                                      @((bitRate) / 8.f), @1,\r\n                                                                                                      ],\r\n                                                                                              AVVideoProfileLevelKey: AVVideoProfileLevelH264High41,\r\n                                                                                              }\r\n                                                                                      }];\r\n\r\n    AVAssetReaderOutput *const output = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack\r\n                                                                         outputSettings:@{\r\n                                                                                          (id)kCVPixelBufferPixelFormatTypeKey:\r\n                                                                                              @(kCVPixelFormatType_32BGRA),\r\n                                                                                          }];\r\n\r\n    [assetReader addOutput:output];\r\n    [assetWriter addInput:input];\r\n\r\n    XCTAssertNil(assetReader.error);\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    [assetReader startReading];\r\n    [assetWriter startWriting];\r\n\r\n    [assetWriter startSessionAtSourceTime:kCMTimeZero];\r\n\r\n    const dispatch_queue_t queue = dispatch_queue_create(\"transcode\", DISPATCH_QUEUE_SERIAL);\r\n    const dispatch_semaphore_t transcode = dispatch_semaphore_create(0);\r\n    [input requestMediaDataWhenReadyOnQueue:queue usingBlock:^{\r\n        while ([input isReadyForMoreMediaData]) {\r\n            const CMSampleBufferRef sampleBuffer = [output copyNextSampleBuffer];\r\n\r\n            XCTAssertNil(assetReader.error);\r\n            XCTAssertNil(assetWriter.error);\r\n\r\n            if (sampleBuffer) {\r\n                [input appendSampleBuffer:sampleBuffer];\r\n                CFRelease(sampleBuffer);\r\n            } else {\r\n                [input markAsFinished];\r\n                dispatch_semaphore_signal(transcode);\r\n            }\r\n        }\r\n    }];\r\n\r\n    dispatch_semaphore_wait(transcode, DISPATCH_TIME_FOREVER);\r\n\r\n    const dispatch_semaphore_t write = dispatch_semaphore_create(0);\r\n    [assetWriter finishWritingWithCompletionHandler:^{\r\n        dispatch_semaphore_signal(write);\r\n    }];\r\n\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    dispatch_semaphore_wait(write, DISPATCH_TIME_FOREVER);\r\n\r\n    NSLog(@\"Wrote to %@\", outputUrl);\r\n}"
    email: cellsworth@gmail.com
    modified: "2020-01-09T22:57:39.833672Z"
    number: "51127979"
    number_intvalue: 51127979
    originated: "2019-05-24"
    parent_number: '&{NULL_VALUE}'
    product: AVFoundation
    product_version: ""
    reproducible: Always
    resolved: "2019-09-11"
    status: Closed
    title: Bitrates set by DataRateLimits are not respected
