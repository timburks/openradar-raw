apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "19085357"
    labels:
        datastore_id: "5527187574751232"
data:
    classification: Serious Bug
    created: "2014-12-02T21:17:48.248903Z"
    description: "Summary:\r\nWith Yosemite PC/SC Framework each call to SCardGetAttrib fails with SCARD_F_INTERNAL_ERROR (0x80100001)\r\n\r\nSteps to Reproduce:\r\n1. Install Xcode 6.1\r\n2. Create a new Command-line Project\r\n3. Add main.c and reader.h in Project (see attachment)\r\n4. Link PC/SC Framework to the Project\r\n5. Plug an USB SmartCard reader & insert a card\r\n6. Compile & Run project\r\n\r\nExpected Results:\r\nSCardGetAttrib call should returns SCARD_SUCESS (0x0) and dwAtrLen variable should be set to real ATR Length\r\n\r\nActual Results:\r\nSCardGetAttrib call fails with SCARD_F_INTERNAL_ERROR (0x80100001)\r\n\r\nfile : main.c\r\n//\r\n//  main.c\r\n//  TestSCard\r\n//\r\n//\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <PCSC/wintypes.h>\r\n#include <PCSC/winscard.h>\r\n#include \"reader.h\"\r\n\r\nint main(int argc, const char * argv[]) {\r\n    // insert code here...\r\n    SCARDCONTEXT hContext;\r\n    LPSTR mszReaders;\r\n    DWORD err = SCardEstablishContext(SCARD_SCOPE_SYSTEM,NULL,NULL,&hContext);\r\n    if (err != 0) {\r\n        printf(\"ScardEstqblishedContext : %08x\\n\",err);\r\n    } else {\r\n        DWORD cchReaders = 0;\r\n        err = SCardListReaders(hContext, \"SCard$AllReaders\", NULL, &cchReaders);\r\n        if (err != 0) {\r\n            printf(\"ScardListReaders : %08x\\n\",err);\r\n            return 0;\r\n        }\r\n        mszReaders = calloc(cchReaders, sizeof(char));\r\n        if (!mszReaders) {\r\n            printf(\"calloc\\n\");\r\n            return 0;\r\n        }\r\n        err = SCardListReaders(hContext,\"SCard$AllReaders\", mszReaders, &cchReaders);\r\n        if (err != 0) {\r\n            printf(\"ScardListReaders : %08x\\n\",err);\r\n            return 0;\r\n        }\r\n        \r\n        printf(\"Reader : %s\\n\", mszReaders);\r\n        \r\n        SCARDHANDLE hCard;\r\n        DWORD dwActiveProtocol;\r\n        err = SCardConnect(hContext, mszReaders, SCARD_SHARE_SHARED, SCARD_PROTOCOL_RAW, &hCard, &dwActiveProtocol);\r\n        if (err != 0) {\r\n            printf(\"ScardConnect : %08x\\n\",err);\r\n        } else {\r\n            DWORD dwAtrLen = 32;\r\n            err = SCardGetAttrib(hCard, SCARD_ATTR_ATR_STRING, NULL, &dwAtrLen);\r\n            printf(\"ATR LENGTH : %1d\\n\", dwAtrLen);\r\n            if (err != 0) {\r\n                printf(\"SCardGetAttrib : %08x\\n\",err);\r\n            } else {\r\n                printf(\"ATR LENGTH %1d\\n\", dwAtrLen);\r\n                SCardDisconnect(hCard, SCARD_LEAVE_CARD);\r\n                SCardReleaseContext(hContext);\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nfile : reader.h\r\n/*\r\n * MUSCLE SmartCard Development ( http://www.linuxnet.com )\r\n *\r\n * Copyright (C) 1999-2005\r\n *  David Corcoran <corcoran@linuxnet.com>\r\n * Copyright (C) 1999-2009\r\n *  Ludovic Rousseau <ludovic.rousseau@free.fr>\r\n *\r\n * $Id: reader.h.in 4210 2009-05-14 13:14:59Z rousseau $\r\n */\r\n\r\n/**\r\n * @file\r\n * @brief This keeps a list of defines shared between the driver and the application\r\n */\r\n\r\n#ifndef __reader_h__\r\n#define __reader_h__\r\n\r\n/*\r\n * Tags for requesting card and reader attributes\r\n */\r\n\r\n#define SCARD_ATTR_VALUE(Class, Tag) ((((ULONG)(Class)) << 16) | ((ULONG)(Tag)))\r\n\r\n#define SCARD_CLASS_VENDOR_INFO     1   /**< Vendor information definitions */\r\n#define SCARD_CLASS_COMMUNICATIONS  2   /**< Communication definitions */\r\n#define SCARD_CLASS_PROTOCOL        3   /**< Protocol definitions */\r\n#define SCARD_CLASS_POWER_MGMT      4   /**< Power Management definitions */\r\n#define SCARD_CLASS_SECURITY        5   /**< Security Assurance definitions */\r\n#define SCARD_CLASS_MECHANICAL      6   /**< Mechanical characteristic definitions */\r\n#define SCARD_CLASS_VENDOR_DEFINED  7   /**< Vendor specific definitions */\r\n#define SCARD_CLASS_IFD_PROTOCOL    8   /**< Interface Device Protocol options */\r\n#define SCARD_CLASS_ICC_STATE       9   /**< ICC State specific definitions */\r\n#define SCARD_CLASS_SYSTEM     0x7fff   /**< System-specific definitions */\r\n\r\n#define SCARD_ATTR_VENDOR_NAME SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0100) /**< Vendor name. */\r\n#define SCARD_ATTR_VENDOR_IFD_TYPE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0101) /**< Vendor-supplied interface device type (model designation of reader). */\r\n#define SCARD_ATTR_VENDOR_IFD_VERSION SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0102) /**< Vendor-supplied interface device version (DWORD in the form 0xMMmmbbbb where MM = major version, mm = minor version, and bbbb = build number). */\r\n#define SCARD_ATTR_VENDOR_IFD_SERIAL_NO SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0103) /**< Vendor-supplied interface device serial number. */\r\n#define SCARD_ATTR_CHANNEL_ID SCARD_ATTR_VALUE(SCARD_CLASS_COMMUNICATIONS, 0x0110) /**< DWORD encoded as 0xDDDDCCCC, where DDDD = data channel type and CCCC = channel number */\r\n#define SCARD_ATTR_ASYNC_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0120) /**< FIXME */\r\n#define SCARD_ATTR_DEFAULT_CLK SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0121) /**< Default clock rate, in kHz. */\r\n#define SCARD_ATTR_MAX_CLK SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0122) /**< Maximum clock rate, in kHz. */\r\n#define SCARD_ATTR_DEFAULT_DATA_RATE SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0123) /**< Default data rate, in bps. */\r\n#define SCARD_ATTR_MAX_DATA_RATE SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0124) /**< Maximum data rate, in bps. */\r\n#define SCARD_ATTR_MAX_IFSD SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0125) /**< Maximum bytes for information file size device. */\r\n#define SCARD_ATTR_SYNC_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0126) /**< FIXME */\r\n#define SCARD_ATTR_POWER_MGMT_SUPPORT SCARD_ATTR_VALUE(SCARD_CLASS_POWER_MGMT, 0x0131) /**< Zero if device does not support power down while smart card is inserted. Nonzero otherwise. */\r\n#define SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE SCARD_ATTR_VALUE(SCARD_CLASS_SECURITY, 0x0140) /**< FIXME */\r\n#define SCARD_ATTR_USER_AUTH_INPUT_DEVICE SCARD_ATTR_VALUE(SCARD_CLASS_SECURITY, 0x0142) /**< FIXME */\r\n#define SCARD_ATTR_CHARACTERISTICS SCARD_ATTR_VALUE(SCARD_CLASS_MECHANICAL, 0x0150) /**< DWORD indicating which mechanical characteristics are supported. If zero, no special characteristics are supported. Note that multiple bits can be set */\r\n\r\n#define SCARD_ATTR_CURRENT_PROTOCOL_TYPE SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0201) /**< FIXME */\r\n#define SCARD_ATTR_CURRENT_CLK SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0202) /**< Current clock rate, in kHz. */\r\n#define SCARD_ATTR_CURRENT_F SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0203) /**< Clock conversion factor. */\r\n#define SCARD_ATTR_CURRENT_D SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0204) /**< Bit rate conversion factor. */\r\n#define SCARD_ATTR_CURRENT_N SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0205) /**< Current guard time. */\r\n#define SCARD_ATTR_CURRENT_W SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0206) /**< Current work waiting time. */\r\n#define SCARD_ATTR_CURRENT_IFSC SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0207) /**< Current byte size for information field size card. */\r\n#define SCARD_ATTR_CURRENT_IFSD SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0208) /**< Current byte size for information field size device. */\r\n#define SCARD_ATTR_CURRENT_BWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0209) /**< Current block waiting time. */\r\n#define SCARD_ATTR_CURRENT_CWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020a) /**< Current character waiting time. */\r\n#define SCARD_ATTR_CURRENT_EBC_ENCODING SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020b) /**< Current error block control encoding. */\r\n#define SCARD_ATTR_EXTENDED_BWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020c) /**< FIXME */\r\n\r\n#define SCARD_ATTR_ICC_PRESENCE SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0300) /**< Single byte indicating smart card presence */\r\n#define SCARD_ATTR_ICC_INTERFACE_STATUS SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0301) /**< Single byte. Zero if smart card electrical contact is not active; nonzero if contact is active. */\r\n#define SCARD_ATTR_CURRENT_IO_STATE SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0302) /**< FIXME */\r\n#define SCARD_ATTR_ATR_STRING SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0303) /**< Answer to reset (ATR) string. */\r\n#define SCARD_ATTR_ICC_TYPE_PER_ATR SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0304) /**< Single byte indicating smart card type */\r\n\r\n#define SCARD_ATTR_ESC_RESET SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA000) /**< FIXME */\r\n#define SCARD_ATTR_ESC_CANCEL SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA003) /**< FIXME */\r\n#define SCARD_ATTR_ESC_AUTHREQUEST SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA005) /**< FIXME */\r\n#define SCARD_ATTR_MAXINPUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA007) /**< FIXME */\r\n\r\n#define SCARD_ATTR_DEVICE_UNIT SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0001) /**< Instance of this vendor's reader attached to the computer. The first instance will be device unit 0, the next will be unit 1 (if it is the same brand of reader) and so on. Two different brands of readers will both have zero for this value. */\r\n#define SCARD_ATTR_DEVICE_IN_USE SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0002) /**< Reserved for future use. */\r\n#define SCARD_ATTR_DEVICE_FRIENDLY_NAME_A SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0003)\r\n#define SCARD_ATTR_DEVICE_SYSTEM_NAME_A SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0004)\r\n#define SCARD_ATTR_DEVICE_FRIENDLY_NAME_W SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0005)\r\n#define SCARD_ATTR_DEVICE_SYSTEM_NAME_W SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0006)\r\n#define SCARD_ATTR_SUPRESS_T1_IFS_REQUEST SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0007) /**< FIXME */\r\n\r\n#ifdef UNICODE\r\n#define SCARD_ATTR_DEVICE_FRIENDLY_NAME SCARD_ATTR_DEVICE_FRIENDLY_NAME_W /**< Reader's display name. */\r\n#define SCARD_ATTR_DEVICE_SYSTEM_NAME SCARD_ATTR_DEVICE_SYSTEM_NAME_W /**< Reader's system name. */\r\n#else\r\n#define SCARD_ATTR_DEVICE_FRIENDLY_NAME SCARD_ATTR_DEVICE_FRIENDLY_NAME_A /**< Reader's display name. */\r\n#define SCARD_ATTR_DEVICE_SYSTEM_NAME SCARD_ATTR_DEVICE_SYSTEM_NAME_A /**< Reader's system name. */\r\n#endif\r\n\r\n/**\r\n * Provide source compatibility on different platforms\r\n */\r\n#define SCARD_CTL_CODE(code) (0x42000000 + (code))\r\n\r\n/**\r\n * PC/SC v2.02.05 part 10 reader tags\r\n */\r\n#define CM_IOCTL_GET_FEATURE_REQUEST SCARD_CTL_CODE(3400)\r\n\r\n#define FEATURE_VERIFY_PIN_START         0x01\r\n#define FEATURE_VERIFY_PIN_FINISH        0x02\r\n#define FEATURE_MODIFY_PIN_START         0x03\r\n#define FEATURE_MODIFY_PIN_FINISH        0x04\r\n#define FEATURE_GET_KEY_PRESSED          0x05\r\n#define FEATURE_VERIFY_PIN_DIRECT        0x06 /**< Verify PIN */\r\n#define FEATURE_MODIFY_PIN_DIRECT        0x07 /**< Modify PIN */\r\n#define FEATURE_MCT_READERDIRECT         0x08\r\n#define FEATURE_MCT_UNIVERSAL            0x09\r\n#define FEATURE_IFD_PIN_PROPERTIES       0x0A /**< retrieve properties of the IFD regarding PIN handling */\r\n#define FEATURE_ABORT                    0x0B\r\n#define FEATURE_SET_SPE_MESSAGE          0x0C\r\n#define FEATURE_VERIFY_PIN_DIRECT_APP_ID 0x0D\r\n#define FEATURE_MODIFY_PIN_DIRECT_APP_ID 0x0E\r\n#define FEATURE_WRITE_DISPLAY            0x0F\r\n#define FEATURE_GET_KEY                  0x10\r\n#define FEATURE_IFD_DISPLAY_PROPERTIES   0x11\r\n\r\n/* structures used (but not defined) in PC/SC Part 10 revision 2.02.05:\r\n * \"IFDs with Secure Pin Entry Capabilities\" */\r\n\r\n#include <inttypes.h>\r\n\r\n/* Set structure elements aligment on bytes\r\n * http://gcc.gnu.org/onlinedocs/gcc/Structure_002dPacking-Pragmas.html */\r\n#if defined(__APPLE__) | defined(sun)\r\n#pragma pack(1)\r\n#else\r\n#pragma pack(push, 1)\r\n#endif\r\n\r\n/** the structure must be 6-bytes long */\r\ntypedef struct\r\n{\r\n\tuint8_t tag;\r\n\tuint8_t length;\r\n\tuint32_t value;\t/**< This value is always in BIG ENDIAN format as documented in PCSC v2 part 10 ch 2.2 page 2. You can use ntohl() for example */\r\n} PCSC_TLV_STRUCTURE;\r\n\r\n/** the wLangId and wPINMaxExtraDigit are 16-bits long so are subject to byte\r\n * ordering */\r\n#ifdef __BIG_ENDIAN__\r\n#define HOST_TO_CCID_16(x) ((((x) >> 8) & 0xFF) + ((x & 0xFF) << 8))\r\n#define HOST_TO_CCID_32(x) ((((x) >> 24) & 0xFF) + (((x) >> 8) & 0xFF00) + ((x & 0xFF00) << 8) + (((x) & 0xFF) << 24))\r\n#else\r\n#define HOST_TO_CCID_16(x) (x)\r\n#define HOST_TO_CCID_32(x) (x)\r\n#endif\r\n\r\n/** structure used with \\ref FEATURE_VERIFY_PIN_DIRECT */\r\ntypedef struct\r\n{\r\n\tuint8_t bTimerOut;\t/**< timeout is seconds (00 means use default timeout) */\r\n\tuint8_t bTimerOut2; /**< timeout in seconds after first key stroke */\r\n\tuint8_t bmFormatString; /**< formatting options */\r\n\tuint8_t bmPINBlockString; /**< bits 7-4 bit size of PIN length in APDU,\r\n\t                        * bits 3-0 PIN block size in bytes after\r\n\t                        * justification and formatting */\r\n\tuint8_t bmPINLengthFormat; /**< bits 7-5 RFU,\r\n\t                         * bit 4 set if system units are bytes, clear if\r\n\t                         * system units are bits,\r\n\t                         * bits 3-0 PIN length position in system units */\r\n\tuint16_t wPINMaxExtraDigit; /**< 0xXXYY where XX is minimum PIN size in digits,\r\n\t                            and YY is maximum PIN size in digits */\r\n\tuint8_t bEntryValidationCondition; /**< Conditions under which PIN entry should\r\n\t                                 * be considered complete */\r\n\tuint8_t bNumberMessage; /**< Number of messages to display for PIN verification */\r\n\tuint16_t wLangId; /**< Language for messages */\r\n\tuint8_t bMsgIndex; /**< Message index (should be 00) */\r\n\tuint8_t bTeoPrologue[3]; /**< T=1 block prologue field to use (fill with 00) */\r\n\tuint32_t ulDataLength; /**< length of Data to be sent to the ICC */\r\n\tuint8_t abData[1]; /**< Data to send to the ICC */\r\n} PIN_VERIFY_STRUCTURE;\r\n\r\n/** structure used with \\ref FEATURE_MODIFY_PIN_DIRECT */\r\ntypedef struct\r\n{\r\n\tuint8_t bTimerOut;\t/**< timeout is seconds (00 means use default timeout) */\r\n\tuint8_t bTimerOut2; /**< timeout in seconds after first key stroke */\r\n\tuint8_t bmFormatString; /**< formatting options */\r\n\tuint8_t bmPINBlockString; /**< bits 7-4 bit size of PIN length in APDU,\r\n\t                        * bits 3-0 PIN block size in bytes after\r\n\t                        * justification and formatting */\r\n\tuint8_t bmPINLengthFormat; /**< bits 7-5 RFU,\r\n\t                         * bit 4 set if system units are bytes, clear if\r\n\t                         * system units are bits,\r\n\t                         * bits 3-0 PIN length position in system units */\r\n\tuint8_t bInsertionOffsetOld; /**< Insertion position offset in bytes for\r\n\t                             the current PIN */\r\n\tuint8_t bInsertionOffsetNew; /**< Insertion position offset in bytes for\r\n\t                             the new PIN */\r\n\tuint16_t wPINMaxExtraDigit;\r\n\t                         /**< 0xXXYY where XX is minimum PIN size in digits,\r\n\t                            and YY is maximum PIN size in digits */\r\n\tuint8_t bConfirmPIN; /**< Flags governing need for confirmation of new PIN */\r\n\tuint8_t bEntryValidationCondition; /**< Conditions under which PIN entry should\r\n\t                                 * be considered complete */\r\n\tuint8_t bNumberMessage; /**< Number of messages to display for PIN verification*/\r\n\tuint16_t wLangId; /**< Language for messages */\r\n\tuint8_t bMsgIndex1; /**< index of 1st prompting message */\r\n\tuint8_t bMsgIndex2; /**< index of 2d prompting message */\r\n\tuint8_t bMsgIndex3; /**< index of 3d prompting message */\r\n\tuint8_t bTeoPrologue[3]; /**< T=1 block prologue field to use (fill with 00) */\r\n\tuint32_t ulDataLength; /**< length of Data to be sent to the ICC */\r\n\tuint8_t abData[1]; /**< Data to send to the ICC */\r\n} PIN_MODIFY_STRUCTURE;\r\n\r\n/** structure used with \\ref FEATURE_IFD_PIN_PROPERTIES */\r\ntypedef struct {\r\n\tuint16_t wLcdLayout; /**< display characteristics */\r\n\tuint16_t wLcdMaxCharacters;\r\n\tuint16_t wLcdMaxLines;\r\n\tuint8_t bEntryValidationCondition;\r\n\tuint8_t bTimeOut2;\r\n} PIN_PROPERTIES_STRUCTURE;\r\n\r\n/* restore default structure elements alignment */\r\n#if defined(__APPLE__) | defined(sun)\r\n#pragma pack()\r\n#else\r\n#pragma pack(pop)\r\n#endif\r\n\r\n#endif"
    email: vincent.sourin@gmail.com
    modified: "2014-12-02T21:20:14.888543Z"
    number: "19085357"
    number_intvalue: 19085357
    originated: 26-Nov-2014 03:41 PM
    parent_number: '&{NULL_VALUE}'
    product: OS X
    product_version: "10.10"
    reproducible: Always
    resolved: ""
    status: Open
    title: OS X Yosemite PCSC SCardGetAttrib Problem
