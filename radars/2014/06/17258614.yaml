apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "17258614"
    labels:
        datastore_id: "5824647949975552"
data:
    classification: ""
    created: "2014-06-10T22:05:50.851383Z"
    description: "It is wonderful that Switch has a switch statement which can be used for rich pattern matching.\r\n\r\n## suggestion: switch should be an expression, not a statement\r\n\r\nRespectfully, I'd like to suggest that it would also be great if their were a kind of \"switch\" which was not a statement but an expression that returned a value. You could then use these these switch-expressions to create compact inline value transformers without creating any unnecessary temporary mutable values.\r\n\r\n## why this is a good idea\r\n\r\nConsider the example from  The Swift Programming Language (p 516):\r\n\r\n   switch self {\r\n   case .Ace:\r\n       return Values(first: 1, second: 11)\r\n   case .Jack, .Queen, .King:\r\n       return Values(first: 10, second: nil)\r\n   default:\r\n       return Values(first: self.toRaw(), second: nil)\r\n       }\r\n   }\r\n   \r\nThe pattern-match here is lovely but it is awkward when you consider the likely case that you are not always writing this at the end of a function when you return value, and that usually you actually want to do something with the value immediately. Then you have to do:\r\n\r\n   var temporary:Values! = nil\r\n   switch self {\r\n   case .Ace:\r\n       temporary = Values(first: 1, second: 11)\r\n   case .Jack, .Queen, .King:\r\n       temporary = Values(first: 10, second: nil)\r\n   default:\r\n       temporary = Values(first: self.toRaw(), second: nil)\r\n       }\r\n   }\r\n\r\nThis works, and now I can use the value in \"temporary\". But there are many problems: 1. I've had to use an implicitly unwrapped optional just to get hold of my result. 2. The compiler will not use its exhaustiveness check to ensure I've assigned to the optional in all the cases. 3. It's misleading, since I know that the temporary will be constant but now it shows up in code as a variable. 4. For the same reason as 3, it wastes an optimization opportunity.\r\n\r\n## possible syntax\r\n\r\nInstead, we could let case statements implicitly return their last value, like so:\r\n\r\n   let result =  switch self {\r\n     case .Ace:\r\n         Values(first: 1, second: 11)\r\n     case .Jack, .Queen, .King:\r\n         Values(first: 10, second: nil)\r\n     default:\r\n         Values(first: self.toRaw(), second: nil)\r\n     }\r\n\r\nBetter, yes? Of course! And when type inference can determine the returned type, the syntax is exactly like a switch statement.\r\n\r\nBut I admit it does raise two questions: how to make this idea work when you need to provide type annotations? and with the existing switch statement more generally?\r\n\r\n## syntax to indicate type of the return value\r\n\r\nIn cases where it is necessary to provide type annotations of the type returned by this switch form, I suggest using a syntax similar to what you've developed for closures:\r\n\r\n   let result =  switch (self:Rank) -> Values {\r\n     case .Ace:\r\n         Values(first: 1, second: 11)\r\n     case .Jack, .Queen, .King:\r\n         Values(first: 10, second: nil)\r\n     default:\r\n         Values(first: self.toRaw(), second: nil)\r\n     }\r\n\r\nWhat I like about this syntax is that it looks like this \"switch\" is an anonymous function definition which transforms its argument expression to its return value -- which is just what it is.\r\n\r\nWhat about the case where people don't care about the return value, and want switch to behave like a statement?\r\n\r\nI'm not sure how to handle this, but here are a couple possibilities.\r\n\r\n## compatibilty with switch as a statement\r\n\r\n### option 1: require explicitly declaring -> Void\r\n\r\nOne option is that explicitly declaring that the switch statement returns Void is effectively asking it to be treated like a statement, just like before\r\n\r\n   switch self -> Void {\r\n   case .Ace:\r\n       doSomethingHere() // irrelevant what I return\r\n   case .Jack, .Queen, .King:\r\n       doSomethingElse() // irrelevant what I return\r\n   default:\r\n       doAnotherThing() // irrelevant what I return\r\n       }\r\n   }\r\n\r\nThis is bad becomes it changes what people are used to right now. Fortunately, this is not necessary!\r\n\r\n### option 2: implicitly return Void when no return type can be inferred\r\n\r\nAnother option is that a switch statement implicitly defaults to returning Void if the case expressions do not have a common return type:\r\n\r\n   switch self {\r\n   case .Ace:\r\n       doSomethingHere() // might return Foo\r\n   case .Jack, .Queen, .King:\r\n       doSomethingElse() // return Void\r\n   default:\r\n       doAnotherThing() // might return Bar\r\n       }\r\n   }\r\n\r\nSince there is no type here that can be inferred which works for both Foo, Void, and Bar, the language interprets this as indicating the switch expression should return Void. And now it acts exactly like a normal switch statement!\r\n\r\nIn other words, I think you could modify the language so that switch behaved like an expression, returning a value, in a way that would not break the existing grammar at all! And the new syntax that would be needed when the return type cannot be inferred, or when someone wanted to provide an additional annotation to the type of the switch expression's argument, is (I think) quite consistent with the syntax the language uses elsewhere for function definition."
    email: alexisgallagher@gmail.com
    modified: "2014-06-10T22:05:50.851578Z"
    number: "17258614"
    number_intvalue: 17258614
    originated: "2014-06-10"
    parent_number: '&{NULL_VALUE}'
    product: Swift
    product_version: beta
    reproducible: ""
    resolved: ""
    status: Open
    title: In Swift, "switch" should be an expression not a statement
