apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "17340748"
    labels:
        datastore_id: "5646946899329024"
data:
    classification: ""
    created: "2014-06-17T10:53:06.126978Z"
    description: "I realize that it's a vain hope that this bug report will be anything than summarily dismissed, but I feel I have to make the attempt nonetheless.\r\n\r\nPlease reconsider Swift’s basic philosophy of fundamentally static typing. Although it is possible to gain access to dynamic dispatch by way of @objc or extending NSObject, the very form of these annotations hint at dynamic dispatch as a second class citizen in Swift.\r\n\r\nOf course, it’s not always necessary to be dynamic, and writing in a safer and more expressive form of a low level language than C and C++ is very nice indeed.\r\n\r\nIt’s tempting to suggest three levels of classes/structs, starting with the current Swift struct and class, then adding a third dynamic class. However, we then run into difficulties with generics over all of these different types.\r\n\r\nThe current state of generics in Swift today is poor. It doesn’t have a very expressive system of generics, which makes it hard to work with certain structures, and seriously hampers reuse. One solution would be to move towards Scala/Haskell/Ceylon with a much more expressive set of generics. However, in those languages the generics goes hand in hand with their programming paradigms. For an imperative language, the gain is not as high, and the added complexity of a generics system like that (which form a sub language in itself) works against the intended simplicity and clarity of the language.\r\n\r\nRight now Swift’s generics are directly responsible for making things that were easy in ObjC really hard.\r\n\r\nIn addition to generics, please also note that functions/closures is not a complete replacement for selectors. Aside from the added cognitive load debugging closures (since the location of calling the closure is quite different from where it was created), it requires lots of work in order to do things like assembling an UI from a configuration file.\r\n\r\nMy conclusion is that dynamic dispatch must be a first class citizen in order to make Swift suitable for UI programming. Also, the generics must be much simplified and permissive in order to not obstruct and complicate the day-to-day programming work. With a dynamic dispatch as its base, programmers could mix and match generic and non-generic code, statically typed with dynamic. As an example, look at Strongtalk.\r\n\r\nIf necessary, project an Objective-Swift with Swift forming the base of a dynamic language, like C forms the base of Objective-C."
    email: christoffer@aegik.com
    modified: "2014-06-24T23:24:01.538443Z"
    number: "17340748"
    number_intvalue: 17340748
    originated: ""
    parent_number: '&{NULL_VALUE}'
    product: Developer Tools
    product_version: Version 6.0 (6A215l)
    reproducible: Always
    resolved: Won't fix
    status: Closed
    title: 'Swift: Drop the strict type system, follow Strongtalk instead'
