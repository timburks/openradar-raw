apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "36078273"
    labels:
        datastore_id: "5049229504413696"
data:
    classification: ""
    created: "2017-12-15T20:47:31.09977Z"
    description: "Area:\r\nSomething not on this list\r\n\r\nSummary:\r\nThe kqueue system call creates a \"kqueue\" which can be used to watch for certain events, including POSIX signals. However, on macOS the kqueue mechanism sometimes reports signals before they have been delivered to the process. This makes it impossible to use the mechanism to reliably retrieve signal data, since when a signal is reported via kqueue but is not detected by eg sigpending() then it is impossible to determine whether the signal is still pending delivery or if it has already been delivered (and previously consumed, including if it was merged with an existing pending signal). An event loop which uses kqueue to detect signals and then allows the signal handler to run (in order to retrieve signal data) is affected by this.\r\n\r\nSteps to Reproduce:\r\nUse the attached C program, macos-kqueue-bug.c,  to reproduce the bug.\r\n\r\nExpected Results:\r\nThe program should have no output, that is, the kevent() system call should only report a signal once the signal has become pending in the calling process.\r\n\r\nActual Results:\r\nThe program outputs a line indicating that the kevent() system call reported a signal, but the signal was not seen as pending using the sigpending() system call.\r\n\r\nVersion/Build:\r\nDarwin 17.3.0 Darwin Kernel Version 17.3.0: Thu Nov  9 18:09:22 PST 2017; root:xnu-4570.31.3~1/RELEASE_X86_64\r\n(on Mac OS High Sierra)\r\n\r\nConfiguration:\r\nN/A\r\n\r\nTest program:\r\n#include <sys/types.h>\r\n#include <sys/event.h>\r\n#include <sys/time.h>\r\n#include <sys/wait.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <signal.h>\r\n#include <unistd.h>\r\n\r\n// Program to demonstrate kqueue bug on macOS (Sierra, possibly others). The\r\n// kqueue mechanism can sometimes reports that a SIGCHLD signal has been\r\n// received, but the signal does not yet report as pending.\r\n//\r\n// Running this program will output a message similar to the following, if the\r\n// bug is present:\r\n//\r\n//    Received SIGCHLD kevent but SIGCHLD is not (yet) pending; i = 273\r\n//\r\n// (The number is the number of loop iterations before the bug was hit).\r\n//\r\n// This bug makes it impossible to reliably recover signal data when using\r\n// kqueue to detect signals. The problem is that kqueue reports signal\r\n// delivery attempts, which is different (potentially greater) than the\r\n// number of signals actually received (i.e. because a signal can be merged\r\n// with another, already pending, instance of the same signal). So, when\r\n// this bug is present, and we receive a notification of a signal via kqueue\r\n// but the signal does not show as pending, we do not know if it is because\r\n// the signal has not yet arrived or if delivery was already attempted. We\r\n// cannot risk waiting for the signal, because this might block indefinitely.\r\n//\r\n// Note that in this test, we just have the child process fork and exit to\r\n// generate the SIGCHLD signal. However, we can have the child send the\r\n// parent any signal prior to terminating, and reproduce the problem with that\r\n// signal, i.e. it is not specific to the case of SIGCHLD and terminating\r\n// processes.\r\n\r\nvoid errout(const char * s)\r\n{\r\n    perror(s);\r\n    exit(1);\r\n}\r\n\r\nvoid sighandler(int signo)\r\n{\r\n\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    int kq = kqueue();\r\n    if (kq == -1) errout(\"kqueue\");\r\n\r\n    // Mask SIGCHLD (but establish a handler):\r\n    sigset_t sigset;\r\n    sigemptyset(&sigset);\r\n    sigaddset(&sigset, SIGCHLD);\r\n    sigprocmask(SIG_BLOCK, &sigset, NULL);\r\n\r\n    struct sigaction sa;\r\n    sa.sa_handler = sighandler;\r\n    sigfillset(&sa.sa_mask);\r\n    sa.sa_flags = 0;\r\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) errout(\"sigaction\");\r\n\r\n    struct timespec timeout;\r\n    timeout.tv_nsec = 0;\r\n    timeout.tv_sec = 0;\r\n\r\n    // Set up kqueue to report SIGCHLD:\r\n    struct kevent kev;\r\n    EV_SET(&kev, SIGCHLD, EVFILT_SIGNAL, EV_ADD, 0, 0, 0);\r\n    if (kevent(kq, &kev, 1, NULL, 0, &timeout) == -1) errout(\"kevent\");\r\n\r\n    for (int i = 0; i < 10000; i++) {\r\n        // Fork a child, which immediately exits, to generate SIGCHLD:\r\n        pid_t child = fork();\r\n        if (child == 0) {\r\n            _exit(0);\r\n        }\r\n\r\n        // Retrieve event from kqueue, and make sure it refers to the SIGCHLD:\r\n        int r;\r\n        if ((r = kevent(kq, NULL, 0, &kev, 1, NULL)) == -1) errout(\"kevent\");\r\n        if (r != 1) {\r\n            fprintf(stderr, \"kevent: didn't receive one event?\\n\");\r\n            exit(1);\r\n        }\r\n\r\n        if (kev.filter != EVFILT_SIGNAL || kev.ident != SIGCHLD) {\r\n            fprintf(stderr, \"kevent: received wrong event?\\n\");\r\n            exit(1);\r\n        }\r\n\r\n        // Now confirm that SIGCHLD is actually pending:\r\n        sigset_t pendingsigs;\r\n        sigpending(&pendingsigs);\r\n        if (! sigismember(&pendingsigs, SIGCHLD)) {\r\n            fprintf(stderr, \"Received SIGCHLD kevent but SIGCHLD is not (yet) pending; i = %d\\n\", i);\r\n            exit(1);\r\n        }\r\n\r\n        int signo;\r\n        sigwait(&sigset, &signo);\r\n        int status;\r\n        wait(&status);\r\n    }\r\n\r\n    return 0;\r\n}"
    email: davmac@davmac.org
    modified: "2017-12-15T20:47:31.10004Z"
    number: "36078273"
    number_intvalue: 36078273
    originated: 15/12/2017
    parent_number: '&{NULL_VALUE}'
    product: macOS + SDK
    product_version: Darwin Kernel Version 17.3.0
    reproducible: ""
    resolved: ""
    status: Open
    title: kqueue reports signals before they have been delivered to process
