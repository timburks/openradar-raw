apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "32385716"
    labels:
        datastore_id: "4988931149922304"
data:
    classification: Enhancement
    created: "2017-05-24T20:54:12.04212Z"
    description: "Summary:\r\n\r\nMOTIVATION\r\n\r\nFor the last decade, NSTreeController has been—let's admit it—a bit of a pain to use, mostly because of the way it handles tree nodes. Mainly:\r\n\r\n- To manage a tree using an NSTreeController, one binds its 'Content Array' binding in Interface Builder. The NSTreeController can then be used to populate an NSOutlineView or another NSTreeController-aware view.\r\n\r\n- However, in managing the tree, NSTreeController effectively duplicates the entire tree using a private subclass of NSTreeNode called NSTreeControllerTreeNode. Every node in the original tree is mirrored by a NSTreeControllerTreeNode in the parallel tree. This can confer a few advantages; the NSTreeControllerTreeNodes can be arbitrarily reordered by the NSTreeController without altering the order of nodes in the original tree, and individual objects can be duplicated in the original tree without causing issues, as each occurrence of a single object will get a unique NSTreeControllerTreeNode in the parallel tree. Finally, since NSTreeControllerTreeNodes are lazily created, structures that infinitely loop back on themselves are possible without breaking things.\r\n\r\n- However, this approach has many drawbacks. For one, maintaining two parallel trees to represent the same data is, in many cases, a quite unnecessarily messy and awkward design, since many trees do not contain non-unique members. Furthermore, while it is easy to get the real model object from an NSTreeNode through its representedObject property, there is no way to go the other way and get an NSTreeNode corresponding to any given model object. This means that if the program wants to do something like select a given model object, or expand a given model object in an outline view, it will need to manually walk through the entire tree, checking the representedObject property on each node until it finds the desired node. This can be prohibitively expensive for large trees, resulting in an inferior user experience as the user may have to contend with beachballs and stuttering, as well as diminished battery life.\r\n\r\nPROPOSED SOLUTION:\r\n\r\nFor the common case where: 1) every node in a tree can be guaranteed to be at a unique object address, and 2) the program code is not making assumptions about the ordering of tree nodes, so that it does not matter if they are arbitrarily resorted, I propose the following:\r\n\r\n1. Either make NSTreeControllerTreeNode public, or fold its functionality into the already-public NSTreeNode.\r\n\r\n2. Introduce a new \"Content Nodes\" binding on NSTreeController. This binding will point to an array of objects which are required to be a subclass of NSTreeControllerTreeNode (or NSTreeNode). The NSTreeController will then use these nodes directly, instead of creating a whole separate tree of proxy nodes.\r\n\r\n(to be continued in Steps To Reproduce due to the character limit)\r\n\r\nSteps to Reproduce:\r\n3. In the case where the \"Content Nodes\" binding is used instead of \"Content Objects\", the childrenKeyPath, countKeyPath, and leafKeyPath key paths will be ignored, and it will no longer be an error to leave these blank in Interface Builder. The appropriate properties on NSTreeNode will be used instead of these key paths.\r\n\r\n4. The \"Content Objects\" binding will continue to be available for cases in which features like non-uniqueness are required.\r\n\r\nThis will confer the following advantages:\r\n\r\n- A cleaner model, without all the parallelism that is seen currently.\r\n\r\n- Better performance for applications that need to select particular model items, or use NSOutlineView methods such as -expandItem:expandChildren:, since there will no longer be any need to traverse the whole tree to find the needed node.\r\n\r\n- A much easier experience for the user, which parallels more closely the behavior of NSArrayController.\r\n\r\nExpected Results:\r\nA way to build the NSTreeNode tree by oneself, instead of having to duplicate one's existing tree, by way of a new 'Arranged Nodes' binding on NSTreeController.\r\n\r\nObserved Results:\r\nNSTreeController and its NSTreeControllerTreeNodes are currently messy, awkward, and ill-performing."
    email: CharlesJS@gmail.com
    modified: "2017-05-24T20:54:12.04232Z"
    number: "32385716"
    number_intvalue: 32385716
    originated: 5-24-2017
    parent_number: '&{NULL_VALUE}'
    product: macOS + SDK/AppKit
    product_version: 16F73
    reproducible: N/A
    resolved: ""
    status: Open
    title: '''Content Nodes'' binding for NSTreeController'
