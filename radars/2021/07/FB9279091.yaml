apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB9279091
    labels:
        datastore_id: "4984072304590848"
data:
    classification: Incorrect/Unexpected Behavior
    created: "2021-07-07T00:33:19.219844Z"
    description: "It seems that when performing concurrent encodes with an HDR source asset, there is a high chance of hitting a AVErrorMediaServicesWereReset error from either AVAssetReader or AVAssetWriter. We do not encounter this error with SDR inputs, leading us to believe there is a resource that is no longer mutually exclusive in the HDR path. The error occurs 100% of the time when the target codec is HEVC, and sometimes when the target codec is H264.\r\n\r\n---\r\n\r\n#import <XCTest/XCTest.h>\r\n#import <VideoToolbox/VideoToolbox.h>\r\n#import <AVFoundation/AVFoundation.h>\r\n\r\n@interface ConcurrentEncodingTests : XCTestCase\r\n\r\n@end\r\n\r\n@implementation ConcurrentEncodingTests\r\n\r\n- (void)testHDRtoHEVC {\r\n    // always error\r\n    NSURL *const url = [[NSBundle bundleForClass:[self class]] URLForResource:@\"IMG_0156\" withExtension:@\"MOV\"];\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    [self testWithAsset:asset codec:AVVideoCodecTypeHEVC lock:NO];\r\n}\r\n\r\n- (void)testHDRtoHEVCWithLock {\r\n    // no error\r\n    NSURL *const url = [[NSBundle bundleForClass:[self class]] URLForResource:@\"IMG_0156\" withExtension:@\"MOV\"];\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    [self testWithAsset:asset codec:AVVideoCodecTypeHEVC lock:YES];\r\n}\r\n\r\n- (void)testHDRtoH264 {\r\n    // sometimes error\r\n    NSURL *const url = [[NSBundle bundleForClass:[self class]] URLForResource:@\"IMG_0156\" withExtension:@\"MOV\"];\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    [self testWithAsset:asset codec:AVVideoCodecTypeH264 lock:NO];\r\n}\r\n\r\n- (void)testSDRtoHEVC {\r\n    // no error\r\n    NSURL *const url = [[NSBundle bundleForClass:[self class]] URLForResource:@\"IMG_0162\" withExtension:@\"MOV\"];\r\n    AVAsset *const asset = [AVAsset assetWithURL:url];\r\n    [self testWithAsset:asset codec:AVVideoCodecTypeHEVC lock:NO];\r\n}\r\n\r\n- (void)testWithAsset:(AVAsset *)asset codec:(AVVideoCodecType)codec lock:(BOOL)lock {\r\n    dispatch_group_t group = dispatch_group_create();\r\n\r\n    NSLock *const nsLock = lock ? [NSLock new] : nil;\r\n\r\n    for (int i = 0; i < 3; ++i) {\r\n        [nsLock lock];\r\n        dispatch_group_enter(group);\r\n        NSLog(@\"starting %d\", i);\r\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\r\n            [self testWithAsset:asset index:i codec:codec completion:^{\r\n                NSLog(@\"finished %d\", i);\r\n                dispatch_group_leave(group);\r\n                [nsLock unlock];\r\n            }];\r\n        });\r\n    }\r\n\r\n    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);\r\n}\r\n\r\n- (void)testWithAsset:(AVAsset *)asset index:(NSInteger)index codec:(AVVideoCodecType)codec completion:(void(^)(void))completion {\r\n    NSString *filename = [[NSUUID UUID] UUIDString];\r\n\r\n    NSURL *const outputUrl = [[[NSURL fileURLWithPath:NSTemporaryDirectory()]\r\n                               URLByAppendingPathComponent:filename]\r\n                              URLByAppendingPathExtension:@\"mp4\"];\r\n\r\n    if ([[NSFileManager defaultManager]fileExistsAtPath:outputUrl.path]) {\r\n        [[NSFileManager defaultManager] removeItemAtURL:outputUrl error:nil];\r\n    }\r\n\r\n    AVAssetTrack *const videoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] firstObject];\r\n    NSError *error = nil;\r\n    AVAssetReader *const assetReader = [AVAssetReader assetReaderWithAsset:asset error:&error];\r\n    XCTAssertNil(error);\r\n    AVAssetWriter *const assetWriter = [AVAssetWriter assetWriterWithURL:outputUrl fileType:AVFileTypeMPEG4 error:&error];\r\n    XCTAssertNil(error);\r\n\r\n    AVAssetWriterInput *const input = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo\r\n                                                                     outputSettings:@{\r\n                                                                                      AVVideoCodecKey: codec,\r\n                                                                                      AVVideoWidthKey: @(videoTrack.naturalSize.width),\r\n                                                                                      AVVideoHeightKey: @(videoTrack.naturalSize.height),\r\n                                                                                      AVVideoCompressionPropertiesKey: @{\r\n                                                                                              AVVideoAverageBitRateKey: @(3e6),\r\n                                                                                              }\r\n                                                                                      }];\r\n\r\n    AVAssetReaderOutput *const output = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack\r\n                                                                         outputSettings:@{\r\n                                                                                          (id)kCVPixelBufferPixelFormatTypeKey:\r\n                                                                                              @(kCVPixelFormatType_32BGRA),\r\n                                                                                          }];\r\n\r\n    [assetReader addOutput:output];\r\n    [assetWriter addInput:input];\r\n\r\n    XCTAssertNil(assetReader.error);\r\n    XCTAssertNil(assetWriter.error);\r\n\r\n    [assetReader startReading];\r\n    [assetWriter startWriting];\r\n\r\n    [assetWriter startSessionAtSourceTime:kCMTimeZero];\r\n\r\n    const dispatch_queue_t queue = dispatch_queue_create(\"transcode\", DISPATCH_QUEUE_SERIAL);\r\n    const dispatch_semaphore_t transcode = dispatch_semaphore_create(0);\r\n\r\n    __block BOOL shouldCancel = NO;\r\n    [input requestMediaDataWhenReadyOnQueue:queue usingBlock:^{\r\n        while ([input isReadyForMoreMediaData]) {\r\n            XCTAssertNil(assetReader.error);\r\n            XCTAssertNil(assetWriter.error);\r\n\r\n            if (assetWriter.error.code == AVErrorEncoderTemporarilyUnavailable) {\r\n                NSLog(@\"Waiting for encoder (%ld)\", (long)index);\r\n                [input markAsFinished];\r\n                shouldCancel = YES;\r\n                dispatch_semaphore_signal(transcode);\r\n                break;\r\n            }\r\n\r\n            if (assetWriter.error.code == AVErrorMediaServicesWereReset || assetReader.error.code == AVErrorMediaServicesWereReset) {\r\n                NSLog(@\"Media services were reset (%ld)\", (long)index);\r\n                [input markAsFinished];\r\n                shouldCancel = YES;\r\n                dispatch_semaphore_signal(transcode);\r\n                break;\r\n            }\r\n\r\n            const CMSampleBufferRef sampleBuffer = [output copyNextSampleBuffer];\r\n\r\n            if (sampleBuffer) {\r\n                [input appendSampleBuffer:sampleBuffer];\r\n                CFRelease(sampleBuffer);\r\n            } else {\r\n                [input markAsFinished];\r\n                dispatch_semaphore_signal(transcode);\r\n            }\r\n        }\r\n    }];\r\n\r\n    dispatch_semaphore_wait(transcode, DISPATCH_TIME_FOREVER);\r\n\r\n    if (shouldCancel) {\r\n        [assetWriter cancelWriting];\r\n        NSLog(@\"Canceled (%ld)\", (long)index);\r\n    } else {\r\n        const dispatch_semaphore_t write = dispatch_semaphore_create(0);\r\n        [assetWriter finishWritingWithCompletionHandler:^{\r\n            dispatch_semaphore_signal(write);\r\n        }];\r\n\r\n        XCTAssertNil(assetWriter.error);\r\n\r\n        dispatch_semaphore_wait(write, DISPATCH_TIME_FOREVER);\r\n\r\n        NSLog(@\"Wrote to %@ (%ld)\", outputUrl, (long)index);\r\n    }\r\n\r\n    completion();\r\n}\r\n\r\n@end"
    email: cellsworth@gmail.com
    modified: "2021-07-08T16:12:32.028013Z"
    number: FB9279091
    number_intvalue: 9279091
    originated: "2021-07-06"
    parent_number: '&{NULL_VALUE}'
    product: AVFoundation
    product_version: iOS 14.6
    reproducible: Always
    resolved: ""
    status: Open
    title: AVErrorMediaServicesWereReset error when performing concurrent encodes with HDR source
