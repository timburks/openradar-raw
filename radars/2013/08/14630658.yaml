apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "14630658"
    labels:
        datastore_id: "5720827718795264"
data:
    classification: Other Bug
    created: "2013-08-02T10:03:37.264186Z"
    description: "Summary:\r\n\r\nAccording to its man page, the /usr/libexec.path_helper program \"reads the contents of the files in the directories /etc/paths.d and /etc/manpaths.d and appends their contents to the PATH and MANPATH environment variables respectively\".\r\n\r\nThis is either a bug in the utility or its docs because its actual behavior is quite different. Speaking only of PATH for instance, what it does is:\r\n\r\n1. read the list of paths in the file /etc/paths\r\n2. APPEND onto it the lists of paths in the files in the directory /etc/paths.d\r\n3. mutate the PATH variable to remove any items in the list\r\n4. APPEND onto the list the value of the PATH variable\r\n5. Save this list as the new PATH\r\n\r\nTo rephrase this in pseudocode, what it's doing is:\r\n\r\n1. NEWPATH = Read(/etc/paths)\r\n2. NEWPATH = $NEWPATH +append+ Read(/etc/paths.d/*) \r\n3. PATH        = $PATH -minus- $NEWPATH\r\n4. NEWPATH = $NEWPATH +append+ $PATH\r\n5. PATH        = $NEWPATH\r\n\r\nIn other words, the man page says path_helper is appending /etc/paths.d onto the PATH. But actually, path_helper is APPENDing /etc/paths.d onto the list from /etc/paths and then effectively PREPENDing that result onto actual pre-existing PATH (as well as purging duplicates).\r\n\r\nSteps to Reproduce:\r\nIn numbered format, detail the exact steps taken to produce the bug.\r\n1. launch Terminal.app\r\n2. $ export PATH=/Users/foo/bin:$PATH\r\n3. $ eval `/usr/libexec/path_helper -s` \r\n4. echo $PATH\r\n\r\nExpected Results:\r\nExpect to see /Users/foo/bin as the first item in the path, since the man page since path_helper generates bash code that will APPEND the system paths.\r\n\r\nActual Results:\r\nActually see /Users/foo/bin behind all of the system-wide paths, because path_helper actually generates bash code that PREPENDS the system paths.\r\n\r\nRegression:\r\nI believe path_helper has never worked as documented.\r\n\r\nNotes:\r\n\r\nWhy is this a problem? Obviously it is different from the man page so that is confusing.\r\n\r\nBut the real problem is that *prepending* onto PATH is a bug. Since items early in the PATH override items later in the PATH, and since the paths in /etc/paths and /etc/paths.d are system-wide configurations, prepending these values onto PATH has the effect of causing the system-wide PATH components to override any user-supplied PATH components.\r\n\r\nFor instance, suppose you want /Users/myself/bin to override /usr/bin so you define PATH=/Users/foo/bin:$PATH. After running eval `path_helper -s`, your PATH has been re-arranged so that PATH=...:/usr/bin:...:/Users/foo/bin.\r\n\r\nThis is especially a problem with the built-in zsh shell, because of OS X's default /etc/shenv. The factory-supplied /etc/zshenv sources calls path_helper. zsh always calls /etc/zshev, before it calls other startup scripts like .profile or .zshrc.  If a user is starting a login zsh, then zsh calls .profile, which sets up the path manually and probably fixes changes introduced by /etc/zshenv. But if a user is starting a non-login zsh (for instance, by lauching a subshell from the command line, or by launching zshell from inside another application like emacs), then .profile is not called, and that zsh instance inherits the PATH of its parent strangely mangled by the call to path_helper in /etc/zshev.\r\n\r\nSteps to Reproduce (interaction with zsh):\r\n1. open a Terminal\r\n2. $ sudo chsh -s /bin/zsh\r\n3. $ export PATH=/Users/foo/bin:$PATH\r\n4. $ zsh\r\n5  $ echo $PATH. \r\n\r\nExpected Results  (interaction with zsh):\r\nExpect to see /Users/foo/bin as the first item in the path, since a subshell should inherit the PATH of its parent shell.\r\n\r\nActual Results  (interaction with zsh):\r\nActually see /Users/foo/bin behind all of the system-wide paths, since zsh startup calls /etc/zshenv which calls path_helper, which PREPENDS the system paths.\r\n\r\nFor the problem with zsh, one workaround is, at the end of .profile, to save the final computed PATH into a variable FINALPATH, and in the beginning of .zshrc to restore PATH to FINALPATH. Since FINALPATH will be properly inherited by subshells without being changed by path_helper, .zshrc will restore the correct PATH.\r\nSummary:\r\n\r\nAccording to its man page, the /usr/libexec.path_helper program \"reads the contents of the files in the directories /etc/paths.d and /etc/manpaths.d and appends their contents to the PATH and MANPATH environment variables respectively\".\r\n\r\nThis is either a bug in the utility or in its docs, because its actual behavior is quite different. Speaking only of PATH for instance, what it does is:\r\n\r\n1. read the list of paths in the file /etc/paths\r\n2. APPEND onto it the lists of paths in the files in the directory /etc/paths.d\r\n3. mutate the PATH variable to remove any items in the list\r\n4. APPEND onto the list the value of the PATH variable\r\n\r\nTo rephrase this in pseudocode, what it's doing is:\r\n\r\n1. SYSTEMPATH = Read(/etc/paths)\r\n2. SYSTEMPATH = $SYSTEMPATH +append+ Read(/etc/paths.d/*) \r\n3. PATH       = $PATH -minus- $SYSTEMPATH\r\n3. PATH       = SYSTEMPATH +append+ $PATH\r\n\r\nIn other words, the man page says path_helper is appending /etc/paths.d onto the PATH. But actually, path_helper is APPENDing /etc/paths.d onto the list from /etc/paths and then effectively PREPENDing that result onto actual pre-existing PATH (as well as purging duplicates).\r\n\r\nSteps to Reproduce (Basic behavior):\r\nIn numbered format, detail the exact steps taken to produce the bug.\r\n1. open a Terminal\r\n2. $ export PATH=/Users/foo/bin:$PATH\r\n3. $ eval `/usr/libexec/path_helper -s` \r\n4. echo $PATH\r\n\r\nExpected Results  (Basic behavior):\r\nExpect to see /Users/foo/bin as the first item in the path, since the man page since path_helper generates bash code that will APPEND the system paths.\r\n\r\nActual Results  (Basic behavior):\r\nActually see /Users/foo/bin behind all of the system-wide paths, because path_helper actually generates bash code that PREPENDS the system paths.\r\n\r\n\r\nRegression:\r\nDescribe circumstances where the problem occurs or does not occur, such as software versions and/or hardware configurations.\r\n\r\nNotes:\r\n\r\nWhy is this a problem? Obviously it is different from the man page so that is confusing.\r\n\r\nBut the real problem is that *prepending* onto PATH is a bug. Since items early in the PATH override items later in the PATH, and since the paths in /etc/paths and /etc/paths.d are system-wide configurations, prepending these values onto PATH has the effect of causing the system-wide PATH components to override any user-specific PATH configurations.\r\n\r\nFor instance, you want /Users/myself/bin to override /usr/bin so you define PATH=/Users/foo/bin:/usr/bin. After running eval `path_helper -s`, your PATH has been re-arranged so that PATH=...:/usr/bin:...:/Users/foo/bin.\r\n\r\nThis is notably a problem with the built-in zsh shell. The factory-supplied /etc/zshenv sources calls path_helper. zsh always calls /etc/zshev, before it calls other startup script like .profile or .zshrc.  If a user is starting a login zsh, then zsh calls .profile, which sets up the path manually and fixes changes introduced by path_helper. But if a user is starting a non-login zsh (for instance, by lauching a subshell from the command line, or by launching zshell from inside another application like emacs), then .profile is not called, and that zsh instance inherits the PATH of its parent strangely mangled by the call to path_helper in /etc/zshev.\r\n\r\nSteps to Reproduce (interaction with zsh):\r\nIn numbered format, detail the exact steps taken to produce the bug.\r\n1. open a Terminal\r\n2. $ sudo chsh -s /bin/zsh\r\n3. $ export PATH=/Users/foo/bin:$PATH\r\n4. $ zsh  # launches a subshell\r\n5  $ echo $PATH. \r\n\r\nExpected Results  (interaction with zsh):\r\nExpect to see /Users/foo/bin as the first item in the path, since a subshell should inherit the PATH of its parent shell\r\n\r\nActual Results  (interaction with zsh):\r\nActually see /Users/foo/bin behind all of the system-wide paths, since zsh startup calls /etc/zshenv which calls path_helper, which PREPENDS the system paths.\r\n\r\nFor the problem with zsh, one workaround is, in .profile, to save the final computed PATH into a variable FINALPATH, and in zshrc to set PATH equal to FINALPATH.  FINALPATH will be properly inherited by subshells without being mangled by path_helper and then .zshrc will restore the correct PATH. But this should not be necessary."
    email: alexisgallagher@gmail.com
    modified: "2013-08-02T10:03:37.264343Z"
    number: "14630658"
    number_intvalue: 14630658
    originated: "2013-08-02"
    parent_number: '&{NULL_VALUE}'
    product: OS X
    product_version: 10.8.4
    reproducible: Always
    resolved: ""
    status: Open
    title: path_helper prepends not appends system paths
