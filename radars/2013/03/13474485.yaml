apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "13474485"
    labels:
        datastore_id: "2886403"
data:
    classification: Crash/Hang/Data Loss
    created: "2013-03-21T18:20:38.764817Z"
    description: "Summary:\r\nSending an ICMPv6 ECHO REQUEST packet over a connected ICMP datagram socket (without root permissions) causes a kernel panic. This issue affects 10.8.x as well as 10.7.x (verified with 10.7.5).\r\n\r\nSteps to Reproduce:\r\n1. Create an ICMPv6 socket: socket(PF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6)\r\n2. Connect the socket to an IPv6 address: connect(...)\r\n3. Create an ICMPv6 packet by hand\r\n4. Send the ICMPv6 packet over the socket: send(...)\r\n\r\nExpected Results:\r\nEither the packet is sent or an error is returned.\r\n\r\nActual Results:\r\nThe kernel panics.\r\n\r\nRegression:\r\nn/a\r\n\r\nNotes:\r\nI can even tell you exactly where the bug is in the kernel code. I only have the kernel code from 10.8.2 (10.8.3 source has not been released yet), but the problem still exists in 10.8.3.\r\n\r\nTake a look at icmp6_dgram_send() in icmp6.c:\r\n\r\n__private_extern__ int\r\nicmp6_dgram_send(struct socket *so, int flags, struct mbuf *m,\r\n    struct sockaddr *nam, struct mbuf *control, struct proc *p)\r\n{\r\n#pragma unused(flags, p)\r\n\tint error = 0;\r\n\tstruct inpcb *inp = sotoinpcb(so);\r\n\tstruct sockaddr_in6 tmp;\r\n\tstruct sockaddr_in6 *dst = (struct sockaddr_in6 *)(void *)nam;\r\n\tstruct icmp6_hdr *icmp6;\r\n\r\n\tif (kauth_cred_issuser(so->so_cred))\r\n\t\treturn rip6_output(m, so, (struct sockaddr_in6 *)(void *)nam,\r\n\t\t    control, 0);\r\n\r\n\t/* always copy sockaddr to avoid overwrites */\r\n\tif (so->so_state & SS_ISCONNECTED) {\r\n\t\tif (nam) {\r\n\t\t\tm_freem(m);\r\n\t\t\treturn EISCONN;\r\n\t\t}\r\n\t\t/* XXX */\r\n\t\tbzero(&tmp, sizeof(tmp));\r\n\t\ttmp.sin6_family = AF_INET6;\r\n\t\ttmp.sin6_len = sizeof(struct sockaddr_in6);\r\n\t\tbcopy(&inp->in6p_faddr, &tmp.sin6_addr,\r\n\t\t\t  sizeof(struct in6_addr));\r\n\t\tdst = &tmp;\r\n\t} else {\r\n\t\tif (nam == NULL) {\r\n\t\t\tm_freem(m);\r\n\t\t\treturn ENOTCONN;\r\n\t\t}\r\n\t\ttmp = *(struct sockaddr_in6 *)(void *)nam;\r\n\t\tdst = &tmp;\r\n\t}\r\n\r\nIf the socket is connected (`SS_ISCONNECTED`) and we get to beyond the code above, we know for sure that `nam` is NULL (otherwise we had returned with the error code `EISCONN`). `nam` is not touched till the end of the function. At the end of the function, the following function call is performed:\r\n\r\n\treturn rip6_output(m, so, (struct sockaddr_in6 *)(void *)nam,\r\n\t   control, 0);\r\n\r\nRemember, `nam` *IS NULL*! I think you probably wanted to use `dst` here, not `nam`. This is probably a copy&paste error from the same call at the beginning of the function, which is only performed if the socket is owned by root.\r\n\r\nNow take a look at rip6_output() in raw_ip6.c:\r\n\r\nint\r\nrip6_output(\r\n\tregister struct mbuf *m,\r\n\tstruct socket *so,\r\n\tstruct sockaddr_in6 *dstsock,\r\n\tstruct mbuf *control,\r\n\tint israw)\r\n{\r\n\tstruct in6_addr *dst;\r\n\tstruct ip6_hdr *ip6;\r\n\tstruct inpcb *in6p;\r\n\tu_int\tplen = m->m_pkthdr.len;\r\n\tint error = 0;\r\n\tstruct ip6_pktopts opt, *optp = 0;\r\n\tstruct ip6_moptions *im6o = NULL;\r\n\tstruct ifnet *oifp = NULL;\r\n\tint type = 0, code = 0;\t\t/* for ICMPv6 output statistics only */\r\n\tmbuf_svc_class_t msc = MBUF_SC_UNSPEC;\r\n\tstruct ip6_out_args ip6oa =\r\n\t    { IFSCOPE_NONE, { 0 }, IP6OAF_SELECT_SRCIF };\r\n\tint flags = IPV6_OUTARGS;\r\n\r\n\tif (dstsock && IN6_IS_ADDR_V4MAPPED(&dstsock->sin6_addr)) {\r\n\t\tm_freem(m);\r\n\t\treturn (EINVAL);\r\n\t}\r\n\r\n\tin6p = sotoin6pcb(so);\r\n\r\n\tif (in6p->inp_flags & INP_BOUND_IF) {\r\n\t\tip6oa.ip6oa_boundif = in6p->inp_boundifp->if_index;\r\n\t\tip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;\r\n\t}\r\n\tif (in6p->inp_flags & INP_NO_IFT_CELLULAR)\r\n\t\tip6oa.ip6oa_flags |= IP6OAF_NO_CELLULAR;\r\n\r\n\tdst = &dstsock->sin6_addr;\r\n\r\ndstsock is NULL! So this line in fact is the same as `dst = (NULL + 8)`. `dst` is not being used in the code up to that line:\r\n\r\n\t/*\r\n\t * Next header might not be ICMP6 but use its pseudo header anyway.\r\n\t */\r\n\tip6->ip6_dst = *dst;\r\n\r\nHere the system panics because this operation is a memory access to address 0x8, which is within the first memory page and read access to this page cause a CPU page fault exception."
    email: m.hanauska@gmail.com
    modified: "2013-10-24T11:34:57.825969Z"
    number: "13474485"
    number_intvalue: 13474485
    originated: 21-Mar-2013
    parent_number: '&{NULL_VALUE}'
    product: OS X
    product_version: 10.8.3
    reproducible: Always
    resolved: Fixed in Mavericks (MacOS 10.9)
    status: Closed
    title: Sending ICMPv6 ECHO REQUEST over a connected ICMP socket panics the kernel
