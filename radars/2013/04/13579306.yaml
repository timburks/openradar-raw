apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "13579306"
    labels:
        datastore_id: "2915402"
data:
    classification: ""
    created: "2013-04-06T00:44:22.498698Z"
    description: "Here is the code for the system library version of swapcontext taken from the apple open source site:\r\nint swapcontext(ucontext_t *oucp, const ucontext_t *ucp)\r\n{\r\n    int ret;\r\n    if ((oucp == NULL) || (ucp == NULL)) {\r\n            errno = EINVAL;\r\n            return (-1);\r\n    }\r\n    oucp->uc_flags &= ~UCF_SWAPPED;\r\n    ret = getcontext(oucp);\r\n    if ((ret == 0) && !(oucp->uc_flags & UCF_SWAPPED)) {\r\n            oucp->uc_flags |= UCF_SWAPPED;\r\n            ret = setcontext(ucp);\r\n    }\r\n    return (ret);\r\n}\r\n\r\nOn the OS X port of libc in Mac OSX 10.7.5, this gets compiled to:\r\n\r\n0x00007fff901e86b2 <swapcontext+0>:     push   %r14\r\n0x00007fff901e86b4 <swapcontext+2>:     push   %rbx\r\n0x00007fff901e86b5 <swapcontext+3>:     sub    $0x8,%rsp\r\n0x00007fff901e86b9 <swapcontext+7>:     test   %rdi,%rdi\r\n0x00007fff901e86bc <swapcontext+10>:    je     0x7fff901e86c6 <swapcontext+20>\r\n0x00007fff901e86be <swapcontext+12>:    mov    %rsi,%rbx\r\n0x00007fff901e86c1 <swapcontext+15>:    test   %rbx,%rbx\r\n0x00007fff901e86c4 <swapcontext+18>:    jne    0x7fff901e86d8 <swapcontext+38>\r\n0x00007fff901e86c6 <swapcontext+20>:    callq  0x7fff90262c88 <__error>\r\n0x00007fff901e86cb <swapcontext+25>:    movl   $0x16,(%rax)\r\n0x00007fff901e86d1 <swapcontext+31>:    mov    $0xffffffff,%eax\r\n0x00007fff901e86d6 <swapcontext+36>:    jmp    0x7fff901e86f3 <swapcontext+65>\r\n0x00007fff901e86d8 <swapcontext+38>:    mov    %rdi,%r14\r\n0x00007fff901e86db <swapcontext+41>:    andb   $0x7f,0x3(%r14)\r\n0x00007fff901e86e0 <swapcontext+46>:    mov    %r14,%rdi\r\n0x00007fff901e86e3 <swapcontext+49>:    callq  0x7fff901e87af <getcontext>\r\n0x00007fff901e86e8 <swapcontext+54>:    test   %eax,%eax\r\n0x00007fff901e86ea <swapcontext+56>:    jne    0x7fff901e86f3 <swapcontext+65>\r\n0x00007fff901e86ec <swapcontext+58>:    mov    (%r14),%ecx\r\n0x00007fff901e86ef <swapcontext+61>:    test   %ecx,%ecx\r\n0x00007fff901e86f1 <swapcontext+63>:    jns    0x7fff901e86fb <swapcontext+73>\r\n0x00007fff901e86f3 <swapcontext+65>:    add    $0x8,%rsp\r\n0x00007fff901e86f7 <swapcontext+69>:    pop    %rbx\r\n0x00007fff901e86f8 <swapcontext+70>:    pop    %r14\r\n0x00007fff901e86fa <swapcontext+72>:    retq\r\n0x00007fff901e86fb <swapcontext+73>:    or     $0x80000000,%ecx\r\n0x00007fff901e8701 <swapcontext+79>:    mov    %ecx,(%r14)\r\n0x00007fff901e8704 <swapcontext+82>:    mov    %rbx,%rdi\r\n0x00007fff901e8707 <swapcontext+85>:    add    $0x8,%rsp\r\n0x00007fff901e870b <swapcontext+89>:    pop    %rbx\r\n0x00007fff901e870c <swapcontext+90>:    pop    %r14\r\n0x00007fff901e870e <swapcontext+92>:    jmpq   0x7fff90262855 <setcontext>\r\n\r\nThe important thing to note is that rbx and r14 are stored on the stack and therefore not stored by the getcontext call.  This would be okay, but there is a tail call to setcontext after they are popped off.  We next look at setcontext and see:\r\n\r\n(gdb) disassemble setcontext\r\nDump of assembler code for function setcontext:\r\n0x00007fff90262855 <setcontext+0>:      push   %rbx\r\n0x00007fff90262856 <setcontext+1>:      lea    0x38(%rdi),%rbx\r\n0x00007fff9026285a <setcontext+5>:      cmp    0x30(%rdi),%rbx\r\n0x00007fff9026285e <setcontext+9>:      je     0x7fff90262864 <setcontext+15>\r\n0x00007fff90262860 <setcontext+11>:     mov    %rbx,0x30(%rdi)\r\n0x00007fff90262864 <setcontext+15>:     mov    0x4(%rdi),%edi\r\n0x00007fff90262867 <setcontext+18>:     callq  0x7fff90262998 <sigsetmask>\r\n0x00007fff9026286c <setcontext+23>:     mov    %rbx,%rdi\r\n0x00007fff9026286f <setcontext+26>:     pop    %rbx\r\n0x00007fff90262870 <setcontext+27>:     jmpq   0x7fff90262875 <_setcontext>\r\nEnd of assembler dump.\r\n\r\nIt begins by pushing rbx to stack and trashing the memory location where r14 was stored.  It then calls sigsetmask which pushes stuff on the stack overwriting the memory location where rbx was stored.  Thus when we revive the saved context, rbx and r14 will both have bogus values when the pop statement are executed in swapcontext.\r\n\r\n\r\nSteps to Reproduce: Any call to swapcontext in which rbx or r14 stores something important will lose rbx or r14.\r\n\r\nExpected Results: rbx and r14 are callee saved registers.  They should be preserved.\r\n\r\nActual Results:\r\n\r\nRegression:\r\n\r\nNotes:"
    email: bdemsky@gmail.com
    modified: "2013-04-06T00:44:22.499168Z"
    number: "13579306"
    number_intvalue: 13579306
    originated: 4/4/2013
    parent_number: '&{NULL_VALUE}'
    product: OS X
    product_version: 10.7.5
    reproducible: yes
    resolved: ""
    status: Duplicate
    title: Swapcontext is broken on 10.7.5
