apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "9599977"
    labels:
        datastore_id: "1216404"
data:
    classification: Other Bug
    created: "2011-06-13T19:13:37.897731Z"
    description: "Summary:\r\n\r\nThe “timezone” variable from libc is not usable in the iOS Simulator. It works properly on a real iOS device and in desktop Mac OS X.\r\n\r\nSteps to Reproduce:\r\n\r\nBuild and run this program. You can do this for the iOS Simulator, an iOS device, and desktop Mac OS X.\r\n\r\n--\r\n#import <Foundation/Foundation.h>\r\n#include <time.h>\r\n\r\nint main(int argc, char* argv[]) {\r\n  NSLog(@\"Before: %d\", timezone);\r\n  tzset();\r\n  NSLog(@\"After: %d\", timezone);\r\n  return 0;\r\n}\r\n--\r\n\r\nExpected Results:\r\n\r\nThe expected “after” value is 18000 in New York and 28800 in Cupertino. The value should be the number of seconds west of UTC during standard (not daylight) time for the currently selected time zone. This is 5 * 60 * 60 in New York and 8 * 60 * 60 in Cupertino.\r\n\r\nActual Results:\r\n\r\nThe iOS device (4.3) and desktop OS (10.6.7) both report the proper “after” value. For me, this is 18000, because my system is configured to use New York as the time zone.\r\n\r\nThe iOS simulator (4.3) shows both 1474660693 for the “before” and “after” values.\r\n\r\nRegression:\r\n\r\nNone that I can see, although it is an unnecessary area of divergence between the iOS device and simulator targets.\r\n\r\nNotes:\r\n\r\nThis bug is caused by the simulator’s libSystem (libc) design, which overlays ….sdk/usr/lib/libSystem.dylib on top of the host system’s /usr/lib/libSystem.dylib. Other similar bugs may be present, the one I’m reporting relates to the use of the “timezone” variable.\r\n\r\nIn the iOS (and iOS Simulator) SDK’s <sys/cdefs.h>, there is no non-UNIX2003 mode for source code at all. iOS is always UNIX2003. This is controlled by the __DARWIN_ONLY_UNIX_CONFORMANCE macro. Thus, according to <time.h>, there should only be a timezone variable, and no timezone(int, int) function, because __DARWIN_UNIX03 is always be defined for iOS and the iOS Simulator. At the binary level, libSystem (libc) only offers timezone in the data section in the iOS device SDK; this is the timezone variable. There is no timezone(int, int) function. However, the design of libSystem (libc) for the iOS simulator target presents a timezone symbol in the text section.\r\n\r\nmark@selecty bash$ nm /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.3.sdk/usr/lib/libSystem.dylib | grep timezone\r\n0000d298 T _timezone\r\n\r\nT for Text. There isn’t any corresponding declaration for this timezone function, but it’s present in the Simulator’s ….sdk/usr/lib/libSystem.dylib. This libSystem.dylib itself relies on ….sdk/usr/lib/system/libSystem.host.dylib, which is a symbolic link to the real native /usr/lib/libSystem.dylib. That means that compiled code is expecting to see a timezone variable according to this declaration:\r\n\r\nextern long timezone;\r\n\r\nbut ld actually resolves “timezone” as the text symbol, which is a timezone function. There’s no error or warning because the linker had no idea that the source expected “timezone” in a specific section, it simply resolves symbols by name, and it finds the one in the text section first because that’s what’s present in ….sdk/usr/lib/libSystem.dylib.\r\n\r\nThe value of timezone in the simulator is always 1474660693 (when you expect 18000). This isn’t a function pointer, it’s the first few instructions of the timezone function.\r\n\r\nThis all became clear to me when I printed 1474660693 in hexadecimal. It’s 0x57e58955. That looks very much like an x86 function prologue.\r\n\r\nWhile debugging this, I found dladdr to be handy. Noting that the value of “daylight” was correct while the value of “timezone” was not, I wrote:\r\n\r\nDl_info dli;\r\nint dlr = dladdr(&timezone, &dli);\r\nNSLog(@\"timezone dlr=%d fname=%s fbase=%p sname=%s saddr=%p\", dlr, dli.dli_fname, dli.dli_fbase, dli.dli_sname, dli.dli_saddr);\r\n\r\ndlr = dladdr(&daylight, &dli);\r\nNSLog(@\"daylight dlr=%d fname=%s fbase=%p sname=%s saddr=%p\", dlr, dli.dli_fname, dli.dli_fbase, dli.dli_sname, dli.dli_saddr);\r\n\r\nand noted the difference in output:\r\n\r\ntimezone dlr=1 fname=/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.3.sdk/usr/lib/libSystem.dylib\r\nfbase=0xcae000 sname=timezone saddr=0xcbb298\r\ndaylight dlr=1 fname=/usr/lib/libSystem.B.dylib fbase=0x90a5b000\r\nsname=daylight saddr=0xa00a67b4\r\n\r\nNote the difference between the fname for each. timezone is coming from ….sdk/usr/lib/libSystem.dylib as opposed to the host’s /usr/lib/libSystem.B.dylib, but ….sdk/usr/lib/libSystem.dylib exposes timezone as a text symbol, not data.\r\n\r\nAnd finally:\r\n\r\nmark@selecty bash$ gdb -q\r\n(gdb) file /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.3.sdk/usr/lib/libSystem.dylib\r\n[...]\r\n(gdb) disas timezone timezone+4\r\nDump of assembler code from 0xd298 to 0xd29c:\r\n0x0000d298 <timezone+0>:        push   %ebp\r\n0x0000d299 <timezone+1>:        mov    %esp,%ebp\r\n0x0000d29b <timezone+3>:        push   %edi\r\nEnd of assembler dump.\r\n(gdb) x/1 timezone\r\n0xd298 <timezone>:      0x57e58955\r\n\r\nThere’s the phantom value."
    email: mark@chromium.org
    modified: "2011-08-28T05:36:20.638734Z"
    number: "9599977"
    number_intvalue: 9599977
    originated: 06/13/2011
    parent_number: "7155711"
    product: iPhone SDK
    product_version: "4.3"
    reproducible: Always
    resolved: ""
    status: Duplicate/7155711
    title: Can’t use “timezone” variable (libc) in iOS Simulator
