apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "9288661"
    labels:
        datastore_id: "1168403"
data:
    classification: Other
    created: "2011-04-15T01:19:07.532556Z"
    description: "14-Apr-2011 09:15 PM Ryan Sleevi:\r\nSummary:\r\nWhen SecTrustEvaluate is called for a SecTrustRef that contains an EV candidate\r\ncertificate, a policy to fetch CRLs and OCSP from the cache only, action data to\r\ncheck revocation per certificate, and a set of anchors set via\r\nSecTrustSetAnchorCertificates, it's possible for a CFArrayRef of EV anchor\r\ncertificates to be leaked.\r\n\r\nSteps to Reproduce:\r\nCreate a SecPolicyRef for CRLs (default is network fetching disabled)\r\nCreate a SecPolicyRef for OCSP, with network fetching disabled\r\nCreate a SecPolicyRef for basic SSL validation\r\nCreate a SecCertificateRef for an end-entity certificate that chains to an EV root\r\nCreate a SecTrustRef for the certificate and policies\r\nAdd a list of trusted anchors via SecTrustSetAnchorCertificates[/Only]\r\nSet the policy ACTION_DATA to include CSSM_TP_ACTION_REQUIRE_REV_PER_CERT\r\nCall SecTrustEvaluate()\r\n\r\nExpected Results:\r\nValgrind reports no memory errors\r\n\r\nActual Results:\r\nValgrind reports a memory leak in the call to SecTrustEvaluate\r\n\r\nRegression:\r\n\r\nNotes:\r\n\r\nThe Valgrind backtrace is:\r\n\r\nLeak_DefinitelyLost\r\n256 bytes in 1 blocks are definitely lost in loss record 1,623 of 1,882\r\n  realloc (mp/valgrind-src/valgrind-memcheck/valgrind/coregrind/m_replacemalloc/vg_replace_malloc.c:525)\r\n  DefaultAllocator::realloc(void*, unsigned long)\r\n  Security::CssmAllocatorMemoryFunctions::relayRealloc(void*, unsigned long, void*)\r\n  Security::CssmMemoryFunctions::realloc(void*, unsigned long) const\r\n  Security::CssmMemoryFunctionsAllocator::realloc(void*, unsigned long)\r\n  Attachment::upcallRealloc(long, void*, unsigned int)\r\n  Security::PluginSession::realloc(void*, unsigned long)\r\n  DecodedExtensions::addExtension(cssm_data const&, bool, void*, bool, SecAsn1Template_struct const*, cssm_data const*)\r\n  DecodedExtensions::decodeFromNss(NSS_CertExtension**)\r\n  DecodedCert::DecodedCert(AppleX509CLSession&, Security::CssmData const&)\r\n  AppleX509CLSession::CertGetFirstFieldValue(Security::CssmData const&, Security::CssmData const&, unsigned int&, cssm_data*&)\r\n  cssm_CertGetFirstFieldValue(long, cssm_data const*, cssm_data const*, long*, unsigned int*, cssm_data**)\r\n  CSSM_CL_CertGetFirstFieldValue\r\n  allowedEVRootsForLeafCertificate\r\n  Security::KeychainCore::Trust::evaluate()\r\n  SecTrustEvaluate\r\n\r\nThe leak can clearly be seen in http://www.opensource.apple.com/source/libsecurity_keychain/libsecurity_keychain-40768/lib/Trust.cpp, reproduced in part below:\r\n\r\nvoid Trust::evaluate(bool disableEV)\r\n{\r\n\tbool isEVCandidate=false;\r\n\t// begin evaluation block with stack-based mutex\r\n\t{\r\n\tStLock<Mutex>_(mMutex);\r\n\t// if we have evaluated before, release prior result\r\n\tclearResults();\r\n\t\r\n\t// determine whether the leaf certificate is an EV candidate\r\n*1\tCFArrayRef allowedAnchors = allowedEVRootsForLeafCertificate(mCerts);\r\n\tCFArrayRef filteredCerts = NULL;\r\n*2\tisEVCandidate = (allowedAnchors && !disableEV) ? true : false;\r\n\tif (isEVCandidate) {\r\n\t\tsecdebug(\"evTrust\", \"Trust::evaluate() certificate is EV candidate\");\r\n\t\tfilteredCerts = potentialEVChainWithCertificates(mCerts);\r\n\t} else {\r\n\t\tif (mCerts) {\r\n\t\t\tfilteredCerts = CFArrayCreateMutableCopy(NULL, 0, mCerts);\r\n\t\t}\r\n*3\t\tif (mAnchors) {\r\n*4\t\t\tallowedAnchors = CFArrayCreateMutableCopy(NULL, 0, mAnchors);\r\n\t\t}\r\n\t}\r\n\r\n*1: Because the SecCertificateRef passed in is an EV candidate, allowedAnchors is a valid CFArrayRef of one or more EV root certificates\r\n*2: If disableEV is true, isEVCandidate will be set to false\r\n*3: Because SecTrustSetAnchorCertificates() was called, mAnchors will be non-null\r\n*4: At this point, the original allowedAnchors from *1 is leaked, replaced with a copy of the mAnchors\r\n\r\nAs far as I can tell from my cursory search, there is only one place where disableEV will be set to true, which is at the end of Trust::evaluate()\r\n\r\n\tif (isEVCandidate && mResult == kSecTrustResultRecoverableTrustFailure &&\r\n\t\tisRevocationServerMetaError(mTpReturn)) {\r\n\t\t// re-do the evaluation, this time disabling EV\r\n\t\tevaluate(true);\r\n\t}\r\n\r\nBecause the certificate is an EV candidate certificate, the OCSP policy specified by the user will be updated to require OCSP if a responder is specified. However, because network fetching is explicitly disabled, the OCSP status will return CSSMERR_APPLETP_OCSP_UNAVAILABLE as a result. Such a result will cause isRevocationServerMetaError to return true. When this happens, evaluate() will be called again, which is where the leak happens.\r\n\r\nCFReleasing and nil'ing allowedAnchors if !isEVCandidate, prior to any possible copy of mAnchors, seems like an appropriate fix, but has not been tested."
    email: ryan.sleevi@gmail.com
    modified: "2011-08-28T05:37:05.168105Z"
    number: "9288661"
    number_intvalue: 9288661
    originated: 14-Apr-2011 09:15 PM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: 10.6.7
    reproducible: Sometimes
    resolved: ""
    status: Open
    title: SecTrustEvaluate may leak a CFArrayRef of SecCertificateRefs
