apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "9288782"
    labels:
        datastore_id: "1169404"
data:
    classification: Other Bug
    created: "2011-04-15T01:40:57.324598Z"
    description: "14-Apr-2011 09:38 PM Ryan Sleevi:\r\nSummary:\r\nSecTrustEvaluate may call CSSM_DL_DataAbortQuery with an invalid/uninitialized CSSM_HANDLE\r\n\r\nSteps to Reproduce:\r\nCreate a SecPolicyRef for CRL validation\r\nCreate a SecTrustRef for a SecCertificateRef, including that SecPolicyRef\r\nCall SecTrustEvaluate\r\n\r\nExpected Results:\r\nValgrind reports no errors.\r\n\r\nActual Results:\r\nValgrind correctly points out that an uninitialized value of size 4 is used if there were errors fetching the CRL.\r\n\r\nNotes:\r\n\r\nThe Valgrind backtrace is\r\n\r\nUninitValue\r\nUse of uninitialised value of size 4\r\n  __gnu_cxx::hashtable<std::pair<long const, Security::MappingHandle<long>*>, long, __gnu_cxx::hash<long>, std::_Select1st<std::pair<long const, Security::MappingHandle<long>*> >, std::equal_to<long>, std::allocator<Security::MappingHandle<long>*> >::find(long const&)\r\n  Security::MappingHandle<long>::State::find(long, int)\r\n  Security::Cursor& Security::MappingHandle<long>::find<Security::Cursor>(long, int)\r\n  Security::AppleDatabase::dataAbortQuery(Security::DbContext&, long)\r\n  Security::DatabaseSession::DataAbortQuery(long, long)\r\n  cssm_DataAbortQuery(cssm_dl_db_handle, long)\r\n  CSSM_DL_DataAbortQuery\r\n  SSDLSession::DataAbortQuery(long, long)\r\n  cssm_DataAbortQuery(cssm_dl_db_handle, long)\r\n  CSSM_DL_DataAbortQuery\r\n  tpDbFindIssuerCrl\r\n  tpVerifyCertGroupWithCrls\r\n  AppleTPSession::CertGroupVerify(long, long, cssm_certgroup const&, cssm_tp_verify_context const*, cssm_tp_verify_context_result*)\r\n  cssm_CertGroupVerify(long, long, long, cssm_certgroup const*, cssm_tp_verify_context const*, cssm_tp_verify_context_result*)\r\n  CSSM_TP_CertGroupVerify\r\n  Security::CssmClient::TPImpl::certGroupVerify(Security::CertGroup const&, Security::TPVerifyContext const&, Security::TPVerifyResult*)\r\n  Security::KeychainCore::Trust::evaluate(bool)\r\n  SecTrustEvaluate\r\n\r\nThis can be confirmed in source at\r\nhttp://www.opensource.apple.com/source/libsecurity_apple_x509_tp/libsecurity_apple_x509_tp-40596/lib/TPDatabase.cpp, reproduced in part below\r\n\r\nTPCrlInfo *tpDbFindIssuerCrl(\r\n\tTPVerifyContext\t\t&vfyCtx,\r\n\tconst CSSM_DATA\t\t&issuer,\r\n\tTPCertInfo\t\t\t&forCert)\r\n{\r\n\tStLock<Mutex> _(SecTrustKeychainsGetMutex());\r\n\r\n\tuint32\t\t\t\t\t\tdbDex;\r\n*1\tCSSM_HANDLE\t\t\t\t\tresultHand;\r\n\tCSSM_DATA\t\t\t\t\tcrl;\t\r\n\tCSSM_DL_DB_HANDLE\t\t\tdlDb;\r\n\tCSSM_DB_UNIQUE_RECORD_PTR\trecord;\r\n\tTPCrlInfo \t\t\t\t\t*issuerCrl = NULL;\r\n\tCSSM_DL_DB_LIST_PTR \t\tdbList = vfyCtx.dbList;\r\n\tCSSM_RETURN\t\t\t\t\tcrtn;\r\n\t\r\n\tif(dbList == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\tfor(dbDex=0; dbDex<dbList->NumHandles; dbDex++) {\r\n\t\tdlDb = dbList->DLDBHandle[dbDex];\r\n\t\tcrl.Data = NULL;\r\n\t\tcrl.Length = 0;\r\n*2\t\trecord = tpCrlLookup(dlDb,\r\n\t\t\t&issuer,\r\n\t\t\tvfyCtx.verifyTime,\r\n\t\t\t&resultHand,\r\n\t\t\t&crl);\r\n\t\t/* remember we have to: \r\n\t\t * -- abort this query regardless, and \r\n\t\t * -- free the CSSM_DATA crl regardless, and \r\n\t\t * -- free the unique record if we don't use it \r\n\t\t *    (by placing it in issuerCert)...\r\n\t\t */\r\n\t\tif(record != NULL) {\r\n!\t\t\t<omitted for brevity>\r\n\r\n\t\t}\t/* tpCrlLookup, i.e., CSSM_DL_DataGetFirst, succeeded */\r\n\t\telse {\r\n\t\t\tassert(crl.Data == NULL);\r\n\t\t}\r\n\t\t/* in any case, abort the query for this db */\r\n*3\t\tCSSM_DL_DataAbortQuery(dlDb, resultHand);\r\n\t\t\r\n\t}\t/* main loop searching dbList */\r\n\r\n*1 is where resultHand is declared, but not initialized\r\n*2 attempts to fetch the CRL, with the expectation that the resultant handle will be written to resultHand\r\n*3 attempts to free the returned handle.\r\n\r\nin tpCrlLookup, there are only two return points. The first, if an invalid time is specified, which will return NULL and will not initialize resultHand. The second is after calling CSSM_DL_DataGetFirst.\r\n\r\nHowever, the return code of CSSM_DL_DataGetFirst is never checked. If CSSM_DL_DataGetFirst fails, resultHand may not be initialized. Subsequently, the attempt to free the handle will report an error.\r\n\r\nMy understanding is that resultHand should be initialized to CSSM_INVALID_HANDLE somewhere along the processing path. This should ensure that when the call eventually makes it to MappingHandle<CSSM_HANDLE>::find(), the attempt to locate the handle will fail, rather than possibly succeed in deleting a handle currently in use."
    email: ryan.sleevi@gmail.com
    modified: "2011-08-28T05:37:04.843834Z"
    number: "9288782"
    number_intvalue: 9288782
    originated: 14-Apr-2011
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: 10.6.7
    reproducible: Sometimes
    resolved: ""
    status: Open
    title: SecTrustEvaluate may attempt to free an invalid CSSM handle
