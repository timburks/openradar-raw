apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "9976774"
    labels:
        datastore_id: "1310402"
data:
    classification: Crash/Hang/Data Loss
    created: "2011-08-18T17:04:05.143701Z"
    description: "I know that ATS is deprecated, but I’ve found a memory-smash bug in ATS, and I’ll even tell you how to fix it, so you might just want to treat this as some low-hanging fruit and eat it.\r\n\r\nI see this bug on 10.7.1 11B26 and 10.7.0 11A511. Based on disassembly, the bug is present in 10.6.8 10K549, but we’ve never attributed any memory corruption to it on 10.6. It has shown up in our application in a very large way in 10.7, though.\r\n\r\nWe’ve discovered memory corruption occurring in Google Chrome Helper (renderer) processes within our calls to ATSFontDeactivate. The actual corruption occurs in SendDeactivateFontsInContainerMessage, which appears to have multiple bugs. A complete write-up of the bug is at http://crbug.com/93191. Important bits are excerpted here.\r\n\r\nThe symptom is that the process will crash, log messages like this, or both:\r\n\r\nGoogle Chrome Helper(42302,0xaca812c0) malloc: *** error for object 0x59fb084: incorrect checksum for freed object - object was probably modified after being freed.\r\n*** set a breakpoint in malloc_error_break to debug\r\n\r\nIn this situation, the stack looks like\r\n\r\nBreakpoint 1, 0x9982fc97 in malloc_error_break ()\r\n(gdb) bt\r\n#0  0x9982fc97 in malloc_error_break ()\r\n#1  0x997f14ce in szone_error ()\r\n#2  0x997f154e in free_list_checksum_botch ()\r\n#3  0x997f7a31 in tiny_malloc_from_free_list ()\r\n#4  0x997f8903 in szone_malloc_should_clear ()\r\n#5  0x997f966b in szone_malloc ()\r\n#6  0x008f9435 in base::(anonymous namespace)::oom_killer_malloc(_malloc_zone_t*, unsigned long) (in Google Chrome Framework) (process_util_mac.mm:522)\r\n#7  0x9982f962 in malloc_zone_malloc ()\r\n#8  0x9a4a0198 in __CFAllocatorSystemAllocate ()\r\n#9  0x9a4a0174 in CFAllocatorAllocate ()\r\n#10 0x9a49fed1 in _CFRuntimeCreateInstance ()\r\n#11 0x9a4a8d6a in CFBasicHashCreate ()\r\n#12 0x9a4a8cc7 in __CFDictionaryCreateGeneric ()\r\n#13 0x9a4a8742 in CFDictionaryCreateMutable ()\r\n#14 0x9145ee61 in GetCachedInMemoryContainer ()\r\n#15 0x91460aca in SendDeactivateFontsInContainerMessage ()\r\n#16 0x9147335a in _eFODeactivateFontsInContainer ()\r\n#17 0x91482b2d in _eATSFontDeactivate ()\r\n#18 0x9149c961 in ATSFontDeactivate ()\r\n#19 0x019777c8 in WebCore::FontCustomPlatformData::~FontCustomPlatformData() (in Google Chrome Framework) (FontCustomPlatformData.cpp:88)\r\n#20 0x01cb4b01 in WebCore::CachedFont::allClientsRemoved() (in Google Chrome Framework) (CachedFont.cpp:183)\r\n\r\nThe object malloc is complaining about:\r\n\r\n(gdb) p (char*)0x59fb084\r\nUnsafe to call functions on thread 13: function: malloc_error_break on stack\r\nwarning: Canceling operation - malloc lock could be held on current thread.\r\n$1 = 0x59fb084 \"Text.framework/Versions/A/CoreText\"\r\n\r\nAnd, actually, backing up a bit to the nearest 0-byte on the front end:\r\n\r\n(gdb) p (char*) 0x59fb010\r\nUnsafe to call functions on thread 13: function: malloc_error_break on stack\r\nwarning: Canceling operation - malloc lock could be held on current thread.\r\n$2 = 0x59fb010 \"/System/Library/Frameworks/ApplicationServices.framework/Frameworks/???\\020?c\\032;???;\\t??(?W?\\r\\005i?\\\\\\032?\\022\\016?/?%\\017g.2$??\\022???~CoreText.framework/Versions/A/CoreText\"\r\n\r\nWith MallocScribble set, the garbage becomes a scribble pattern making it fairly obvious that \"CoreText.framework/Versions/A/CoreText\" was written to a freed block (in this case, the '?' are 0xaa, the “allocated but unused” pattern; the 0x55 'U' are the “freed” pattern):\r\n\r\n(gdb) p (char*)0x5bc8b50\r\nUnsafe to call functions on thread 1: function: malloc_error_break on stack\r\nwarning: Canceling operation - malloc lock could be held on current thread.\r\n$1 = 0x5bc8b50 \"/System/Library/Frameworks/ApplicationServices.framework/Frameworks/\", '?' <repeats 39 times>, \"UUUUUCoreText.framework/Versions/A/CoreText\"\r\n\r\nThe problem lies in SendDeactivateFontsInContainerMessage (ATS.framework). A complete annotated disassembly of the interesting parts of that function is at http://crbug.com/93191#c12 . Translated into C:\r\n\r\n  // This is where it gets pretty interesting.\r\n  const char ct_font_manager_unregister_font_for_data_name[] =\r\n      \"_CTFontManagerUnregisterFontForData\";\r\n  void* ct_font_manager_unregister_font_for_data =\r\n      dlsym(RTLD_DEFAULT, ct_font_manager_unregister_font_for_data_name);\r\n  if (!ct_font_manager_unregister_font_for_data) {\r\n    // This is where it gets really interesting.\r\n\r\n    // expect \"/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ATS.framework/Resources\"\r\n    const char* ats_resources_dir_path = GetATSResourcesDirPath();\r\n\r\n    if (ats_resources_dir_path) {\r\n      const char ats_framework_name[] = \"ATS.framework\";\r\n      const char* application_services_frameworks_path_end =\r\n          strstr(ats_resources_dir_path, ats_framework_name);\r\n      if (application_services_frameworks_path_end) {\r\n        const char coretext_suffix[] = \"CoreText.framework/Versions/A/CoreText\";\r\n        size_t coretext_suffix_size = arraysize(coretext_suffix);\r\n        size_t coretext_dylib_path_size =\r\n            application_services_frameworks_path_end -\r\n            ats_resources_dir_path +\r\n            coretext_suffix_size;\r\n\r\n        // malloc some memory that won't ever be freed, but it should probably\r\n        // only happen once per process.\r\n        char* coretext_dylib_path = malloc(coretext_dylib_path_size);\r\n        if (coretext_dylib_path) {\r\n          // expect 68\r\n          size_t application_services_frameworks_path_length =\r\n              application_services_frameworks_path_end - ats_resources_dir_path;\r\n\r\n          // The strncpy does not '\\0'-terminate coretext_dylib_path. It will\r\n          // copy at most application_services_frameworks_path_length (68)\r\n          // bytes from ats_resources_dir_path (a string with length 92).\r\n          strncpy(coretext_dylib_path,\r\n                  ats_resources_dir_path,\r\n                  application_services_frameworks_path_length);\r\n\r\n          // Since coretext_dylib_path is not '\\0'-terminated at this point,\r\n          // what strlen returns is anyone's best guess. It will be at least\r\n          // 68, but it might be more. In order for there to be no bug, it\r\n          // must be exactly 68. application_services_frameworks_path_length\r\n          // could be reused here. Alternatively, the strncpy above could be\r\n          // modified to pass coretext_suffix_size instead of\r\n          // application_services_frameworks_path_length, or use some other\r\n          // form of safer string handling.\r\n          memcpy(coretext_dylib_path + strlen(coretext_dylib_path),\r\n                 coretext_suffix,\r\n                 coretext_suffix_size);\r\n\r\n          // This is where it stops being really interesting, but it's still\r\n          // pretty interesting.\r\n\r\n          // dlopen a dylib that will never be dlclosed, but it will probably\r\n          // only happen once per process.\r\n          void* coretext_dylib =\r\n              dlopen(coretext_dylib_path, RTLD_LAZY | RTLD_LOCAL);\r\n          if (coretext_dylib) {\r\n            ct_font_manager_unregister_font_for_data =\r\n                dlsym(coretext_dylib,\r\n                      ct_font_manager_unregister_font_for_data_name);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (ct_font_manager_unregister_font_for_data) {\r\n    // Use it.\r\n  }\r\n\r\n  // This is where it stops being interesting.\r\n\r\nLet’s ignore the leaks (sloppy, sloppy, sloppy) because we’ve got bigger fish to fry.\r\n\r\nThe memory errors are in some incredibly poor string handling within the “very interesting” section. The code uses strncpy with an |n| (size) argument guaranteed to be too small so that strncpy never '\\0'-terminates the |s1| (destination) buffer. It then uses strlen to compute the length of the string that it just copied, despite the fact that it already knows how much data was just copied (it’s exactly |n| bytes), and because there’s no guarantee that there’s a '\\0' after the strncpyed string, strlen might return too large a length. Notably, malloc doesn’t zero memory it returns. Sometimes this code gets lucky and there’s a '\\0' after the strncpyed string. Other times, there isn’t, so strlen returns too large a result, and the subsequent memcpy is asked to write to memory beyond the end of the malloced buffer. Whatever’s beyond the end of the buffer may not belong to anyone or it may belong to something else, but it sure won’t belong to this code. That’s why we saw “incorrect checksum for freed object - object was probably modified after being freed” (when the memory didn’t belong to anyone and malloc found it had been tampered with on a subsequent allocation attempt) as well as random crashes throughout the code (when the memory did belong to someone else and it got trashed).\r\n\r\nI am currently working around this bug in my application by providing my own public symbol for __CTFontManagerUnregisterFontForData corresponding to an |extern \"C\"| function named _CTFontManagerUnregisterFontForData that’s a no-op. Since SendDeactivateFontsInContainerMessage looks the symbol up with dlsym(RTLD_DEFAULT), it finds my copy. Since ATS is apparently never successfully calling CTFontManagerUnregisterFontForData now because it looks the symbol up by an incorrect name, the no-op stub works around the bug without altering functionality.\r\n\r\nThe correct solution here is anything that prevents ATS from writing to memory that it doesn’t own. Since SendDeactivateFontsInContainerMessage was apparently unsuccessful at calling CTFontManagerUnregisterFontForData all along, you may not want to “fix” the symbol name, because it might result in behavior changes. On the other hand, you will certainly want to fix the poor string handling in this function."
    email: mark@chromium.org
    modified: "2012-07-27T18:56:58.473331Z"
    number: "9976774"
    number_intvalue: 9976774
    originated: "2011-08-18"
    parent_number: "9632502"
    product: Mac OS X
    product_version: 10.7.1 11B26
    reproducible: Always
    resolved: ""
    status: Duplicate/9632502
    title: Memory corruption in ATSFontDeactivate
