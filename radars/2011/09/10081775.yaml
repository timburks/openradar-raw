apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "10081775"
    labels:
        datastore_id: "1334407"
data:
    classification: Serious Bug
    created: "2011-09-06T23:27:59.288392Z"
    description: "06-Sep-2011 04:02 PM Eric Wing:\r\n'OpenALSuspendResume.zip' was successfully uploaded\r\n\r\n06-Sep-2011 04:02 PM Eric Wing:\r\nSummary:\r\n\r\nI believe I have found a race condition in the OpenAL implementation with respect to pausing and resuming \r\n(playing) on a source. This seems to occur for me when I am dealing with an application suspend and resume on iOS. This is what I do:\r\n\r\nOn App Suspend:\r\n1) I pause my playing OpenAL source\r\n2) I set the current OpenAL context to NULL\r\n3) I set the audio session to inactive\r\n\r\nOn App Resume\r\n1) I set the audio session to active\r\n2) I make the OpenAL context current\r\n3) I resume playing my OpenAL source\r\n\r\nSometimes, my source does not resume playing. I get no OpenAL errors. I discovered that when I check the OpenAL state right after I resume it, the source claims it is playing. But in the case where the source fails to play even though the OpenAL state says it was playing, if I check the OpenAL state again a few seconds later, it says it is paused.\r\n\r\nThis suggests there is some kind of race condition or internal bug that is ignoring or resetting my paused state.\r\n\r\nWith some additional experimentation, I disabled the code that set the current context to NULL and back. When I do this, I can not reproduce this problem. However, I don't consider this a workaround because I also use this suspend/resume code for handling audio interruption events. So this race condition must get fixed because setting/restoring the OpenAL context is required to properly handle interruption events.\r\n\r\n\r\nSteps to Reproduce:\r\nAttached is a simple sample project that isolates the the problem. It uses my open source ALmixer which wraps OpenAL to make playback a little easier to setup in less code. Ultimately, the ALmixer_PauseChannel and ALmixer_ResumeChannel just call alSourcePause and alSourcePlay. Don't let the scary code fool you. This particular case is not complex, and you probably don't need to worry too much about scrutinizing this code.\r\n\r\nI added some addition printf statements in ALmixer for checking the pause and resume-playing states. The specific lines of the most interest are around 2842 in ALmixer.c:\r\n\r\n\t\t\t\talGetSourcei(\r\n\t\t\t\t\t\t\t ALmixer_Channel_List[channel].alsource,\r\n\t\t\t\t\t\t\t AL_SOURCE_STATE, &state\r\n\t\t\t\t\t\t\t );\r\n\t\t\t\tif(state != AL_PAUSED)\r\n\t\t\t\t{\r\n\t\t\t\t\tfprintf(stderr, \"Internal_PauseChannel assertion failed: not paused %x, source=%d\\n\", state, ALmixer_Channel_List[channel].alsource);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfprintf(stderr, \"Internal_ResumeChannel assertion passed: paused %x, source=%d\\n\", state, ALmixer_Channel_List[channel].alsource);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\nThe assertion always passes for me. So to catch the bad race condition, I added additional code in AppDelegate.m in:\r\n- (void)applicationDidBecomeActive:(UIApplication *)application\r\n\r\nAfter I resume everything, I schedule a callback function to fire in 2 seconds:\r\n\t[self performSelector:@selector(checkSourceState:) withObject:nil afterDelay:2];\r\n\r\nThe code checks the state one more time and prints the result:\r\n\r\n- (void) checkSourceState:(id)object\r\n{\r\n\tALint source_state = 0;\r\n\talGetSourcei(ALmixer_GetSource(0), AL_SOURCE_STATE, &source_state);\r\n\tif(AL_PLAYING != source_state)\r\n\t{\r\n\t\tNSLog(@\"Assertion failure in checkSourceState. Should be AL_PLAYING, but is %x\", source_state);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tNSLog(@\"checkSourceState passed; is AL_PLAYING, %x\", source_state);\t\t\r\n\t}\r\n}\r\n\r\nSo to reproduce, build and run the app. (Make sure the application does not exit on suspend in the Info.plist.) Keep suspending and resuming the app. Watch the console and wait for the debugging messages to fire after the 2 second period. When the audio finally fails to come back, when the 2 second callback fires, you should see the assertion failure message. I usually only need to suspend and resume 2-5 times before I encounter this problem.\r\n\r\n\r\nMy failure log output looks like:\r\n2011-09-06 14:10:01.862 OpenALSuspendResume[1466:707] applicationWillResignActive:\r\nInternal_ResumeChannel assertion passed: paused 1013, source=2400\r\n2011-09-06 14:10:01.869 OpenALSuspendResume[1466:707] Error setting audio session active to 0! '!ini'\r\n2011-09-06 14:10:04.591 OpenALSuspendResume[1466:707] applicationDidBecomeActive:\r\n2011-09-06 14:10:04.592 OpenALSuspendResume[1466:707] Error setting audio session active to 1! '!ini'\r\nAudioStreamBasicDescription:  2 ch,  44100 Hz, 'lpcm' (0x00000C2C) 8.24-bit little-endian signed integer, deinterleaved\r\nInternal_ResumeChannel assertion passed: playing 1012, source=2400\r\n2011-09-06 14:10:06.610 OpenALSuspendResume[1466:707] Assertion failure in checkSourceState. Should be AL_PLAYING, but is 1013\r\n\r\n\r\n\r\nExpected Results:\r\nAudio should not fail to resume playing. State should be PLAYING.\r\n\r\nActual Results:\r\nAudio sometimes does not resume playing. State changes from PLAYING to PAUSED.\r\n\r\n\r\n\r\nNotes:\r\nI also added a #define which disables my OpenAL context NULL/restore code. At the top of ALmixer.c, you will see a commented out line:\r\n//#define DONT_SUSPEND_APPLE_OPENAL_CONTEXT\r\n\r\nUncomment this line to bypass my setting of the OpenAL context to NULL and back on suspend/resume. When I do this, I don't seem to encounter the race condition problem.\r\n\r\n\r\n\r\n06-Sep-2011 06:22 PM Eric Wing:\r\nI did some testing on an iPad 1 running 4.3.5 and was not able to reproduce the problem. I have a report complaining about 4.3 on iPad 2 so I'm thinking the problem  iPad 2 regardless of OS version. I definitely have the problem on iPad 2 running iOS 5 beta.\r\n\r\n\r\n07-Sep-2011 11:45 AM Eric Wing:\r\nI got reports that suggest this same race condition may also exist in the Mac implementation. I have not directly verified, but my new workaround which bypasses setting the OpenAL context to NULL and back seems to avoid any problem on the Mac."
    email: ewmailing@gmail.com
    modified: "2011-09-07T18:52:31.020924Z"
    number: "10081775"
    number_intvalue: 10081775
    originated: "2011-09-06"
    parent_number: '&{NULL_VALUE}'
    product: iPhone SDK
    product_version: "4.3"
    reproducible: Sometimes
    resolved: ""
    status: Open
    title: OpenAL race condition for pausing/resuming source w/ app suspend/resume
