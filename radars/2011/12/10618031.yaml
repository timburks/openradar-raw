apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "10618031"
    labels:
        datastore_id: "1478402"
data:
    classification: Serious Bug
    created: "2011-12-22T06:37:18.98584Z"
    description: "Summary:\r\n\r\nkSecAttrApplicationTag is an attribute of SecKey items with the following documentation:\r\n\r\n\t kSecAttrApplicationTag\r\n             Specifies a dictionary key whose value is a CFDataRef containing private tag data.\r\n\r\nIn practice, most (but not all) functions in the Keychain Services API treat it as a CFStringRef.  Functions that output this attribute seem to always use CFStringRef.  Functions that accept this attribute in an input parameter sometimes take CFStringRefs, sometimes CFDataRefs, but never both. In either case, the arguments are usually not adequately type checked, resulting in crashes and unexpected Objective-C exceptions when we accidentally supply a value of the wrong type.\r\n\r\nThe type of this attribute should be consistent across all SecKey* and SecItem* functions. All input arguments should be type checked, and paramErr returned on type errors.\r\n\r\nA description of the erroneous behavior of individual functions is given below:\r\n\r\n(1) SecKeyGenerateSymmetric reports paramErr when given a kSecAttrApplicationTag with a CFDataRef value. It does accept CFStringRef values. The documentation should be amended to reflect that it accepts kSecAttrApplicationTag keys in its parameter dictionary, and the implementation should be fixed to allow CFDataRefs.\r\n\r\n(2) SecKeyGeneratePair is documented to accept kSecAttrApplicationTag, and works correctly when given a CFDataRef value. With CFStringRef, it should fail with paramErr, but instead crashes with the following call stack:\r\n\r\n    #0\t0x00007fff8ff06590 in longcopy ()\r\n    #1\t0x00007fff8fef1f8f in memmove$VARIANT$sse3x ()\r\n    #2\t0x00007fff8b26712f in Security::CssmDbAttributeData::set(cssm_db_attribute_info const&, Security::CssmPolyData const&, Security::Allocator&) ()\r\n    #3\t0x00007fff8b3ae6a2 in Security::CssmAutoDbRecordAttributeData::add(cssm_db_attribute_info const&, Security::CssmPolyData const&) ()\r\n    #4\t0x00007fff8b2e8469 in Security::KeychainCore::ItemImpl::modifyAttributesAndData(SecKeychainAttributeList const*, unsigned int, void const*) ()\r\n    #5\t0x00007fff8b306f80 in SecKeychainItemModifyAttributesAndData ()\r\n    #6\t0x00007fff8b300aef in SetKeyLabelAndTag(OpaqueSecKeyRef*, void const*, __CFData const*) ()\r\n    #7\t0x00007fff8b30207f in SecKeyGeneratePair ()\r\n\r\n(3) SecItemCopyMatching always returns kSecAttrApplicationTag values as CFStringRefs. It should instead return these values as CFDataRefs.\r\n\r\n(4) SecItemUpdate can't modify kSecAttrApplicationTag. When given a CFStringRef value, it reports success, but modifies kSecAttrLabel instead of kSecAttrApplicationTag. When given a CFDataRef value, it throws an Objective-C exception with the call stack given below. It should accept CFDataRefs and update the correct attribute.\r\n\r\n  #0  0x00007fff88983d45 in objc_exception_throw ()\r\n  #1  0x00007fff9242b4ce in -[NSObject doesNotRecognizeSelector:] ()\r\n  #2  0x00007fff9238c133 in ___forwarding___ ()\r\n  #3  0x00007fff9238bf48 in __forwarding_prep_0___ ()\r\n  #4  0x00007fff92306096 in CFStringGetCharactersPtr ()\r\n  #5  0x00007fff92304e04 in __CFStringEncodeByteStream ()\r\n  #6  0x00007fff8dd40387 in _CFStringCreateAttribute ()\r\n  #7  0x00007fff8dd40ca5 in _CreateSecKeychainKeyAttributeListFromDictionary ()\r\n  #8  0x00007fff8dd4006d in _UpdateKeychainItem ()\r\n  #9  0x00007fff8dd45234 in SecItemUpdate ()\r\n\r\n\r\nSteps to Reproduce:\r\n\r\n  I attached a sample command-line tool that creates a temporary keychain and generates a 3DES key and an RSA key pair into it, setting initial values for the application tag. \r\n  It then queries the kSecApplicationTag attributes for all three keys and displays their value and type on the console.\r\n  Finally, it tries to modify the application tag of the 3DES key using SecItemUpdate, then verifies the result.\r\n\r\n  The code demonstrating the four issues above is marked with the corresponding parenthesized number.\r\n\r\nExpected Results:\r\n\r\n  See above.\r\n\r\nActual Results:\r\n  \r\n  See above.\r\n\r\nRegression:\r\n\r\n  Unknown.\r\n\r\nNotes:\r\n\r\n\r\n//\r\n//  main.c\r\n//  KeychainBugs\r\n//\r\n//  Created by Károly Lőrentey on 2011-12-22.\r\n//  Copyright (c) 2011 __MyCompanyName__. All rights reserved.\r\n//\r\n\r\n#import <Foundation/Foundation.h>\r\n#import <Security/Security.h>\r\n\r\nstatic void ReportError(OSStatus status, NSString *message, ...) __attribute__((noreturn));\r\n\r\nstatic void \r\nReportError(OSStatus status, NSString *message, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, message);\r\n    NSString *bakedMessage = [[[NSString alloc] initWithFormat:message arguments:args] autorelease];\r\n    va_end(args);\r\n    CFStringRef errorString = SecCopyErrorMessageString(status, NULL);\r\n    NSLog(@\"%@: %@ (%d)\", bakedMessage, (errorString ? (NSString *)errorString : @\"unknown error\"),  (int)status);\r\n    if (errorString)\r\n        CFRelease(errorString);\r\n    exit(1);\r\n}\r\n\r\nstatic SecKeychainRef\r\nMakeKeychain(NSString *path)\r\n{\r\n    if ([[NSFileManager defaultManager] fileExistsAtPath:path]) {\r\n        [[NSFileManager defaultManager] removeItemAtPath:path error:NULL];\r\n    }\r\n    \r\n    SecKeychainRef keychain = NULL;\r\n    OSStatus status = SecKeychainCreate([path fileSystemRepresentation], 6, \"foobar\", NO, NULL, &keychain);\r\n    if (status)\r\n        ReportError(status, @\"Can't create keychain\");\r\n    [(id)keychain autorelease];\r\n    return keychain;\r\n}\r\n\r\nstruct Keypair {\r\n    SecKeyRef publicKey;\r\n    SecKeyRef privateKey;\r\n};\r\n\r\nstatic struct Keypair\r\nMakeRSAKeyPair(id tag, SecKeychainRef keychain)\r\n{\r\n    OSStatus status;\r\n    \r\n    NSMutableDictionary *parameters = [NSMutableDictionary dictionary];\r\n    \r\n    [parameters setObject:kSecAttrKeyTypeRSA forKey:kSecAttrKeyType];\r\n    [parameters setObject:[NSNumber numberWithInt:2048] forKey:kSecAttrKeySizeInBits];\r\n    [parameters setObject:(id)keychain forKey:kSecUseKeychain];\r\n    [parameters setObject:(id)kCFBooleanTrue forKey:kSecAttrIsPermanent];\r\n    [parameters setObject:@\"Test RSA Key\" forKey:kSecAttrLabel];\r\n    [parameters setObject:tag forKey:kSecAttrApplicationTag];\r\n    \r\n    SecKeyRef spublicKey = NULL;\r\n    SecKeyRef sprivateKey = NULL;\r\n    status = SecKeyGeneratePair((CFDictionaryRef)parameters, &spublicKey, &sprivateKey);\r\n    if (status)\r\n        ReportError(status, @\"Can't generate key pair\");\r\n    [(id)spublicKey autorelease];\r\n    [(id)sprivateKey autorelease];\r\n    \r\n    return (struct Keypair){ .publicKey = spublicKey, .privateKey = sprivateKey };\r\n}\r\n\r\nstatic SecKeyRef\r\nMake3DESKey(id tag, SecKeychainRef keychain)\r\n{\r\n    NSMutableDictionary *parameters = [NSMutableDictionary dictionary];\r\n    [parameters setObject:[NSNumber numberWithInt:192] forKey:kSecAttrKeySizeInBits];\r\n    [parameters setObject:kSecAttrKeyType3DES forKey:kSecAttrKeyType];\r\n    [parameters setObject:@\"Test key\" forKey:kSecAttrLabel];\r\n    [parameters setObject:(id)keychain forKey:kSecUseKeychain];\r\n    [parameters setObject:(id)kCFBooleanTrue forKey:kSecAttrIsPermanent];\r\n    [parameters setObject:tag forKey:kSecAttrApplicationTag];\r\n    \r\n    CFErrorRef cferror = NULL;\r\n    SecKeyRef skey = SecKeyGenerateSymmetric((CFDictionaryRef)parameters, &cferror);\r\n    if (skey == NULL) {\r\n        ReportError((OSStatus)CFErrorGetCode(cferror), @\"Can't generate symmetric key\");\r\n        CFRelease(cferror);\r\n    }\r\n    [(id)skey autorelease];\r\n    return skey;\r\n}\r\n\r\nstatic NSDictionary *\r\nAttributesForKey(SecKeyRef skey)\r\n{\r\n    NSDictionary *query = [NSDictionary dictionaryWithObjectsAndKeys:\r\n                           kSecClassKey, kSecClass,\r\n                           [NSArray arrayWithObject:(id)skey], kSecMatchItemList,\r\n                           kCFBooleanTrue, kSecReturnAttributes,\r\n                           kSecMatchLimitOne, kSecMatchLimit,\r\n                           nil];\r\n    NSDictionary *attrs = nil;\r\n    OSStatus status = SecItemCopyMatching((CFDictionaryRef)query, (CFTypeRef *)&attrs);\r\n    if (status)\r\n        ReportError(status, @\"Can't get item attributes\");\r\n    [(id)attrs autorelease];\r\n    return attrs;\r\n}\r\n\r\nstatic void\r\nChangeAttribute(SecKeyRef skey, id attribute, id value)\r\n{\r\n    NSDictionary *updatedAttrs = [NSDictionary dictionaryWithObject:value forKey:attribute];\r\n    \r\n    NSDictionary *query = [NSDictionary dictionaryWithObjectsAndKeys:\r\n                           kSecClassKey, kSecClass,\r\n                           [NSArray arrayWithObject:(id)skey], kSecMatchItemList,\r\n                           nil];\r\n    \r\n    OSStatus status = SecItemUpdate((CFDictionaryRef)query, (CFDictionaryRef)updatedAttrs);\r\n    if (status)\r\n        ReportError(status, @\"Can't update item attributes\");\r\n}\r\n\r\nint \r\nmain (int argc, const char *argv[])\r\n{\r\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\r\n\r\n    // Create an empty keychain.\r\n    NSString *keychainPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"Test Keychain.keychain\"];\r\n    SecKeychainRef keychain = MakeKeychain(keychainPath);\r\n\r\n    NSString *stringTag = @\"Test value\";\r\n    NSData *dataTag = [stringTag dataUsingEncoding:NSUTF8StringEncoding];\r\n    \r\n    // Create a symmetric key and a pair of assymetric keys.\r\n    \r\n    // (1) Using dataTag instead of stringTag here would make SecKeyGenerateSymmetric fail with paramErr:\r\n    SecKeyRef tripleDESKey = Make3DESKey(stringTag, keychain);\r\n    \r\n    // (2) Using stringTag instead of dataTag here would crash SecKeyGeneratePair:\r\n    struct Keypair keypair = MakeRSAKeyPair(dataTag, keychain);\r\n    \r\n    NSLog(@\"Keys successfully created.\");\r\n\r\n    // (3) SecItemCopyMatching should return kSecAttrApplicationTag values as CFDataRefs.\r\n    id tripleDESTag = [AttributesForKey(tripleDESKey) objectForKey:kSecAttrApplicationTag];\r\n    id publicTag = [AttributesForKey(keypair.publicKey) objectForKey:kSecAttrApplicationTag];;\r\n    id privateTag = [AttributesForKey(keypair.privateKey) objectForKey:kSecAttrApplicationTag];;\r\n    NSLog(@\"3DES application tag: '%@' (%@, should be __NSCFData)\", tripleDESTag, [tripleDESTag class]);\r\n    NSLog(@\"RSA public key application tag: '%@' (%@, should be __NSCFData)\", publicTag, [publicTag class]);\r\n    NSLog(@\"RSA private key application tag: '%@' (%@, should be __NSCFData)\", privateTag, [privateTag class]);\r\n    \r\n    // (4) SecItemUpdate should be able to modify kSecAttrApplicationTag. It modifies kSecAttrLabel instead.\r\n    CFStringRef newStringTag = CFSTR(\"New value\");\r\n    CFDataRef newDataTag = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)\"New value\", 9);\r\n    \r\n    ChangeAttribute(tripleDESKey, kSecAttrApplicationTag, (id)newDataTag);\r\n    \r\n    id tripleDESTag2 = [AttributesForKey(tripleDESKey) objectForKey:kSecAttrApplicationTag];\r\n    if (![(id)newStringTag isEqualTo:tripleDESTag2]) {\r\n        NSLog(@\"FAIL: SecItemUpdate did not modify kSecAttrApplicationTag (value is '%@', should be '%@')\",\r\n              tripleDESTag2, newStringTag);\r\n    }\r\n    else {\r\n        NSLog(@\"SUCCESS: SecItemUpdate could modify the value of the kSecAttrApplicationTag attribute\");\r\n    }\r\n    [pool drain];\r\n    return 0;\r\n}"
    email: Karoly.Lorentey@gmail.com
    modified: "2011-12-22T06:37:18.986247Z"
    number: "10618031"
    number_intvalue: 10618031
    originated: 22-Dec-2011 07:35 AM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: 10.7.2 (11C73)
    reproducible: Always
    resolved: ""
    status: Open
    title: kSecAttrApplicationTag is implemented inconsistently
