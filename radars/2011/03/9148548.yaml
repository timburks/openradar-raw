apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "9148548"
    labels:
        datastore_id: "1137403"
data:
    classification: ""
    created: "2011-03-17T15:51:41.58902Z"
    description: "http://crbug.com/60426 is a bug happening on the Chromium build\r\nwaterfall.  In the course of the fork() implementation, the child\r\nprocess crashes, even though the parent process never has a problem.\r\nThe specific cause is that the metadata which describes the length of\r\na freelist block is set to zero, which should not be possible.\r\nExtensive prodding has been unable to find a proven malloc corruption\r\nin the parent process to explain this.  In trying to trace backwards\r\nto find where the zero is coming from, it APPEARS that the parent\r\nprocess is coalescing a free'd block with the freelist, and when it\r\nclears the metadata using small_meta_header_set_middle(), the child\r\nprocess sees the cleared data.\r\n\r\nThat is clearly impossible!  And yet it moves, and I'm having troubles\r\nseeing how my case is not demonstrating exactly what I describe above\r\nhappening.  I've also been unable to reduce to a simpler repro as of\r\nyet.\r\n\r\nOur waterfall uses Mac Mini machines.  I've been repro'ing this on one\r\nlike what is currently available at the Apple store (Core 2 Duo, 8G\r\nRAM, 500G hard drive), but I think it was being seen on older models,\r\ntoo.  It repros on 10.5 or 10.6, but 10.6 gives a better stack\r\nbacktrace.  See the bug for more color, if you like that kind of\r\nthing.\r\n\r\nshess@chromium.org\r\n\r\n#################################################################\r\n\r\n# Setup to build Chromium, per\r\n# http://code.google.com/p/chromium/wiki/MacBuildInstructions\r\n\r\n# Build unit_tests using Xcode, or something like this (I usually\r\n# ssh to my captive trybot):\r\ncd .../src\r\ngclient sync --jobs 8\r\nxcodebuild -project chrome/chrome.xcodeproj \\\r\n  -target unit_tests -parallelizeTargets -configuration Debug\r\n\r\n# Demonstrate that the bug happens to you.\r\n./repeat_default.sh\r\n# No _child found\r\n# No _child found\r\n# ...\r\n# No _child found\r\n#   8   libSystem.B.dylib                   0x98cd69e5 pthread_workqueue_atfork_child + 48\r\n#   9   libSystem.B.dylib                   0x98cbbcc5 _cthread_fork_child + 176\r\n#   8   libSystem.B.dylib                   0x98cd69e5 pthread_workqueue_atfork_child + 48\r\n#   9   libSystem.B.dylib                   0x98cbbcc5 _cthread_fork_child + 176\r\n# Found a crash on iteration 26\r\n#### Usually takes between 20 and 100 iterations.  The pthread/cthread\r\n#### lines are from the stack backtrace, and are different on 10.5, so\r\n#### my script won't work there.\r\n\r\n# Once proven, set out to build an interpose library to add logging.\r\n\r\n# These are the versions I happened to repro with.  I don't believe\r\n# there are substantive changes in the other nearby versions.\r\nLIBC=Libc-594.9.1\r\nXNU=xnu-1504.7.4\r\n\r\n# Get Libc and unpack it.\r\nwget http://www.opensource.apple.com/tarballs/Libc/${LIBC}.tar.gz\r\ntar -xvzf ${LIBC}.tar.gz\r\n\r\n# xnu needed for dark magic.\r\nwget http://www.opensource.apple.com/tarballs/xnu/${XNU}.tar.gz\r\ntar -xvzf ${XNU}.tar.gz\r\n\r\n# Apply some patches.  The patches were generated by git format-patch,\r\n# in case anyone wants to see things in isolation to verify my work.\r\ncd ${LIBC}\r\npatch -p1 <../0001-Add-my_magazine_malloc.c.patch \r\npatch -p1 <../0002-Don-t-inline-small_malloc_should_clear.patch \r\npatch -p1 <../0003-Interpose-scalable_zone-interface.patch\r\npatch -p1 <../0004-eprintf-to-help-with-logging.patch\r\npatch -p1 <../0005-small_ptr_index-adds-a-logging-function-which-increm.patch \r\npatch -p1 <../0006-Add-logging-to-check-the-last-free-ptr-in-various-pl.patch \r\n\r\n# Hack the build environment to match what make would have.\r\nmkdir out\r\nln -s ../../${XNU}/osfmk out/System\r\ndtrace -o out/magmallocProvider.h -C -h -s gen/magmallocProvider.d\r\n\r\n# Build a dylib.  my_magazine_malloc.c includes malloc.c and\r\n# magazine_malloc.c, and interposes all over them.\r\n# TODO(shess): I don't think it messes with malloc.c any longer, but\r\n# I'm too lazy to fix that up right now.\r\ngcc -Iout -Ipthreads -DPRIVATE -arch i386 -arch x86_64 -dynamiclib -std=gnu99 \\\r\n    -current_version 1.0 -compatibility_version 1.0 -fvisibility=hidden \\\r\n    ./gen/my_magazine_malloc.c -o /tmp/libMagazineMalloc.dylib\r\n\r\n# Run things until failure, interposing the above dylib.\r\n./repeat_interpose.sh\r\n\r\n# The additional log lines in unit_tests_interpose.log are like:\r\n#   pid[cpu#]/seq# msg\r\n# The sequence number is two parts.  n%100 is from an incrementing\r\n# global static, while n/100 is from an incrementing item tucked into\r\n# the pad area of the small region the function sending the log is\r\n# working with.\r\n\r\n# The interesting part (just before the pthread/cthread logging) goes\r\n# something like:\r\n76440[0]/22457 last fp 0xd058000\r\n# The following are the parent process preparing to fork by acquiring\r\n# all the malloc locks.\r\n76440[0] szone_force_lock\r\n76440[0] szone_force_locked\r\n76440[0] szone_force_lock\r\n76440[0] szone_force_locked\r\n76440[0] szone_force_lock\r\n76440[0] szone_force_locked\r\n# The following are in the parent post-fork, releasing those locks.\r\n76440[0] szone_force_unlock\r\n76440[0] szone_force_unlock\r\n76440[0] szone_force_unlock\r\n# The parent continues on, with both sequence numbers incrementing.\r\n76440[0]/22558 coalesce 0xd04f800 next 0xd058000 delta 34816\r\n76440[0]/22659 last fp 0xd058000\r\n76440[0]/22760 sflrp 0xd058000\r\n76440[0]/22861 last fp 0xd125400\r\n76440[0]/22962 SMALL_PTR_SIZE(0xd058000) == 0 at 3929\r\n76440[0]/23063 last fp 0xd125400\r\n76440[0]/23164 sflap 0xd04f800\r\n76440[0]/23265 last fp 0xd04f800\r\n76440[0]/23366 last fp 0xd04f800\r\n# The child comes back from the fork and releases the locks which were\r\n# acquired by the parent in setting up the fork.\r\n76442[0] szone_force_unlock\r\n76442[0] szone_force_unlock\r\n76442[0] szone_force_unlock\r\n# Note that the n/100 sequence number continues from where the PARENT\r\n# is at, while the n%100 sequence number is doing the right thing\r\n# (continuing from where it was pre-fork).\r\n76442[0]/23458 SMALL_PTR_SIZE(0xd058000) == 0 at 4493\r\n76442[0]/23559 split 0xd058000, 0xd05ee00\r\n# The invalid metadata is detected, the crash is coming.\r\npid 76442 soon crashing, ptr 0xd058000 meta 0xd7f8594\r\n# Stack backtrace ..."
    email: bauerb@chromium.org
    modified: "2011-08-28T05:37:31.607856Z"
    number: "9148548"
    number_intvalue: 9148548
    originated: 17-Mar-2011 04:48 PM
    parent_number: '&{NULL_VALUE}'
    product: ""
    product_version: ""
    reproducible: ""
    resolved: ""
    status: Open
    title: Crash in malloc after fork
