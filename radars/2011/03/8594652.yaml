apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "8594652"
    labels:
        datastore_id: "1154401"
data:
    classification: ""
    created: "2011-03-29T19:41:50.696382Z"
    description: "26-Oct-2010 05:48 PM Mattias Nissler:\r\n'fsevents_test.cc' was successfully uploaded\r\n\r\n26-Oct-2010 05:48 PM Mattias Nissler:\r\nSummary:\r\nOn the Chromium continuous build infrastructure we see unit tests that run FSEvents code to monitor the file system fail in small fraction of runs. What happens is that events triggered by the testing code do not get reported to the callback.\r\n\r\nI've produced a small test program that reproduces the problem by generating a trigger and waiting for the corresponding notification in a loop.\r\n\r\nFYI the chromium code that exposes the problem is at http://git.chromium.org/gitweb/?p=chromium.git;a=blob;f=chrome/browser/file_path_watcher_mac.cc;h=cc925a6c39dcc5026d0f27bea136dc3b8d287ed0;hb=HEAD \r\n\r\nSteps to Reproduce:\r\nCompile and run attached test program.\r\n\r\nExpected Results:\r\nThe program should not terminate, and continuously print filesystem events.\r\n\r\nActual Results:\r\nThe program stops eventually, indicating that the notification for the last triggered event wasn't reported to the callback.\r\n\r\nRegression:\r\n\r\nNotes:\r\nThe problem shows up more reliably when using small callback latency parameters. Also, my MacPro usually manages some 10000 iterations before dying, while on my MacBook Pro the program dies after less than 100 iterations.\r\n\r\nHere's the code:\r\n\r\n\r\n/*\r\n * Tests FSEvents reliability, by modifying a file, waiting for the\r\n * corresponding notification and iterating. Theoretically, this program should\r\n * never terminate. In practice, it does sooner or later.\r\n *\r\n * To compile:\r\n *\r\n *    g++ -g -o fsevents_test -framework CoreFoundation \\\r\n *        -framework CoreServices fsevents_test.cc\r\n */\r\n\r\n#include <CoreFoundation/CoreFoundation.h>\r\n#include <CoreServices/CoreServices.h>\r\n\r\n#include <iostream>\r\n#include <limits>\r\n\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#include <sys/stat.h>\r\n#include <stdint.h>\r\n\r\nstatic char g_dirname[PATH_MAX];\r\nstatic char g_filename[PATH_MAX];\r\n\r\nstatic CFRunLoopTimerRef g_timer = NULL;\r\nstatic CFRunLoopSourceRef g_source = NULL;\r\n\r\nstatic void ModifyFile() {\r\n  int fd = open(g_filename, O_RDWR | O_CREAT, 0600);\r\n  if (fd == -1) {\r\n    std::cerr << \"Failed to open \" << g_filename << \": \"\r\n              << strerror(errno) << std::endl;\r\n    CFRunLoopStop(CFRunLoopGetCurrent());\r\n    return;\r\n  }\r\n\r\n  if (write(fd, \"data\", 4) == -1) {\r\n    std::cerr << \"Failed to write \" << g_filename << \": \"\r\n              << strerror(errno) << std::endl;\r\n    close(fd);\r\n    CFRunLoopStop(CFRunLoopGetCurrent());\r\n    return;\r\n  }\r\n\r\n  close(fd);\r\n\r\n  CFRunLoopTimerSetNextFireDate(g_timer, CFAbsoluteTimeGetCurrent() + 10);\r\n}\r\n\r\nstatic void TimerFired(CFRunLoopTimerRef timer, void* info) {\r\n  std::cerr << \"Timeout!\" << std::endl;\r\n  CFRunLoopStop(CFRunLoopGetCurrent());\r\n}\r\n\r\nstatic void SourceSignaled(void* info) {\r\n  ModifyFile();\r\n}\r\n\r\nstatic void EventCallback(ConstFSEventStreamRef stream,\r\n                          void* event_watcher,\r\n                          size_t num_events,\r\n                          void* event_paths,\r\n                          const FSEventStreamEventFlags flags[],\r\n                          const FSEventStreamEventId event_ids[]) {\r\n\r\n  for (size_t i = 0; i < num_events; i++) {\r\n    std::cout << \"Event \" << (uint64_t) event_ids[i] << \" for \"\r\n              << reinterpret_cast<char**>(event_paths)[i]\r\n              << \" flags: \" << std::hex << flags[i] << std::dec\r\n              << std::endl;\r\n  }\r\n\r\n  CFRunLoopSourceSignal(g_source);\r\n  CFRunLoopWakeUp(CFRunLoopGetCurrent());\r\n}\r\n\r\nint main() {\r\n\r\n  pid_t pid = getpid();\r\n  snprintf(g_dirname, PATH_MAX, \"/tmp/fsevents_test_%u\", pid);\r\n  snprintf(g_filename, PATH_MAX, \"%s/test\", g_dirname);\r\n\r\n  struct stat stat_info;\r\n  if (stat(g_dirname, &stat_info) == -1) {\r\n    if (errno != ENOENT) {\r\n      std::cerr << \"Stat on \" << g_dirname << \" failed: \"\r\n                << strerror(errno) << std::endl;\r\n      return 1;\r\n    }\r\n  } else {\r\n    std::cerr << \"Directory \" << g_dirname << \" already exists, aborting!\"\r\n              << std::endl;\r\n    return 1;\r\n  }\r\n\r\n  mkdir(g_dirname, 0700);\r\n\r\n  g_timer = CFRunLoopTimerCreate(NULL, std::numeric_limits<double>::max(),\r\n                                 0, 0, 0, TimerFired, NULL);\r\n  CFRunLoopAddTimer(CFRunLoopGetCurrent(), g_timer, kCFRunLoopCommonModes);\r\n\r\n  CFRunLoopSourceContext source_context;\r\n  bzero(&source_context, sizeof(source_context));\r\n  source_context.perform = SourceSignaled;\r\n  g_source = CFRunLoopSourceCreate(NULL, 0, &source_context);\r\n  CFRunLoopAddSource(CFRunLoopGetCurrent(), g_source, kCFRunLoopCommonModes);\r\n\r\n  CFStringRef dirname_string =\r\n      CFStringCreateWithCString(NULL, g_dirname, kCFStringEncodingMacHFS);\r\n  CFArrayRef paths =\r\n      CFArrayCreate(NULL, reinterpret_cast<const void**>(&dirname_string),\r\n                    1, NULL);\r\n  FSEventStreamRef stream =\r\n      FSEventStreamCreate(NULL, EventCallback, NULL, paths,\r\n                          kFSEventStreamEventIdSinceNow, 0.0,\r\n                          kFSEventStreamCreateFlagNoDefer |\r\n                          kFSEventStreamCreateFlagWatchRoot);\r\n  CFRelease(paths);\r\n  CFRelease(dirname_string);\r\n\r\n  FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(),\r\n                                   kCFRunLoopDefaultMode);\r\n  FSEventStreamStart(stream);\r\n\r\n  ModifyFile();\r\n\r\n  CFRunLoopRun();\r\n\r\n  FSEventStreamStop(stream);\r\n  FSEventStreamInvalidate(stream);\r\n  FSEventStreamRelease(stream);\r\n\r\n  unlink(g_filename);\r\n  unlink(g_dirname);\r\n\r\n  CFRelease(g_timer);\r\n\r\n  return 0;\r\n}"
    email: mnissler@google.com
    modified: "2011-08-28T05:39:24.721648Z"
    number: "8594652"
    number_intvalue: 8594652
    originated: 26-Oct-2010 05:48 PM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: "10.6"
    reproducible: Yes
    resolved: ""
    status: Open
    title: FSEvents fails to report events
