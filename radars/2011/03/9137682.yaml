apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "9137682"
    labels:
        datastore_id: "1138403"
data:
    classification: Crash/Hang/Data Loss
    created: "2011-03-15T21:35:16.547936Z"
    description: "### Added new information November 3, 2016\r\nStill happens in macOS 10.12. As far as I understand this means that macOS 10.12 does not conform to the Single Unix Specification.\r\n\r\n### Added new information 24-Oct-2013 00:44 AM\r\nStill happens in OS X 10.9.\r\n\r\n(foo.c in the transcript is the program in this bug report)\r\nbash-3.2$ cc -g -Wall -Werror -pthread foo.c && ./a.out 100000000 10\r\nStarting test, 100000000 iterations, sleep interval 10ms\r\nfoo.c:46: ERROR cancelled while PTHREAD_CANCEL_DISABLE\r\nIllegal instruction: 4\r\nbash-3.2$ cc --version\r\nApple LLVM version 5.0 (clang-500.2.78) (based on LLVM 3.3svn)\r\nTarget: x86_64-apple-darwin13.0.0\r\nThread model: posix\r\nbash-3.2$ file ./a.out\r\n./a.out: Mach-O 64-bit executable x86_64\r\nbash-3.2$ bash-3.2$ uname -a\r\nDarwin Ps-iMac.local 13.0.0 Darwin Kernel Version 13.0.0: Thu Sep 19 22:22:27 PDT 2013; root:xnu-2422.1.72~6/RELEASE_X86_64 x86_64\r\n\r\n### Original report\r\n\r\nSummary:\r\nA thread that has disabled cancellation with PTHREAD_CANCEL_DISABLE can still get cancelled when another thread does pthread_cancel()\r\n\r\nSteps to Reproduce:\r\nSee the below transcript. It may take hours for it to happen with this code but it happens far too often in our real code.\r\n\r\nExpected Results:\r\nA call to write() should not be cancelled while PTHREAD_CANCEL_DISABLE is in effect.\r\n\r\nActual Results:\r\n\r\nThe cleanup handler is called, despite PTHREAD_CANCEL_DISABLE being in effect (and it intentionally calls abort() to expose the bug).\r\n\r\nRegression:\r\n\r\nNotes: The following transcript shows the code and how it was run and some information about the machine. This is problem has been present in earlier versions of 10.6.x too and on other hardware. (I have updated XCode to 3.2.6 today before collecting the System Profiler report so the XCode version used in the transcript was the one before 3.2.6)\r\n\r\nbash$ gcc -g -Wall -Werror -pthread cancel_leak.c && ./a.out 100000000 10\r\nStarting test, 100000000 iterations, sleep interval 10ms\r\ncancel_leak.c:46: ERROR cancelled while PTHREAD_CANCEL_DISABLE\r\nAbort trap\r\nbash$ uname -a\r\nDarwin big-brothers-imac.local 10.6.0 Darwin Kernel Version 10.6.0: Wed Nov 10 18:13:17 PST 2010; root:xnu-1504.9.26~3/RELEASE_I386 i386\r\nbash$ sw_vers\r\nProductName:\tMac OS X\r\nProductVersion:\t10.6.6\r\nBuildVersion:\t10J567\r\nbash$ gcc --version\r\ni686-apple-darwin10-gcc-4.2.1 (GCC) 4.2.1 (Apple Inc. build 5664)\r\nCopyright (C) 2007 Free Software Foundation, Inc.\r\nThis is free software; see the source for copying conditions.  There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\nbash$ cat cancel_leak.c\r\n/*\r\n gcc -g -Wall -Werror -pthread cancel_leak.c && ./a.out 100000000 10\r\n*/\r\n\r\n#include <unistd.h>\r\n#include <pthread.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n\r\n#define PTHREAD_CHECK(X) do{                                            \\\r\n   int pthread_result = (X);                                           \\\r\n   if (pthread_result != 0)                                            \\\r\n     {                                                                 \\\r\n       fprintf(stderr, \"%s:%d: ERROR code %d from pthread operation\\n\", \\\r\n               __FILE__, (int)__LINE__,                                \\\r\n               (int)pthread_result);                                   \\\r\n       fflush(stderr);                                                 \\\r\n       abort();                                                        \\\r\n     }                                                                 \\\r\n } while(0)\r\n\r\n#define CLIB_CHECK(X) do{                                               \\\r\n   int clib_result = (X);                                              \\\r\n   if (clib_result == -1)                                              \\\r\n     {                                                                 \\\r\n       int errno_value = errno;                                        \\\r\n       fprintf(stderr, \"%s:%d: ERROR errno %d from clib operation\\n\",  \\\r\n               __FILE__, (int)__LINE__,                                \\\r\n               (int)errno_value);                                      \\\r\n       fflush(stderr);                                                 \\\r\n       abort();                                                        \\\r\n     }                                                                 \\\r\n } while(0)\r\n\r\nstruct thread_cookie {\r\n int wait_fd;\r\n int write_fd;\r\n};\r\n\r\n/* Should never be called on a POSIX compliant system */\r\nstatic void cleanup_routine(void *arg)\r\n{\r\n (void)arg;\r\n fprintf(stderr, \"%s:%d: ERROR cancelled while PTHREAD_CANCEL_DISABLE\\n\",\r\n         __FILE__, (int)__LINE__);\r\n fflush(stderr);\r\n abort();\r\n}\r\n\r\nstatic size_t cookie_wait_fd_read_attempts = 0;\r\nstatic size_t cookie_wait_fd_read = 0;\r\nstatic size_t cookie_write_fd_written= 0;\r\nstatic size_t pipefd_a_written = 0;\r\n\r\n/* RUN IN SEPARATE THREAD */\r\nstatic void *pthread_start_routine(void *vcookie)\r\n{\r\n struct thread_cookie *pcookie = (struct thread_cookie*)vcookie;\r\n int oldstate;\r\n char buf[1];\r\n {\r\n   ssize_t result;\r\n   PTHREAD_CHECK(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate));\r\n   cookie_wait_fd_read_attempts++;\r\n   do {\r\n     CLIB_CHECK(result = read(pcookie->wait_fd, &buf[0], 1));\r\n     if (result < 1)\r\n       {\r\n         fprintf(stderr, \"%s:%d ERROR read only %ld bytes\\n\", __FILE__, (int)__LINE__, (long)result);fflush(stderr);\r\n       }\r\n   } while (result < 1);\r\n\r\n   cookie_wait_fd_read++;\r\n\r\n   PTHREAD_CHECK(pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstate));\r\n   /* PTHREAD_CANCEL_DISABLE should prevent cancel here, but it does not. */\r\n   pthread_cleanup_push(cleanup_routine, NULL);\r\n   do {\r\n     CLIB_CHECK(result = write(pcookie->write_fd, &buf[0], 1));\r\n     if (result < 1)\r\n       {\r\n         fprintf(stderr, \"%s:%d ERROR wrote only %ld bytes\\n\", __FILE__, (int)__LINE__, (long)result);fflush(stderr);\r\n       }\r\n   } while (result < 1);\r\n   cookie_write_fd_written++;\r\n   pthread_cleanup_pop(0);     /* uninstall and do not call cleanup handler */\r\n }\r\n\r\n\r\n\r\n\r\n return NULL;\r\n}\r\n\r\nstatic void bad_usage(void)\r\n{\r\n fprintf(stderr, \"Usage: a.out ITERATIONS [MS SLEEP]\\n\");fflush(stderr);\r\n exit(EXIT_FAILURE);\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n pthread_t thread;\r\n void *thread_return = NULL;\r\n struct timespec nanosleep_interval;\r\n struct timespec nanosleep_rem;\r\n long ms_interval = 200;\r\n struct thread_cookie cookie;\r\n int pipefd_a[2];\r\n int pipefd_b[2];\r\n long iterations;\r\n (void)argc; (void)argv;\r\n if (argc != 2 && argc != 3)\r\n   {\r\n     bad_usage();\r\n     exit(EXIT_FAILURE);\r\n   }\r\n iterations = strtol(argv[1], NULL, 10);\r\n if (iterations <= 0)\r\n   {\r\n     bad_usage();\r\n   }\r\n if (argc == 3)\r\n   {\r\n     ms_interval = strtol(argv[2], NULL, 10);\r\n     if (ms_interval < 0)\r\n       {\r\n         bad_usage();\r\n       }\r\n   }\r\n\r\n fprintf(stderr, \"Starting test, %ld iterations, sleep interval %ldms\\n\", (long)iterations, (long)ms_interval);fflush(stderr);\r\n nanosleep_interval.tv_sec = 0;\r\n nanosleep_interval.tv_nsec = 1000*1000*ms_interval;\r\n while (iterations-- > 0)\r\n   {\r\n     CLIB_CHECK(pipe(pipefd_a));\r\n     CLIB_CHECK(pipe(pipefd_b));\r\n     cookie.wait_fd = pipefd_a[0]; /* input */\r\n     cookie.write_fd = pipefd_b[1]; /* output */\r\n     PTHREAD_CHECK(pthread_create(&thread,NULL,&pthread_start_routine, &cookie));\r\n     if (ms_interval > 0)\r\n       {\r\n         CLIB_CHECK(nanosleep(&nanosleep_interval, &nanosleep_rem));\r\n       }\r\n     /* Expects thread to wait for wait_fd now */\r\n     {\r\n       char data[1] = { 'X' };\r\n       ssize_t result;\r\n       do {\r\n       CLIB_CHECK(result = write(pipefd_a[1], &data[0], 1));\r\n       if (result < 1)\r\n         {\r\n           fprintf(stderr, \"%s:%d ERROR wrote only %ld bytes\\n\", __FILE__, (int)__LINE__, (long)result);fflush(stderr);\r\n         }\r\n       } while (result < 1);\r\n       pipefd_a_written++;\r\n\r\n       /* Expects thread to wake up soon and write to cookie.write_fd */\r\n     }\r\n     /* This may (and is allowed to) cancel thread while it waits for\r\n        cookie.wait_fd. The bug manifests itself it this cancels the\r\n        thread while it writes to cookie.write_fd */\r\n     PTHREAD_CHECK(pthread_cancel(thread));\r\n     PTHREAD_CHECK(pthread_join(thread, &thread_return));\r\n     CLIB_CHECK(close(pipefd_a[0]));\r\n     CLIB_CHECK(close(pipefd_a[1]));\r\n     CLIB_CHECK(close(pipefd_b[0]));\r\n     CLIB_CHECK(close(pipefd_b[1]));\r\n   }\r\n exit(EXIT_SUCCESS);\r\n}\r\nbash$\r\n\r\n05-Aug-2012 12:01 PM Per Mildner:\r\nStill happens in OS X 10.8 on the same iMac as in my original\r\nbug-report, both 64-bit and 32-bit:\r\n\r\nbash$ gcc -g -Wall -Werror -pthread cancel_leak.c && ./a.out 100000000 10\r\nStarting test, 100000000 iterations, sleep interval 10ms\r\ncancel_leak.c:46: ERROR cancelled while PTHREAD_CANCEL_DISABLE\r\nIllegal instruction: 4\r\nbash$ gcc --version\r\ni686-apple-darwin11-llvm-gcc-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)\r\nCopyright (C) 2007 Free Software Foundation, Inc.\r\nThis is free software; see the source for copying conditions.  There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\nbash$ uname -a\r\nDarwin imac 12.0.0 Darwin Kernel Version 12.0.0: Sun Jun 24 23:00:16 PDT 2012; root:xnu-2050.7.9~1/RELEASE_X86_64 x86_64\r\n\r\nAlso happens with cc (i.e. clang) on OS X 10.8:\r\n\r\nbash$ cc -g -Wall -Werror -pthread cancel_leak.c && ./a.out 100000000 10\r\nStarting test, 100000000 iterations, sleep interval 10ms\r\ncancel_leak.c:46: ERROR cancelled while PTHREAD_CANCEL_DISABLE\r\nIllegal instruction: 4\r\nbash$ cc --version\r\nApple clang version 4.0 (tags/Apple/clang-421.0.57) (based on LLVM 3.1svn)\r\nTarget: x86_64-apple-darwin12.0.0\r\nThread model: posix\r\n\r\nAlso happens in 32-bit code on OS X 10.8:\r\n\r\nbash$ cc -m32 -g -Wall -Werror -pthread cancel_leak.c && ./a.out 100000000 10\r\nStarting test, 100000000 iterations, sleep interval 10ms\r\ncancel_leak.c:74: ERROR cancelled while PTHREAD_CANCEL_DISABLE\r\nIllegal instruction: 4\r\nbash$ file a.out\r\na.out: Mach-O executable i386"
    email: Per.Mildner.usenet@gmail.com
    modified: "2016-11-03T18:12:23.25331Z"
    number: "9137682"
    number_intvalue: 9137682
    originated: 15-Mar-2011 10:28 PM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: 10.8 (12A269), 10.6.6 10J567
    reproducible: Always
    resolved: ""
    status: Open
    title: PTHREAD_CANCEL_DISABLE does not prevent pthread_cancel from cancelling thread
