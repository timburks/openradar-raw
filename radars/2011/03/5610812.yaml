apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "5610812"
    labels:
        datastore_id: "1142403"
data:
    classification: ""
    created: "2011-03-15T21:44:16.096686Z"
    description: "22-Nov-2007 07:48 PM Per Mildner:\r\nSummary: \r\npthread_cancel does not interrupt system calls that has already caused the thread to suspend. This makes \r\n\r\nSteps to Reproduce:\r\n\r\n1. Upgrade from pre-installed Tiger -> Leopard (bundled DVD) -> Mac OS X 10.5.1 and everything else available via Software Update. iMac Intel Core 2 Duo.\r\n2. Compile the test program below with the Xcode 3.0 /usr/bin/gcc without any extra args.\r\n3. Run ./a.out from bash.\r\n4. After 10 seconds the program should  cancel its worker thread and exit but it hangs forever.\r\n\r\nExpected Results:\r\n\r\npthread_cancel should wake up a thread blocking in read(2).\r\n\r\nActual Results:\r\n\r\nA thread blocking read(2) hangs forever even if another thread pthread_cancel-s the thread.\r\n\r\nRegression:\r\n\r\nConforming SUSv3/UNIX 2003 platforms does not have this problem. Neither does Linux nor Solaris.\r\n\r\nNotes:\r\n\r\n(This originated as a question to Darwin-kernel mailing list but got shot down as to much of a bug-report...)\r\n\r\nMy tests indicate that pthread_cancel still cannot interrupt blocking system calls like read(2) in Intel Mac OS X 10.5.1, despite the claim that it is now UNIX 2003 compliant. A brief look at the Darwin 9.0 kernel sources seems to confirm this.\r\n\r\nThe Single Unix Specification v3 (SUSv3) defines cancelation points in\r\nhttp://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09_05_02\r\n\r\nThe critical part, and the reason why pthread_testcancel is not sufficient is \"If a thread has cancelability enabled and a cancellation request is made with the thread as a target while the thread is suspended at a cancellation point, the thread shall be awakened and the cancellation request shall be acted upon.\". That is, pthread_cancel should wake (a well defined list of) blocking system calls.\r\n\r\nThe below test program shows that a blocking read() is _not_ awakened by pthread_cancel, making the cancelation handling in Leopard no improvement over earlier OS releases and in violation of the SUSv3 standard.\r\n\r\nThe test program starts a worker thread that loops reading from standard input. The main thread then sleeps for a while to ensure that the worker thread has blocked in read(2) and the main thread then cancels the worker thread. This program terminates on Linux and Solaris but not on Intel Leopard 10.5.1.\r\n\r\nFrom a cursory glance at xnu-1228, e.g. sys_generic.c, it looks as if the system calls that SUSv3 requires to be cancelation points are all implemented something like the following template:\r\n\r\nint read(...) {\r\n  pthread_testcancel();\r\n  return read_nocancel(...);\r\n}\r\n\r\nThat is, if a cancel is pending when the system call is entered then the call will be canceled but once the real system call is blocking it will not react to cancel requests.\r\n\r\nTranscript:\r\nbash$ gcc cancel_bug.c -Wall && ./a.out\r\nCreated thread, sleeping\r\ncalling read..<press return>\r\n.called read()==1\r\ncalling read..<press return>\r\n.called read()==1\r\ncalling read..cancelling read()\r\n<blocks forever or until more input is available>\r\n\r\nThis is with Xcode 3.0. Compiling with -D_APPLE_C_SOURCE does not make a difference.\r\n\r\n\r\n/* cancel_bug.c */\r\n#include <assert.h>\r\n#include <pthread.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nstatic int exit_status = EXIT_FAILURE;\r\n\r\n#define CHECK(X) do { if ((X) == 0) { fprintf(stderr, \"%s:%d CHECK FAILED\\n\", __FILE__, (int)__LINE__); } } while (0)\r\n\r\nvoid *\r\nfunc(void *arg)\r\n{\r\n  char buf;\r\n  int oldstate;\r\n  ssize_t res;\r\n\r\nexit_status = EXIT_SUCCESS;\r\n/* redundant */\r\nCHECK(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate) == 0);\r\n/* Will not terminate unless cancelled or read error */\r\ndo\r\n{\r\nfprintf(stderr, \"calling read..\");fflush(stderr);\r\nres = read(STDIN_FILENO, &buf, 1);\r\nfprintf(stderr, \".called read()==%ld\\n\", (long)res);fflush(stderr);\r\n}\r\nwhile (res != -1);\r\n\r\n  return NULL;\r\n}\r\n\r\nint\r\nmain(void)\r\n{\r\n  pthread_t thread;\r\n  void *retval;\r\n\r\n  CHECK(pthread_create(&thread, NULL, func, NULL) == 0);\r\n  fprintf(stderr, \"Created thread, sleeping\\n\");fflush(stderr);\r\n  sleep(10);                 /* ensure thread reaches blocking read */\r\n  fprintf(stderr, \"cancelling read()\\n\");fflush(stderr);\r\n  CHECK(pthread_cancel(thread) == 0);\r\n  CHECK(pthread_join(thread, &retval) == 0);\r\n  CHECK(PTHREAD_CANCELED == retval);\r\n\r\n  return exit_status;\r\n}\r\n\r\n\r\n\r\n\r\n25-Nov-2007 01:34 AM Per Mildner:\r\nTo rule out that the problem is specific to the tty or pty drivers and to investigate whether the problem persists even if asynchronous cancellation type is in effect I modified the worker thread function as follows.\r\n\r\nThe problem (i.e., infinite blocking persists) even if read is blocking from a pipe and even if asynchronous cancellation type is in effect.\r\n\r\nTo reproduce:\r\n1. Perform all the steps outlined in the original problem report.\r\n2. Create a new file identical to cancel_bug.c except that the original fun() is replaced with the one below. Call this new file cancel_bug_pipe.c\r\n3. gcc cancel_bug_pipe.c -Wall && ./a.out\r\n\r\n     This tests the behavior with the default, deferred, cancellation type\r\n     The result is as follows:\r\n\r\nbash$ gcc cancel_bug_pipe.c -Wall && ./a.out\r\nCreated thread, sleeping\r\nSetting PTHREAD_CANCEL_DEFERRED\r\nSetting PTHREAD_CANCEL_ENABLE\r\ncalling read..cancelling read()\r\n << the process hangs>>\r\n4. gcc -DUSE_PTHREAD_CANCEL_ASYNCHRONOUS cancel_bug_pipe.c -Wall && ./a.out\r\n\r\n    This tests the behavior when setting asynchronous cancellation type.\r\n    This result is as follows:\r\n\r\nbash$ gcc -DUSE_PTHREAD_CANCEL_ASYNCHRONOUS cancel_bug_pipe.c -Wall && ./a.out\r\nCreated thread, sleeping\r\nSetting PTHREAD_CANCEL_ASYNCHRONOUS\r\nSetting PTHREAD_CANCEL_ENABLE\r\ncalling read..cancelling read()\r\n << the process hangs>>\r\n\r\n\r\nvoid *\r\nfunc(void *arg)\r\n{\r\n  char buf;\r\n  int oldstate;\r\n  int oldtype;\r\n  ssize_t res;\r\n  int fildes[2];\r\n\r\n  CHECK(pipe(fildes) == 0);\r\n\r\n  exit_status = EXIT_SUCCESS;\r\n\r\n#if USE_PTHREAD_CANCEL_ASYNCHRONOUS\r\n  fprintf(stderr, \"Setting PTHREAD_CANCEL_ASYNCHRONOUS\\n\");fflush(stderr);\r\n  CHECK(pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype) == 0);\r\n#else  /* !USE_PTHREAD_CANCEL_ASYNCHRONOUS */\r\n  fprintf(stderr, \"Setting PTHREAD_CANCEL_DEFERRED\\n\");fflush(stderr);\r\n  /* redundant */\r\n  CHECK(pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype) == 0);\r\n#endif  /* !USE_PTHREAD_CANCEL_ASYNCHRONOUS */\r\n\r\n  fprintf(stderr, \"Setting PTHREAD_CANCEL_ENABLE\\n\");fflush(stderr);\r\n  /* redundant */\r\n  CHECK(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate) == 0);\r\n\r\n  /* Will not terminate unless cancelled or read error */\r\n  do\r\n    {\r\n      int read_fd = fildes[0];\r\n      fprintf(stderr, \"calling read..\");fflush(stderr);\r\n      res = read(read_fd, &buf, 1);\r\n      fprintf(stderr, \".called read()==%ld\\n\", (long)res);fflush(stderr);\r\n    }\r\n  while (res != -1);\r\n\r\n  return NULL;\r\n}\r\n\r\n\r\n25-Nov-2007 01:37 AM Per Mildner:\r\nCompiling cancel_bug_pipe.c with -D_APPLE_C_SOURCE does not make a difference (as expected).\r\n\r\n\r\n\r\n26-Nov-2007 09:21 PM Per Mildner:\r\nI brought this up on the austin-group-l mailing list (Nov 23 2007, Item 11231 \"A question about cancellation points\" on https://www.opengroup.org/sophocles/show_archive.tpl?listname=austin-group-l). Presumably the Austin list members have more experience than most in judging in matters related to SUSv3 conformance.\r\n\r\nThe consensus seems to be that the current Mac OS 10.5 behavior does not conform to SUSv3 and that:\r\n\r\n<quote>\r\nMac OS X is just broken. 10.5 apparently passed the VSTH suite, which \r\nsimply means that the test suite has missed a few more relatively \r\nobvious test cases.\r\n</quote>\r\n\r\n\"In particular, no test suite can detect every possible way that an\r\nimplementation can be non-conforming.\"\r\n\r\n<quote>\r\nI would seem to me that Apple should correct the problem, once\r\nreported, by its next Open Brand Certificate renewal date, which\r\nsi 18 May 2008.[sic]\r\n</quote>\r\n\r\n<quote>\r\nApple has an obligation to correct any reported non-conformities\r\n\"within the prescribed timescale\", regardless of what may not be\r\ndetected by a test suite.  (See\r\nhttp://www.opengroup.org/openbrand/ .)\"\r\n</quote>\r\n\r\nAnd, quoting from <http://www.opengroup.org/openbrand/>:\r\n\"If ... the non-conformance is not\r\ncorrected in the predefined timescale, then the Product\r\nRegistration, and the ability to use the trademark, will be lost.\"\r\n\r\nThe thread also points out that the behavior with PTHREAD_CANCEL_ASYNCHRONOUS is irrelevant since:\r\n\r\n<quote>\r\nIt would, in fact, be INCORRECT to call read(), or most other POSIX \r\nfunctions, with asynchronous cancel enabled.\r\n\r\n From POSIX, \"The pthread_cancel( ), pthread_setcancelstate( ), and \r\npthread_setcanceltype( ) functions are defined to\r\nbe async-cancel safe. No other functions in this volume of POSIX.1-200x \r\nare required to be async-cancel-safe.\"\r\n</quote>\r\n\r\nRegards,\r\n\r\n\r\n\r\n27-Nov-2007 08:19 PM Per Mildner:\r\nPS. The quotes from the austin-group-l mailing list included above was not intended to accuse anyone of \"hate crime\"(!) as someone suggested on the darwin-kernel mailing list. The quotes was to ensure that the problem I reported with deferred cancellation was not dismissed as a non-bug, which seemed likely from the darwin-kernel thread on this issue.\r\n\r\nRegards,"
    email: Per.Mildner.usenet@gmail.com
    modified: "2011-08-28T05:50:46.884096Z"
    number: "5610812"
    number_intvalue: 5610812
    originated: 22-Nov-2007 07:48 PM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: "10.5"
    reproducible: Always
    resolved: ""
    status: Duplicate
    title: pthread_cancel cancelation points (still) broken in Leopard
