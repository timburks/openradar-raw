apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "8926215"
    labels:
        datastore_id: "1092401"
data:
    classification: ""
    created: "2011-01-27T20:54:47.249893Z"
    description: "I think we need general access to key presses in iOS - especially when external/physical keyboards are in use. For Twitterrific, we would love to be able to carry over keyboard shortcuts from the Mac for people who are familiar with them, but there appears to be no way to do this with the public API.\r\n\r\nWhile I'm sure you already have an idea of how you might want to solve these problems, I figured I'd suggest the API design I came up with in case anyone is interested. :)\r\n\r\nTo UIResponder add the following method:\r\n\r\n- (void)keyPressed:(UIKey *)aKey withEvent:(UIEvent *)anEvent;\r\n\r\nThe UIResponder implementation of this could read the key and then check to see if the receiver conforms to the UIKeyInput, UITextInput, etc. protocols and do the expected stuff there. If the receiver doesn't implement those protocols, it should call [[self nextResponder] keyPressed:aKey withEvent:anEvent]; This is a little bit \"magical\" or \"heavy\" relative to the other UIResponder methods, but it seems a logical place to put this because then subclasses could easily handle some exceptional case (checking for a modifier key being down or whatever) and then simply call super to get the usual behavior thus allowing relatively easy subclassing of UITextField, UITextView, etc just to add some kind of special keyboard-centric magic if necessary. (Although to be honest, I'm not sure what magic that'd be given that keyboard usage should be considered rare/unusual on iOS devices.)\r\n\r\n\r\nDefine UIKey (or something like it) with an API something like this (partly inspired by some of the things available via NSEvent in AppKit):\r\n\r\ntypedef enum {\r\n\tUIKeyTypeCharacter,\r\n\tUIKeyTypeUpArrow,\r\n\tUIKeyTypeDownArrow,\r\n\tUIKeyTypeLeftArrow,\r\n\tUIKeyTypeRightArrow,\r\n\tUIKeyTypeReturn,\r\n\tUIKeyTypeEnter,\r\n\tUIKeyTypeHome,\r\n\tUIKeyTypeInsert,\r\n\tUIKeyTypeDelete,\r\n\tUIKeyTypeEnd,\r\n\tUIKeyTypePageUp,\r\n\tUIKeyTypePageDown,\r\n\tetc…\r\n} UIKeyType;\r\n\r\n@interface UIKey : NSObject\r\n@property (nonatomic, readonly) UIKeyType type;\r\n@property (nonatomic, readonly) NSString *characters; // could be nil\r\n@property (nonatomic, readonly) NSString *charactersWithModifiers; // could be nil\r\n@property (nonatomic, readonly, getter=isRepeat) BOOL repeat;\r\n@property (nonatomic, readonly, getter=isCapslockEnabled) BOOL capslockEnabled;\r\n@property (nonatomic, readonly, getter=isShiftKeyPressed) BOOL shiftKeyPressed;\r\n@property (nonatomic, readonly, getter=isControlKeyPressed) BOOL controlKeyPressed;\r\n@property (nonatomic, readonly, getter=isOptionKeyPressed) BOOL optionKeyPressed;\r\n@property (nonatomic, readonly, getter=isCommandKeyPressed) BOOL commandKeyPressed;\r\netc…\r\n@end\r\n\r\n\r\n\r\nWhen a key is pressed on the keyboard, UIApplication would be notified, a UIEvent created/updated, and then the app's keyWindow is given the event which then travels down that window's responder chain (if any) until something (if anything) handles it.\r\n\r\n\r\nAdditionally, I'd propose adding the following informal protocol:\r\n\r\n@interface NSObject (UIResponderStandardKeyboardActions)\r\n- (void)cancel:(id)sender;\r\n- (void)commit:(id)sender;\r\n@end\r\n\r\n\r\nBefore UIWindow sends the keyPressed event down the responder chain, it could check to see if a couple of standard conditions are true, and if they are, send one of these actions to the first responder instead. (Could use UIResponder's canPerformAction:withSender: to determine if they should even be sent.)\r\n\r\nThe purpose of these would be to map a couple of \"standard\" keyboard combos in an easy way. The idea is that -cancel: would be sent if ESC is pressed (this is similar to the idea of cancelOperation: in AppKit). -commit: could be sent if the user presses CMD-Return or the Enter key, since that's a rather common convention as well. There might be a couple others, but I wouldn't want to overdo it. I do think, though, that by standardizing a couple of common key combos, it'd help keep things cleaner and cover a lot of common cases and improve app consistency when a keyboard is being used."
    email: sean@spiffytech.com
    modified: "2011-08-28T05:38:09.950471Z"
    number: "8926215"
    number_intvalue: 8926215
    originated: Jan 27, 2011
    parent_number: '&{NULL_VALUE}'
    product: ""
    product_version: ""
    reproducible: ""
    resolved: ""
    status: Open
    title: Proposed API for handling key presses in UIKit
