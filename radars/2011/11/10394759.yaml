apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "10394759"
    labels:
        datastore_id: "1406408"
data:
    classification: Serious bug
    created: "2011-11-04T01:25:17.443524Z"
    description: "Summary:\r\n\r\nThe sign computation transformation created by SecSignTransformCreate does not report an error when the application does not have the credentials to sign data with the supplied SecKeyRef. \r\n\r\nInstead, it runs successfully, but produces corrupt signature data of length 32768. The contents of this signature look like random memory junk. SecVerifyTransform confirms that these signatures are invalid.\r\n\r\nThe result is the same with either SecTransformExecute and SecTransformExecuteAsync.\r\n\r\n\r\nSteps to Reproduce:\r\n\r\nThe attached project includes a silly little command-line tool that retrieves a random identity from your keychain and tries to sign the contents of /etc/passwd using SecSignTransform. It then tries to verify the result with a SecVerifyTransform.\r\n\r\n- Create at least one identity in your login keychain.\r\n- Build and run the attached project. It should make the system pop up a standard keychain access confirmation dialog. (\"SecTransformTest wants to sign using key \"<key>\" in your keychain.\")\r\n- Click \"Allow\".  It should produce the following output (indicating correct behavior):\r\n\r\n        2011-11-04 01:11:32.103 SecTransformTest[69579:707] Successfully signed, signature length: 256\r\n        2011-11-04 01:11:32.134 SecTransformTest[69579:707] Verified signature with result: 1 (OK)\r\n\r\n- Now re-run the project, but click \"Deny\". It will produce this result:\r\n\r\n        2011-11-04 01:23:05.550 SecTransformTest[69703:707] Successfully signed, signature length: 32768\r\n        2011-11-04 01:23:05.557 SecTransformTest[69703:707] Verified signature with result: 0 (FAIL)\r\n\r\nThus, with access denied, the sign transform runs successfully, but its result isn't a signature.\r\n\r\n\r\nExpected Results:\r\n\r\nThe sign transformation should either produce a valid signature or report an error.\r\n\r\n\r\nActual Results:\r\n\r\nThe sign transformation produces a bogus signature without reporting an error.\r\n\r\n\r\nRegression:\r\n\r\nNone, SecTransform is new in Lion.\r\n\r\n\r\nNotes:\r\n\r\nThe source code of the sample project is reproduced below:\r\n\r\n\r\n//\r\n//  main.c\r\n//  SecTransformTest\r\n//\r\n//  Created by Karoly Lorentey on 2011-11-04.\r\n//  Copyright (c) 2011 __MyCompanyName__. All rights reserved.\r\n//\r\n\r\n#import <Cocoa/Cocoa.h>\r\n#import <CoreFoundation/CoreFoundation.h>\r\n#import <Security/Security.h>\r\n\r\nCFDataRef CreateSignature (SecKeyRef privateKey, CFDataRef plaintext, CFErrorRef *error);\r\nCFBooleanRef CreateVerificationResult (SecKeyRef publicKey, CFDataRef plaintext, CFDataRef signature, CFErrorRef *error);\r\n\r\nCFDataRef \r\nCreateSignature (SecKeyRef privateKey, CFDataRef plaintext, CFErrorRef *error)\r\n{\r\n    SecTransformRef signingTransform = SecSignTransformCreate(privateKey, error);\r\n    if (signingTransform == NULL)\r\n        return NULL;\r\n    \r\n    Boolean success = SecTransformSetAttribute(signingTransform,\r\n                                               kSecTransformInputAttributeName,\r\n                                               plaintext,\r\n                                               error);\r\n    if (!success) {\r\n        CFRelease(signingTransform);\r\n        return NULL;\r\n    }\r\n    \r\n    CFDataRef signature = SecTransformExecute(signingTransform, error);\r\n    if (signature != NULL)\r\n        CFRetain(signature);\r\n    CFRelease(signingTransform);\r\n    return signature;\r\n}\r\n\r\nCFBooleanRef\r\nCreateVerificationResult (SecKeyRef publicKey, CFDataRef plaintext, CFDataRef signature, CFErrorRef *error)\r\n{\r\n    SecTransformRef verifyTransform = SecVerifyTransformCreate(publicKey, signature, error);\r\n    if (verifyTransform == NULL)\r\n        return NULL;\r\n    \r\n    Boolean success = SecTransformSetAttribute(verifyTransform,\r\n                                               kSecTransformInputAttributeName,\r\n                                               plaintext,\r\n                                               error);\r\n    if (!success) {\r\n        CFRelease(verifyTransform);\r\n        return NULL;\r\n    }\r\n    \r\n    CFBooleanRef result = SecTransformExecute(verifyTransform, error);\r\n    if (result != NULL)\r\n        CFRetain(result);\r\n    CFRelease(verifyTransform);\r\n    return result;\r\n}\r\n\r\nint main (int argc, const char * argv[])\r\n{\r\n    BOOL success = 0;\r\n    CFErrorRef error = NULL;\r\n    CFDataRef plaintext = (CFDataRef)[[NSData alloc] initWithContentsOfFile:@\"/etc/passwd\"];\r\n\r\n    CFMutableDictionaryRef query = CFDictionaryCreateMutable(kCFAllocatorDefault, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\r\n    CFDictionarySetValue(query, kSecClass, kSecClassIdentity);\r\n    CFDictionarySetValue(query, kSecReturnRef, kCFBooleanTrue);\r\n    CFDictionarySetValue(query, kSecMatchLimit, kSecMatchLimitOne);\r\n\r\n    SecIdentityRef identity = NULL;\r\n    SecCertificateRef certificate = NULL;\r\n    SecKeyRef publicKey = NULL;\r\n    SecKeyRef privateKey = NULL;\r\n    CFDataRef signature = NULL;\r\n    CFBooleanRef verified = NULL;\r\n\r\n    OSStatus status = SecItemCopyMatching((CFDictionaryRef)query, (CFTypeRef *)&identity);\r\n    if (status)\r\n        goto error;\r\n    \r\n    status = SecIdentityCopyCertificate(identity, &certificate);\r\n    if (status)\r\n        goto error;\r\n    \r\n    status = SecCertificateCopyPublicKey(certificate, &publicKey);\r\n    if (status)\r\n        goto error;\r\n    \r\n    status = SecIdentityCopyPrivateKey(identity, &privateKey);\r\n    if (status)\r\n        goto error;\r\n    \r\n    signature = CreateSignature(privateKey, plaintext, &error);\r\n    if (signature == NULL)\r\n        goto error;\r\n    NSLog(@\"Successfully signed, signature length: %lu\", CFDataGetLength(signature));\r\n    \r\n    verified = CreateVerificationResult(publicKey, plaintext, signature, &error);\r\n    if (verified == NULL)\r\n        goto error;\r\n    NSLog(@\"Verified signature with result: %@ (%@)\", verified, (verified == kCFBooleanTrue ? @\"OK\" : @\"FAIL\"));\r\n    \r\n    success = YES;\r\n    \r\nerror:\r\n    if (!success) {\r\n        NSLog(@\"An error happened.\");\r\n        NSLog(@\"status: %d\", (int)status);\r\n        if (error) {\r\n            CFShow(error);\r\n        }\r\n    }\r\n    CFRelease(plaintext);\r\n    CFRelease(query);\r\n    if (identity) CFRelease(identity);\r\n    if (certificate) CFRelease(certificate);\r\n    if (publicKey) CFRelease(publicKey);\r\n    if (privateKey) CFRelease(privateKey);\r\n    if (signature) CFRelease(signature);\r\n    if (verified) CFRelease(verified);\r\n    return (success ? 0 : 1);\r\n}"
    email: Karoly.Lorentey@gmail.com
    modified: "2011-12-12T14:52:11.721144Z"
    number: "10394759"
    number_intvalue: 10394759
    originated: 04-Nov-2011 02:21 AM
    parent_number: "10394846"
    product: Mac OS X
    product_version: 10.7.2 (11C73)
    reproducible: Always
    resolved: ""
    status: Duplicate/10394846
    title: 'SecTransform API: Sign transform silently produces bogus signatures'
