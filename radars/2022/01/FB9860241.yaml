apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB9860241
    labels:
        datastore_id: "5611356640247808"
data:
    classification: Incorrect/Unexpected Behavior
    created: "2022-01-27T10:20:59.075078Z"
    description: "Please describe the issue:\r\nWhen flatMap operator is used and failing publisher is returned from transform block, it never cancels upstream and blocks any cancelling efforts causing memory leak.\r\n\r\nPlease list the steps you took to reproduce the issue:\r\npublisher.flatMap { _ in\r\n    Fail(error: MyError.error)\r\n}\r\nThat's all but please find attached swift with example that can be executed\r\n\r\nWhat did you expect to happen?\r\nsubscription to publisher gets cancelled\r\nplease see example in attached file where I wrote draft of fixed flatMap by returning Result and then using tryMap outside the transform block\r\n\r\nWhat actually happened?\r\nsubscription to publisher is still active, calling cancel on stream cancellable has no effect, there is no way to cancel the subscription\r\n\r\nAttached file:\r\n\r\nCombineFlatMapIssue.swift\r\nhttps://gist.github.com/piotrtobolski/b6fa065194935f2d083e96375e3ca432\r\n\r\nimport Combine\r\n\r\nenum MyError: Error {\r\n    case error\r\n}\r\n\r\nlet subject1 = PassthroughSubject<Int, Error>()\r\n\r\nlet cancellable1 = subject1\r\n    .print(\"before flatMap\")\r\n    .flatMap { _ in\r\n        Fail<Int, Error>(error: MyError.error)\r\n    }\r\n    .print(\"after flatMap\")\r\n    .sink {\r\n        print(\"completion: \\($0)\")\r\n    } receiveValue: {\r\n        print(\"receiveValue: \\($0)\")\r\n    }\r\n\r\nprint(\"Sending 1\")\r\nsubject1.send(1)\r\nprint(\"Sending 2\")\r\nsubject1.send(2)\r\nprint(\"Cancelling\")\r\ncancellable1.cancel()\r\nprint(\"Sending 3\")\r\nsubject1.send(3)\r\n\r\nextension Publisher {\r\n    func flatMap2<T, P>(\r\n        maxPublishers: Subscribers.Demand = .unlimited,\r\n        _ transform: @escaping (Self.Output) -> P\r\n    ) -> AnyPublisher<T, Failure>\r\n    where T == P.Output, P : Publisher, Self.Failure == P.Failure {\r\n        flatMap(maxPublishers: maxPublishers) {\r\n            transform($0)\r\n                .map { value -> Result<T, Failure> in\r\n                    Result.success(value)\r\n                }\r\n                .catch {\r\n                    return Just<Result<T, Failure>>(Result.failure($0))\r\n                }\r\n        }\r\n        .tryMap { result in\r\n            switch result {\r\n            case let .success(value):\r\n                return value\r\n            case let .failure(error):\r\n                throw error\r\n            }\r\n        }\r\n        .mapError { error in\r\n            error as! Failure\r\n        }\r\n        .eraseToAnyPublisher()\r\n    }\r\n}\r\n\r\nprint(\"-----------------\")\r\n\r\nlet subject2 = PassthroughSubject<Int, Error>()\r\n\r\nlet cancellable2 = subject2\r\n    .print(\"before flatMap\")\r\n    .flatMap2 { _ in\r\n        Fail<Int, Error>(error: MyError.error)\r\n    }\r\n    .print(\"after flatMap\")\r\n    .sink {\r\n        print(\"completion: \\($0)\")\r\n    } receiveValue: {\r\n        print(\"receiveValue: \\($0)\")\r\n    }\r\n\r\nprint(\"Sending 1\")\r\nsubject2.send(1)\r\nprint(\"Sending 2\")\r\nsubject2.send(2)\r\nprint(\"Cancelling\")\r\ncancellable2.cancel()\r\nprint(\"Sending 3\")\r\nsubject2.send(3)\r\n\r\n/*\r\noutput:\r\nafter flatMap: receive subscription: (FlatMap)\r\nafter flatMap: request unlimited\r\nbefore flatMap: receive subscription: (PassthroughSubject)\r\nbefore flatMap: request unlimited\r\nSending 1\r\nbefore flatMap: receive value: (1)\r\nafter flatMap: receive error: (error)\r\ncompletion: failure(__lldb_expr_13.MyError.error)\r\nSending 2\r\nbefore flatMap: receive value: (2)\r\nCancelling\r\nSending 3\r\nbefore flatMap: receive value: (3)\r\n-----------------\r\nafter flatMap: receive subscription: (TryMap)\r\nafter flatMap: request unlimited\r\nbefore flatMap: receive subscription: (PassthroughSubject)\r\nbefore flatMap: request unlimited\r\nSending 1\r\nbefore flatMap: receive value: (1)\r\nbefore flatMap: receive cancel\r\nafter flatMap: receive error: (error)\r\ncompletion: failure(__lldb_expr_13.MyError.error)\r\nSending 2\r\nCancelling\r\nSending 3\r\n*/"
    email: slammer0@gmail.com
    modified: "2022-01-27T10:20:59.075224Z"
    number: FB9860241
    number_intvalue: 9860241
    originated: Jan 27, 2022 at 11:16 AM
    parent_number: '&{NULL_VALUE}'
    product: Something else not on this list
    product_version: ""
    reproducible: yes
    resolved: ""
    status: Open
    title: Combine.Publisher.flatMap memory leak when publisher fails
