apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB8914231
    labels:
        datastore_id: "5065277553246208"
data:
    classification: Application Crash
    created: "2020-11-23T17:44:16.994269Z"
    description: "If a Mach-O executable is created by writing the image contents to a mmaped region, the result incorrectly fails code signature verification in xnu and won’t run. This happens when “kill” semantics are enforced, which is the default on arm64.\r\n\r\nSteps to reproduce:\r\n\r\n1. Create a Mach-O executable by writing its image to an mmaped region. The attached test program, mmap_copy, can do this. In this example, it’s instructed to make a copy of itself in a new location, mmap_copy_copy.\r\n\r\nmark@arm-and-hammer zsh% clang++ -Wall -Werror t_mmap_copy.cc -o t_mmap_copy\r\nmark@arm-and-hammer zsh% ./mmap_copy mmap_copy mmap_copy_copy\r\n\r\n2. Attempt to run the executable.\r\n\r\nmark@arm-and-hammer zsh% ./mmap_copy_copy\r\n\r\nExpected behavior:\r\n\r\nThe executable should run.\r\n\r\nmark@arm-and-hammer zsh% ./mmap_copy_copy\r\nusage: ./mmap_copy_copy <source> <destination>\r\n\r\nObserved behavior:\r\n\r\nThe executable does not run. It’s killed by the kernel with a SIGKILL.\r\n\r\nmark@arm-and-hammer zsh% ./mmap_copy_copy\r\nzsh: killed     ./mmap_copy_copy\r\n\r\nObserving the system log during the above test, these messages are visible:\r\n\r\nadmin@arm-and-hammer zsh% sudo log stream --predicate 'sender = \"kernel\"'\r\nFiltering the log data using \"sender == \"kernel\"\"\r\nTimestamp                       Thread     Type        Activity             PID    TTL  \r\n2020-11-23 11:23:29.167443-0500 0x1a601    Default     0x0                  0      0    kernel: CODE SIGNING: cs_invalid_page(0x100250000): p=2369[mmap_copy_copy] final status 0x23020200, denying page sending SIGKILL\r\n2020-11-23 11:23:29.167471-0500 0x1a601    Default     0x0                  0      0    kernel: CODE SIGNING: process 2369[mmap_copy_copy]: rejecting invalid page at address 0x100250000 from offset 0x0 in file \"/Users/mark/mmap_copy_copy\" (cs_mtime:1606148606.175188953 == mtime:1606148606.175188953) (signed:1 validated:1 tainted:1 nx:0 wpmapped:1 dirty:0 depth:0)\r\n\r\nObserve equivalence between mmap_copy, which runs, and mmap_copy_copy, which does not:\r\n\r\nmark@arm-and-hammer zsh% shasum mmap_copy mmap_copy_copy\r\ne217641f45b8b2311e87276da79d81906bfa296e  mmap_copy\r\ne217641f45b8b2311e87276da79d81906bfa296e  mmap_copy_copy\r\n\r\nSystem information:\r\n\r\nmark@arm-and-hammer zsh% sw_vers\r\nProductName:\tmacOS\r\nProductVersion:\t11.0.1\r\nBuildVersion:\t20B29\r\nmark@arm-and-hammer zsh% xcodebuild -version\r\nXcode 12.2\r\nBuild version 12B45b\r\nmark@arm-and-hammer zsh% uname -m\r\narm64\r\nmark@arm-and-hammer zsh% system_profiler SPHardwareDataType | grep 'Model Identifier'\r\n      Model Identifier: ADP3,2\r\n\r\nThis occurs on shipping M1-based hardware as well.\r\n\r\nTo reproduce on x86_64, set the “kill” flag in the code signature.\r\n\r\nmark@sweet16 zsh% clang++ -Wall -Werror mmap_copy.cc -o mmap_copy\r\nmark@sweet16 zsh% codesign --sign=- --options=kill mmap_copy\r\nmark@sweet16 zsh% ./mmap_copy mmap_copy mmap_copy_copy\r\nmark@sweet16 zsh% shasum mmap_copy mmap_copy_copy\r\n9a2750b2ea900767bcfe4f7ae74597ebd33e0c6f  mmap_copy\r\n9a2750b2ea900767bcfe4f7ae74597ebd33e0c6f  mmap_copy_copy\r\nmark@sweet16 zsh% ./mmap_copy_copy\r\nzsh: killed     ./mmap_copy_copy\r\n\r\nmark@sweet16 zsh% shasum mmap_copy mmap_copy_copy\r\n58a3d23cb46d283e7a0c943e96244240646aab24  mmap_copy\r\n58a3d23cb46d283e7a0c943e96244240646aab24  mmap_copy_copy\r\n\r\nmark@sweet16 zsh% sw_vers\r\nProductName:\tMac OS X\r\nProductVersion:\t10.15.7\r\nBuildVersion:\t19H15\r\nmark@sweet16 zsh% xcodebuild -version\r\nXcode 12.2\r\nBuild version 12B45b\r\nmark@sweet16 zsh% uname -m\r\nx86_64\r\nmark@sweet16 zsh% system_profiler SPHardwareDataType | grep 'Model Identifier'\r\n      Model Identifier: MacBookPro16,1\r\n\r\nAdditional information:\r\n\r\nThe following workarounds are available:\r\n\r\n1. You can wait for your pages to leave the UBC. If you don’t want to wait, purge can help.\r\n2. You can put your file contents into a new vnode (via a new inode), as long as you write the file with something like write and not writing to an mmaped region. cp or equivalent is fine for this.\r\n3. My favorite: you can call msync(…, MS_INVALIDATE) on the mmaped region, asking xnu to throw away what it knows about the vnode. If you compile mmap_copy.cc with MMAP_COPY_MSYNC_INVALIDATE defined, it will do this. You can even use this technique to “save” a broken vnode from an entirely different process by opening the file,mmaping it, and then calling msync.\r\n\r\nld64 is the primary producer of Mach-O executables, and has traditionally written Mach-O output by writing to an mmaped region whenever possible, as mmap_copy does. The most current source available is Xcode 11.3.1 ld64-530/src/ld/OutputFile.cpp ld::tool::OutputFile::writeOutputFile demonstrates that. But that’s old, and the new truth is that in Xcode 12.2 ld64-609.7, only on arm64, ld64 uses the write approach (essentially workaround 2 above) in every case.\r\n\r\nThis bug was discovered during the course of updating the golang linker to support mac-arm64, tracked at https://github.com/golang/go/issues/42684."
    email: mark@chromium.org
    modified: "2020-11-24T01:32:17.608839Z"
    number: FB8914231
    number_intvalue: 8914231
    originated: "2020-11-23"
    parent_number: '&{NULL_VALUE}'
    product: macOS
    product_version: 11.0.1 20B29
    reproducible: Always
    resolved: ""
    status: Open
    title: '[Chrome] arm64: Writing a Mach-O executable via mmap produces something that incorrectly fails code signature verification and won’t run'
