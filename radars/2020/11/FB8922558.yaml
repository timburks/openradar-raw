apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB8922558
    labels:
        datastore_id: "5006130551980032"
data:
    classification: Application Crash
    created: "2020-11-30T17:04:24.334473Z"
    description: "When the kernel wants to invoke a user-space signal handler, it writes the signal handler’s stack frame and then sets the register state to jump to the signal handler. For arm64, this happens in xnu bsd/dev/arm/unix_signal.c sendsig. (x86_64 is bsd/dev/i386/unix_signal.c sendsig, which is similar.)\r\n\r\nI have discovered that, when a user-space signal handler is expected to be invoked, on arm64, sometimes an uncatchable SIGILL is sent to the process instead. The “bad:” label at the bottom of sendsig is the source of this SIGILL. Notably, it sets the disposition for SIGILL to SIG_DFL (the default action for this signal being to terminate the process), unblocks the signal, and sends it via psignal_locked. This results in process termination by uncatchable SIGILL, regardless of the signal originally being sent in sendsig.\r\n\r\nThis occurs whenever the copyout call in sendsig fails. The copyout call is responsible for writing the user-space signal handler’s stack frame. It should not be possible for copyout to fail in a well-behaved program where the stack frame is to be written to memory that is validly mapped in the target process. However, on arm64, if the copyout triggers a page fault, the copyout fails. The absent page should be paged in and used.\r\n\r\nThis bug reproduces at random and in the wild in Go (golang) executables. We are tracking this bug at https://github.com/golang/go/issues/42774. The Go runtime makes heavy use of SIGURG being sent cross-thread within a process. The design of Go’s use of SIGURG is discussed at https://go.googlesource.com/proposal/+/master/design/24543-non-cooperative-preemption.md.\r\n\r\nIn Go’s case, the user-space signal handler that uses sigaltstack and SA_ONSTACK to provide an alternate signal stack, but presumably the bug can occur even with the signal handler’s stack frame on the main thread stack, particularly if the signal handler’s stack frame would occupy space on a different page than the existing stack top. In the wild, the bug occurs most readily on a system under heavy load (particularly, memory pressure). Both “all.bash” and “go test io -run='^$' -bench=BenchmarkCopy -count=10” have been used to demonstrate the bug. In these cases, the bug reproduces spuriously and at random.\r\n\r\nGo’s runtime also has a user-space signal handler for SIGILL, which is not invoked when this bug occurs.\r\n\r\nIn order to provide a more concrete reproduction, I’ve distilled the basic operations into a pair of C++ test programs, a “simple” version that experience shows reproduces at 100%, and a more complete version that simulates Go’s use of SIGURG. For these tests, I’ve allocated the sigaltstack stack_t region using a file-backed mmap, as pages allocated in this way are least likely to be present, can be removed from the unified buffer cache for testing easily by running purge, and thus most likely to reproduce the bug. Note, however, that when the bug was discovered, it was with memory regions allocated with MAP_ANONYMOUS and not file-backed.\r\n\r\nSteps to reproduce (t_fault_sigaltstack_simple):\r\n\r\nmark@arm-and-hammer zsh% clang++ -Wall -Werror -g t_fault_sigaltstack_simple.cc -o t_fault_sigaltstack_simple\r\nmark@arm-and-hammer zsh% ./t_fault_sigaltstack_simple; echo $?\r\n\r\nExpected behavior:\r\n\r\nmark@arm-and-hammer zsh% ./t_fault_sigaltstack_simple; echo $?\r\n0\r\n\r\nObserved behavior:\r\n\r\nmark@arm-and-hammer zsh% ./t_fault_sigaltstack_simple; echo $?\r\nzsh: illegal hardware instruction  ./t_fault_sigaltstack_simple\r\n132\r\n\r\nSteps to reproduce (t_fault_sigaltstack):\r\n\r\nmark@arm-and-hammer zsh% clang++ -Wall -Werror -std=c++11 -g t_fault_sigaltstack.cc -o t_fault_sigaltstack\r\nmark@arm-and-hammer zsh% ./t_fault_sigaltstack -n 8 -t 60; echo $?\r\n\r\nNOTE: If the bug doesn’t reproduce quickly, encourage the memory used for the threads’ alternate signal stacks to be paged out by running “purge”, possibly in a loop. From another shell:\r\n\r\nadmin@arm-and-hammer zsh% while true; do sudo purge; done\r\n\r\nExpected behavior:\r\n\r\nmark@arm-and-hammer zsh% ./t_fault_sigaltstack -n 8 -t 60; echo $?\r\n[…wait -t seconds…]\r\n0\r\n\r\nObserved behavior:\r\n\r\nmark@arm-and-hammer zsh% ./t_fault_sigaltstack -n 8 -t 60; echo $?\r\n[…wait up to -t seconds, possibly use purge as described above…]\r\nzsh: illegal hardware instruction  ./t_fault_sigaltstack -n 8 -t 60\r\n132\r\n\r\nSystem information:\r\n\r\nmark@arm-and-hammer zsh% sw_vers\r\nProductName:\tmacOS\r\nProductVersion:\t11.0.1\r\nBuildVersion:\t20B29\r\nmark@arm-and-hammer zsh% xcodebuild -version\r\nXcode 12.2\r\nBuild version 12B45b\r\nmark@arm-and-hammer zsh% uname -m\r\narm64\r\nmark@arm-and-hammer zsh% system_profiler SPHardwareDataType | grep 'Model Identifier'\r\n      Model Identifier: ADP3,2\r\n\r\nThis occurs on shipping M1-based hardware as well.\r\n\r\nThis does not occur on x86_64 (tested 10.15.7 19H15 and 11.0.1 20B29), and does not occur when running x86_64 code on arm64 under Rosetta translation (tested 11.0.1 20B29).\r\n\r\nAdditional information:\r\n\r\nAs a workaround, it is possible to mlock the page that the kernel will write the user-space signal handler’s stack frame to. This page can generally be known when using sigaltstack and SA_ONSTACK, as it’s the top page in the stack_t region. This workaround is not complete because there are still circumstances under which a signal handler may run on the thread’s main stack, even with an alternate signal stack configured, and the page used for a signal handler’s stack frame on a thread’s main stack cannot generally be known ahead of time. The workaround is undesirable as well, because it requires wired memory of at least one page (16kB on arm64) for each thread.\r\n\r\nWhen this bug occurs, crash reports written by ReportCrash contain some characteristics that identify this bug, or at the very least, identify that the SIGILL did not originate from a genuine hardware trap.\r\n\r\nmark@arm-and-hammer zsh% cat Library/Logs/DiagnosticReports/t_fault_sigaltstack_simple_2020-11-30-*_arm-and-hammer.crash\r\nProcess:               t_fault_sigaltstack_simple [1285]\r\n[…]\r\nCode Type:             ARM-64 (Native)\r\n[…]\r\nCrashed Thread:        0  Dispatch queue: com.apple.main-thread\r\n\r\nException Type:        EXC_CRASH (SIGILL)\r\nException Codes:       0x0000000000000000, 0x0000000000000000\r\nException Note:        EXC_CORPSE_NOTIFY\r\n\r\nTermination Signal:    Illegal instruction: 4\r\nTermination Reason:    Namespace SIGNAL, Code 0x4\r\nTerminating Process:   t_fault_sigaltstack_simple [1285]\r\n\r\nApplication Specific Information:\r\ndyld2 mode\r\n[…]\r\n\r\nIn contrast to a genuine SIGILL:\r\n - In this case, “Exception Type” indicates EXC_CRASH (SIGILL). With a genuine illegal instruction, it will be EXC_BAD_ACCESS (SIGILL).\r\n - In this case, the “Exception Codes” are always both zero. With a genuine illegal instruction, codes[0] is never 0, and is nearly always EXC_ARM_UNDEFINED, represented numerically as 1. codes[1] will be the faulting instruction (which may be 0, as this is in fact an illegal instruction on arm64).\r\n - In this case, “Terminating Process” indicates that the signal was sent by the process itself (in actuality, it was sent by the kernel on behalf of the process). With a genuine illegal instruction, this field would show “exc handler [1285]”, indicating that the Mach exception handler server in the kernel, operating on behalf of the process, generated the signal.\r\n\r\nThese conditions exist in crash reports for t_fault_sigaltstack too. In that case, the crash report may blame either the thread that sent the signal or the thread that was to receive the signal as the crash thread.\r\n\r\nmark@arm-and-hammer zsh% cat Library/Logs/DiagnosticReports/t_fault_sigaltstack_2020-11-30-*_arm-and-hammer.crash\r\n[…]\r\nCrashed Thread:        0  Dispatch queue: com.apple.main-thread\r\n[…]\r\nThread 0 Crashed:: Dispatch queue: com.apple.main-thread\r\n0   libsystem_kernel.dylib              0x0000000191e4fcec __pthread_kill + 8\r\n1   libsystem_pthread.dylib             0x0000000191e80c24 pthread_kill + 292\r\n2   t_fault_sigaltstack                 0x0000000102b311a4 main + 816 (t_fault_sigaltstack.cc:268)\r\n3   libdyld.dylib                       0x0000000191e9cf54 start + 4\r\n[…]\r\n\r\nmark@arm-and-hammer zsh% cat Library/Logs/DiagnosticReports/t_fault_sigaltstack_2020-11-30-*_arm-and-hammer.crash\r\n[…]\r\nCrashed Thread:        1\r\n[…]\r\nThread 0:: Dispatch queue: com.apple.main-thread\r\n0   libsystem_kernel.dylib              0x000000018298bcec __pthread_kill + 8\r\n1   libsystem_pthread.dylib             0x00000001829bcc24 pthread_kill + 292\r\n2   t_fault_sigaltstack                 0x00000001003b91a4 main + 816 (t_fault_sigaltstack.cc:268)\r\n3   libdyld.dylib                       0x00000001829d8f54 start + 4\r\n\r\nThread 1 Crashed:\r\n0   libsystem_kernel.dylib              0x0000000182983d24 semaphore_wait_trap + 8\r\n1   libdispatch.dylib                   0x0000000182810988 _dispatch_sema4_wait + 28\r\n2   libdispatch.dylib                   0x0000000182811050 _dispatch_semaphore_wait_slow + 132\r\n3   t_fault_sigaltstack                 0x00000001003b9844 (anonymous namespace)::Semaphore::Wait() + 32 (t_fault_sigaltstack.cc:62)\r\n4   t_fault_sigaltstack                 0x00000001003b9744 (anonymous namespace)::ThreadMain(void*) + 540 (t_fault_sigaltstack.cc:154)\r\n5   libsystem_pthread.dylib             0x00000001829bd06c _pthread_start + 320\r\n6   libsystem_pthread.dylib             0x00000001829b7da0 thread_start + 8\r\n[…]\r\n\r\nThis bug was discovered during the course of updating golang to run on mac-arm64, tracked at https://github.com/golang/go/issues/42774"
    email: mark@chromium.org
    modified: "2020-11-30T17:04:24.334656Z"
    number: FB8922558
    number_intvalue: 8922558
    originated: "2020-11-30"
    parent_number: '&{NULL_VALUE}'
    product: macOS
    product_version: 11.0.1 20B29
    reproducible: Always
    resolved: ""
    status: Open
    title: '[Chrome] arm64: uncatchable spurious SIGILL received when a page fault occurs while calling a signal handler for any signal'
