apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB8914243
    labels:
        datastore_id: "4976424746221568"
data:
    classification: Application Crash
    created: "2020-11-23T17:45:48.098286Z"
    description: "If a vnode contains a Mach-O executable, replacing the contents with a different Mach-O executable produces a file that incorrectly fails code signature verification in xnu and won’t run. This happens when “kill” semantics are enforced, which is the default on arm64.\r\n\r\nSimplified test case:\r\n\r\nmark@arm-and-hammer zsh% rm -f /tmp/test\r\nmark@arm-and-hammer zsh% cp /usr/bin/false /tmp/test; echo $?\r\nmark@arm-and-hammer zsh% /tmp/test\r\n1\r\nmark@arm-and-hammer zsh% cp /usr/bin/true /tmp/test; echo $?\r\nmark@arm-and-hammer zsh% /tmp/test\r\nzsh: killed     /tmp/test\r\n137\r\n\r\nDetailed test case:\r\n\r\n1. Create a Mach-O executable and make sure that xnu is aware of it and its code signature by running it. Note its inode number, modification timestamp, and code directory hash.\r\n\r\nIn this example, I’m using my own executables for “true” and “false” in place of the ones that ship in /usr/bin, because the kernel produces a more valuable log in this case. However, per the simplified test case above, the same behavior (minus the log messages) occurs when using the prebuilt /usr/bin/true and /usr/bin/false in place of the compiled /tmp/true and /tmp/false.\r\n\r\nmark@arm-and-hammer zsh% rm -f /tmp/test\r\nmark@arm-and-hammer zsh% clang -x c - -o /tmp/false <<< 'int main() { return 1; }'\r\nmark@arm-and-hammer zsh% cp /tmp/false /tmp/test\r\nmark@arm-and-hammer zsh% stat -f '%i %Fm' /tmp/test\r\n6951173 1606151966.467082817\r\nmark@arm-and-hammer zsh% codesign --display --verbose=5 /tmp/test 2>&1 | grep ^CDHash=\r\nCDHash=a66099928a3c71e1e76865b010bacd46b5c53358\r\nmark@arm-and-hammer zsh% /tmp/test; echo $?\r\n1\r\n\r\n2. Replace the contents of the file with a different executable. Verify that the inode has remained the same.\r\n\r\nmark@arm-and-hammer zsh% clang -x c - -o /tmp/true <<< 'int main() { return 0; }'\r\nmark@arm-and-hammer zsh% cp /tmp/true /tmp/test\r\nmark@arm-and-hammer zsh% stat -f '%i %Fm' /tmp/test\r\n6951173 1606152024.837585424\r\nmark@arm-and-hammer zsh% codesign --display --verbose=5 /tmp/test 2>&1 | grep ^CDHash=\r\nCDHash=485dec78a904ee3c8301d10037caebe65feec83d\r\nmark@arm-and-hammer zsh% /tmp/test; echo $?\r\n\r\nExpected behavior:\r\n\r\nThe executable should run.\r\n\r\nmark@arm-and-hammer zsh% /tmp/test; echo $?\r\n0\r\n\r\nObserved behavior:\r\n\r\nThe executable does not run. It’s killed by the kernel with a SIGKILL.\r\n\r\nmark@arm-and-hammer zsh% /tmp/test; echo $?\r\nzsh: killed     /tmp/test\r\n137\r\n\r\nObserving the system log during the above test, these messages are visible:\r\n\r\nadmin@arm-and-hammer zsh% sudo log stream --predicate 'sender = \"kernel\"'\r\nFiltering the log data using \"sender == \"kernel\"\"\r\nTimestamp                       Thread     Type        Activity             PID    TTL  \r\n2020-11-23 12:20:36.817603-0500 0x1077     Default     0x0                  0      0    kernel: ignoring detached code signature on 'test' with cdhash 'a66099928a3c71e1e76865b010bacd46b5c53358' because it is invalid, or not a simple adhoc signature.\r\n2020-11-23 12:20:36.825652-0500 0x1078     Default     0x0                  0      0    kernel: CODE SIGNING: process 398[test]: rejecting invalid page at address 0x104b44000 from offset 0x0 in file \"/private/tmp/test\" (cs_mtime:1606151966.467082817 != mtime:1606152024.837585424) (signed:1 validated:1 tainted:1 nx:0 wpmapped:0 dirty:0 depth:0)\r\n\r\nOf note:\r\n\r\na66099928a3c71e1e76865b010bacd46b5c53358 is the CDHash from /tmp/false and the original version of /tmp/test. It is not the CDHash of the version of /tmp/test that I was expecting to run the second time (485dec78a904ee3c8301d10037caebe65feec83d)\r\n\r\n1606151966.467082817 is the mtime of the original version of /tmp/test, but not the mtime of the version of /tmp/test that I was expecting to run the second time (1606152024.837585424).\r\n\r\nSystem information:\r\n\r\nmark@arm-and-hammer zsh% sw_vers\r\nProductName:\tmacOS\r\nProductVersion:\t11.0.1\r\nBuildVersion:\t20B29\r\nmark@arm-and-hammer zsh% xcodebuild -version\r\nXcode 12.2\r\nBuild version 12B45b\r\nmark@arm-and-hammer zsh% uname -m\r\narm64\r\nmark@arm-and-hammer zsh% system_profiler SPHardwareDataType | grep 'Model Identifier'\r\n      Model Identifier: ADP3,2\r\n\r\nThis occurs on shipping M1-based hardware as well.\r\n\r\nTo reproduce on x86_64, set the “kill” flag in the code signature.\r\n\r\nmark@sweet16 zsh% rm -f /tmp/test\r\nmark@sweet16 zsh% clang -x c - -o /tmp/false <<< 'int main() { return 1; }'\r\nmark@sweet16 zsh% codesign --sign=- --options=kill /tmp/false\r\nmark@sweet16 zsh% cp /tmp/false /tmp/test\r\nmark@sweet16 zsh% /tmp/test; echo $?                                      \r\n1\r\nmark@sweet16 zsh% clang -x c - -o /tmp/true <<< 'int main() { return 0; }'\r\nmark@sweet16 zsh% codesign --sign=- --options=kill /tmp/true              \r\nmark@sweet16 zsh% cp /tmp/true /tmp/test\r\nmark@sweet16 zsh% /tmp/test; echo $?                        \r\nzsh: killed     /tmp/test\r\n137\r\n\r\nmark@sweet16 zsh% sw_vers\r\nProductName:\tMac OS X\r\nProductVersion:\t10.15.7\r\nBuildVersion:\t19H15\r\nmark@sweet16 zsh% xcodebuild -version\r\nXcode 12.2\r\nBuild version 12B45b\r\nmark@sweet16 zsh% uname -m\r\nx86_64\r\nmark@sweet16 zsh% system_profiler SPHardwareDataType | grep 'Model Identifier'\r\n      Model Identifier: MacBookPro16,1\r\n\r\nAdditional information:\r\n\r\nFeedback FB8914231 is related. Unlike in that report, purge and msync(…, MS_INVALIDATE) are not viable workarounds here.\r\n\r\nThis bug was discovered during the course of building and testing open-source llvm/clang on mac-arm64, tracked at https://bugs.llvm.org/show_bug.cgi?id=46644#c7."
    email: mark@chromium.org
    modified: "2020-11-23T17:46:05.221978Z"
    number: FB8914243
    number_intvalue: 8914243
    originated: "2020-11-23"
    parent_number: '&{NULL_VALUE}'
    product: macOS
    product_version: 11.0.1 20B29
    reproducible: Always
    resolved: ""
    status: Open
    title: '[Chrome] arm64: Copying a new Mach-O executable to an inode that previously contained a different Mach-O executable produces something that incorrectly fails code signature verification and won’t run'
