apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB7620133
    labels:
        datastore_id: "5059066896318464"
data:
    classification: Crash
    created: "2020-03-09T16:38:36.315005Z"
    description: "Before iOS 13, `AVAudioPlayer` declares its delegate as `assign`. With iOS 13 and later, `AVAudioPlayer` declares its delegate as `weak`, but still internally accesses the delegate directly via a raw pointer instead of using `objc_loadWeak()`.\r\n\r\nThis causes a crash when `AVAudioPlayer` invokes a method on the delegate which internally releases the last reference to the delegate (e.g. invalidating `CADisplayLink` or `NSTimer`).\r\n\r\nNote: Disconnecting the delegate in `-dealloc` doesn't work around this bug, since we're already in a delegate method by the time `-dealloc` is called.\r\n\r\nThis reproduces on iOS 13.3 as well as macOS 10.15.3.\r\n\r\nRepro: Compile and run the attached file `AVAudioPlayerCrash.m` for macOS or iOS with `NSZombieEnabled=YES` set in the environment:\r\n\r\n```\r\n% clang -fobjc-arc -fobjc-abi-version=2 -framework Foundation -framework AVFoundation -ObjC -o AVAudioPlayerCrash AVAudioPlayerCrash.m\r\n% NSZombieEnabled=YES ./AVAudioPlayerCrash\r\n2020-03-09 10:22:18.531 AVAudioPlayerCrash[5121:6485407] Created audio player <AudioPlayerBug: 0x7fbbc2e02da0>\r\n2020-03-09 10:22:18.531 AVAudioPlayerCrash[5121:6485407] Starting timer\r\n2020-03-09 10:22:18.531 AVAudioPlayerCrash[5121:6485407] Playing audio\r\n2020-03-09 10:22:18.753 AVAudioPlayerCrash[5121:6485407] Audio player did finish playing, successfully: 1\r\n2020-03-09 10:22:18.753 AVAudioPlayerCrash[5121:6485407] Invalidating timer\r\n2020-03-09 10:22:18.753 AVAudioPlayerCrash[5121:6485407] Deallocating audio player <AudioPlayerBug: 0x7fbbc2e02da0>\r\n2020-03-09 10:22:18.753 AVAudioPlayerCrash[5121:6485407] Finished invalidating timer (we will crash now if self was deallocated)\r\n2020-03-09 10:22:18.753 AVAudioPlayerCrash[5121:6485407] *** -[AudioPlayerBug class]: message sent to deallocated instance 0x7fbbc2e02da0\r\n[1]    5121 illegal hardware instruction  NSZombieEnabled=YES ./AVAudioPlayerCrash\r\n```\r\n\r\nExpected Behavior:\r\n\r\nApp should not crash when `AVAudioPlayer` invokes a delegate method which releases the last reference to the delegate.\r\n\r\nActual Behavior:\r\n\r\nApp crashes 100% when `AVAudioPlayer` invokes a delegate method which releases the last reference to the delegate.\r\n\r\nRoot cause:\r\n\r\nBecause `AVAudioPlayer`'s delegate is accessed directly via an ivar instead of via `objc_loadWeak()`, ARC does not retain a reference to the delegate for the duration of the delegate method. If that delegate method touches `self` after it's been deallocated, it will crash with `SIGSEGV`.\r\n\r\nProposed fix:\r\n\r\n`AVAudioPlayer` should access its delegate using `objc_loadWeak()` or a similar explicit strong reference.\r\n\r\nIn addition, `-[AVAudioPlayer setDelegate:]` should use `objc_storeWeak()` to store the delegate instead of copying a raw pointer.\r\n\r\nWorkaround:\r\n\r\nUse `NS_VALID_UNTIL_END_OF_SCOPE` from within the delegate method before invalidating any timers or display links which might release the last reference to `self`:\r\n\r\n```\r\n- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)audioPlayer successfully:(BOOL)flag {\r\n  NS_VALID_UNTIL_END_OF_SCOPE __typeof__(self) strongSelf = self;\r\n  // snip\r\n}\r\n```\r\n\r\nAlternately, do not reference `self` in an `AVAudioPlayerDelegate` method after any point which might release the last reference to `self` (e.g. invalidating `NSTimer` or `CADisplayLink`).\r\n\r\n% cat AVAudioPlayer.m\r\n\r\n#import <Foundation/Foundation.h>\r\n#import <AVFoundation/AVFoundation.h>\r\n\r\n// Sample MP3 data, Base64 encoded.\r\nNSString *const kMP3DataBase64 =\r\n    @\"/+MYxAAAAANIAAAAAExBTUUzLjk4LjIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\r\n    @\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\r\n\r\n@interface AudioPlayerBug : NSObject <AVAudioPlayerDelegate> {\r\n  AVAudioPlayer *_audioPlayer;\r\n  NSTimer *_timer;\r\n}\r\n\r\n- (void)play;\r\n\r\n@end\r\n\r\n@implementation AudioPlayerBug\r\n\r\n- (instancetype)init {\r\n  self = [super init];\r\n  if (self) {\r\n    NSData *audioData = [[NSData alloc] initWithBase64EncodedString:kMP3DataBase64 options:0];\r\n    NSAssert(audioData != nil, @\"Audio data must be valid\");\r\n    NSError *error = nil;\r\n    _audioPlayer = [[AVAudioPlayer alloc] initWithData:audioData\r\n                                          fileTypeHint:@\"public.mp3\"\r\n                                                 error:&error];\r\n    NSAssert(_audioPlayer != nil, @\"Audio player must be valid\");\r\n    NSAssert(error == nil, @\"Got error: %@\", error);\r\n    _audioPlayer.delegate = self;\r\n  }\r\n  NSLog(@\"Created audio player %@\", self);\r\n  return self;\r\n}\r\n\r\n- (void)dealloc {\r\n  NSLog(@\"Deallocating audio player %@\", self);\r\n\r\n  // Before iOS 13, the delegate is declared `assign`, so we must manually disconnect the delegate\r\n  // in `-dealloc` to ensure `AVAudioPlayer` doesn't access this object after `self` is deallocated.\r\n  //\r\n  // For iOS 13 and later, this should not be necessary, since the delegate is declared `weak`.\r\n  // However, even in iOS 13, `AVAudioPlayer` incorrectly accesses the delegate via a raw pointer\r\n  // instead of using `objc_loadWeak()`.  That means we might get here while we're in the middle of\r\n  // a delegate method, at which point it's too late to disconnect the delegate.\r\n  _audioPlayer.delegate = nil;\r\n}\r\n\r\n- (void)play {\r\n  NSLog(@\"Starting timer\");\r\n  _timer = [NSTimer scheduledTimerWithTimeInterval:1\r\n                                            target:self\r\n                                          selector:@selector(onTimer:)\r\n                                          userInfo:nil\r\n                                           repeats:NO];\r\n  NSLog(@\"Playing audio\");\r\n  [_audioPlayer play];\r\n}\r\n\r\n- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)successfully {\r\n\r\n  NSLog(@\"Audio player did finish playing, successfully: %d\", successfully);\r\n\r\n  // BUG: This releases the last reference to `self`.\r\n  //\r\n  // Root cause: `AVAudioPlayer` does not use `objc_loadWeak()` to load the reference to its\r\n  // delegate, but instead accesses it via a raw pointer, which means ARC does not hold a\r\n  // reference to the delegate for the lifetime of this method.\r\n  NSAssert(_audioPlayer != nil, @\"Audio player must not be deallocated\");\r\n\r\n  NSLog(@\"Invalidating timer\");\r\n  [_timer invalidate];\r\n  NSLog(@\"Finished invalidating timer (we will crash now if self was deallocated)\");\r\n\r\n  // This assertion check will fail if ARC has just deallocated self.\r\n  NSAssert(_audioPlayer != nil, @\"Audio player must not be deallocated (self=%@)\", self);\r\n}\r\n\r\n- (void)onTimer:(NSTimer *)timer {\r\n  NSLog(@\"Timer fired\");\r\n}\r\n\r\n@end\r\n\r\nint main(int argc, char **argv) {\r\n  @autoreleasepool {\r\n    __attribute((objc_precise_lifetime)) AudioPlayerBug *bug = [[AudioPlayerBug alloc] init];\r\n    [bug play];\r\n  }\r\n  [NSRunLoop.mainRunLoop run];\r\n  return 0;\r\n}"
    email: foxden@gmail.com
    modified: "2020-03-09T18:34:22.037056Z"
    number: FB7620133
    number_intvalue: 7620133
    originated: "2020-03-09"
    parent_number: '&{NULL_VALUE}'
    product: AVFoundation
    product_version: iOS 13.3
    reproducible: 100%
    resolved: ""
    status: Open
    title: '[iOS 13] 100% repro crash in AVAudioPlayer'
