apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB8707529
    labels:
        datastore_id: "5039961103400960"
data:
    classification: Incorrect/Unexpected Behavior
    created: "2020-09-20T04:34:27.522538Z"
    description: "SIGBUS, SIGFPE, SIGILL, and SIGSEGV are distinguished from other signals in that they arise synchronously as a result of sustaining a hardware trap. In xnu, the hardware traps give rise to Mach exceptions which, if handled by the default in-kernel handler, are delivered to the faulting process as a POSIX signal (10.15.6 xnu-6153.141.1/bsd/uxkern/ux_exception.c handle_ux_exception()). A signal handler responding to one of these signals has the opportunity to handle the fault. If unhandled, the signal will recur when the signal handler returns. Should the signal handler uninstall itself (restoring SIG_DFL) and return, the recurring signal will be treated according to the system’s default disposition, which for these signals is termination with an optional core dump (SA_KILL | SA_CORE, 10.15.6 xnu-6153.141.1/bsd/sys/signalvar.h sigprop[]).\r\n\r\nBecause they are part of the signal interface, it is also possible for these four signals, normally delivered synchronously as described above, to occur asynchronously, being sent from software by the kill() system call, the raise() library function, or the kill command. When triggered in this way, these signals will be delivered to a signal handler, but they will not recur autonomously when the signal handler returns, because no hardware fault exists that would cause them to re-raise. As such, a signal handler that wants to perform its own action, uninstall itself, and have the default termination action occur, will need to explicitly re-raise the signal from within the signal handler.\r\n\r\nSignal handlers need to be able to distinguish between these hardware-based signals occurring naturally and synchronously from hardware traps and those generated asynchronously from software. Only true hardware traps should be the target of user-space fault handling from the signal handler. Autonomous re-raise is also available for hardware trap-based signals, but not for others.\r\n\r\nA re-raised signal with the default disposition guarantees the desired termination, but if applied to hardware faults, results information loss, as the underlying cause of the hardware fault is no longer available via the EXC_CORPSE_NOTIFY and EXC_CRASH interfaces used by crash reporters such as Apple’s own ReportCrash and Chrome’s Crashpad. This is undesirable as it obscures the true cause of the crash. A well-designed signal handler will observe the attributes of a signal to determine whether it will re-raise autonomously or if an explicit software re-raise is necessary. Therefore, for this purpose as well, it is important for the signal handler to be able to distinguish between signals arising from hardware faults that will re-raise autonomously, and those arising asynchronously from software that will not and that must be re-raised manually.\r\n\r\nOrdinarily, it’s possible to use the siginfo::si_code field to distinguish between signals that arose as hardware traps (and thus will be re-raised autonomously) and those that arose asynchronously from software (and will not). A well-behaved signal handler would consult this field to determine whether software re-raise is necessary and appropriate. In xnu, this does not function as intended: on x86_64, SIGBUS always appears to a signal handler as a hardware trap even when originating asynchronously in software. On x86_64, SIGSEGV arising out of a hardware #GP trap (general protection fault) will appear to the signal handler as though it was generated asynchronously in software. Regardless of the actual source of the signal, SIGTRAP on x86_64 always appears as if it originated synchronously in hardware\r\n\r\nQuoting POSIX.1-2008, 2018 Edition, XRAT “Rationale”/B.2.4 “Signal Concepts”/“Signal Actions”:\r\n\r\n> Historically, an si_code value of less than or equal to zero indicated that\r\n> the signal was generated by a process via the kill() function, and values of\r\n> si_code that provided additional information for implementation-generated\r\n> signals, such as SIGFPE or SIGSEGV, were all positive.\r\n\r\nFor SIGBUS on all architectures, si_code is always nonzero, even when generated by kill().\r\n\r\n> XSI applications should check whether si_code is SI_USER or SI_QUEUE in\r\n> addition to checking whether it is less than or equal to zero.\r\n\r\nNote that xnu currently defines but never uses the SI_* constants such as SI_USER and SI_QUEUE. I don’t consider it important for xnu to adopt SI_USER, provided that it correctly implements what POSIX calls the “historical” behavior of setting si_code to 0 for signals generated asynchronously in software and to a positive value for signals generated from hardware traps.\r\n\r\nI’m attaching a test program, t_signals.cc, that demonstrates the problem. Compilation and usage:\r\n\r\nmark@sweet16 zsh% clang++ -std=c++17 -g -Wall -Werror t_signals.cc -o t_signals\r\nmark@sweet16 zsh% ./t_signals\r\nusage: t_signals <handle> <trigger> <signal>\r\n  handle: catch,\r\n          nocatch\r\n  trigger: cause,\r\n           cause/nocatch,\r\n           raise\r\n  signal: abrt,\r\n          alrm,\r\n          bus,\r\n          fpe,\r\n          ill,\r\n          pipe,\r\n          segv,\r\n          segv/gp,\r\n          sys,\r\n          trap\r\n\r\n“handle” determines whether the program installs its own signal handlers in-process or simply leaves all signals at their default (SIG_DFL) dispositions. “trigger” determines whether the signal arises naturally due to some fault (“cause”), or via the raise() library function (which internally uses the kill() system call). “signal” specifies the signal to cause or raise. A bit of explanation on “segv/gp”: with trigger set to “cause”, it causes SIGSEGV to be raised by triggering a #GP trap (general protection fault), to exhibit the subtly different handling afforded to such traps compared to other causes of SIGSEGV. “segv” without the “/gp” achieves the signal in “cause” mode via an ordinary null pointer dereference.\r\n\r\nFor the signals that can arise from hardware traps, SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGTRAP, the program arranges to generate a true trap, and xnu’s full fault handling path comes into play in order to deliver a signal to the process. (A note on SIGTRAP: although originating from a hardware fault, it’s intended for use as a software trap, and the program counter advances to the next instruction before the fault occurs, so it will not re-raise autonomously, in contrast to the other, harder, hardware faults.)\r\n\r\nThe expected behavior is for a signal handler to execute in the program, and for the program to subsequently exit with the proper status reported via waitpid. For example:\r\n\r\nmark@sweet16 zsh% PS1='%n@%m %? zsh%# '\r\nmark@sweet16 0 zsh% ./t_signals catch cause bus\r\nexpect_signal = 10\r\nsignal = 10 (Bus error: 10)\r\ncode = 2 (genuine)\r\npid = 0, uid = 0\r\nreraise_autonomously = 1\r\nzsh: bus error  ./t_signals catch cause bus\r\nmark@sweet16 138 zsh%\r\n\r\nThis is fine. The signal handler detected that the signal originated from a hardware trap (code = 2 (genuine)), would re-raise autonomously (reraise_autonomously = 1), and the signal did in fact recur on its own. SIGBUS was visible to the parent, zsh, via waitpid. I have placed %? in PS1 so that the exit status is visible, here, 138. (138 & 0x7f = 10 = SIGBUS). However, a SIGBUS generated via the kill() system call is not handled correctly:\r\n\r\nmark@sweet16 0 zsh% ./t_signals catch raise bus\r\nexpect_signal = 10\r\nsignal = 10 (Bus error: 10)\r\ncode = 2 (genuine)\r\npid = 0, uid = 0\r\nreraise_autonomously = 1\r\nt_signals: unexpected successful exit\r\nmark@sweet16 0 zsh%\r\n\r\nIn this case, raise_autonomously was incorrectly detected as 1 because xnu set sigaction::si_code to a positive value, BUS_ADRERR. This happens unconditionally when delivering SIGBUS in 10.15.6 xnu-6153.141.1/bsd/dev/i386/unix_signal.c sendsig(). As a result, the signal handler did not attempt to re-raise the signal manually, and the signal, having originated asynchronously in software, did not recur following the signal handler’s return. The program proceeded to complete executing in main(), exiting with status 0.\r\n\r\nA related problem occurs on x86_64 for SIGSEGV when originating from a #GP trap (general protection fault). In 10.15.6 xnu-6153.141.1/bsd/dev/i386/unix_signal.c sendsig, handling EXC_I386_GPFLT, si_code is cleared, making the signal appear asynchronous, when it is obviously not. A new si_code value in the SEGV_ namespace should be introduced to properly convey that such signals originate asynchronously in software. This can be diagnosed by running t_signals on x86_64:\r\n\r\nmark@sweet16 0 zsh% ./t_signals catch cause segv/gp\r\nexpect_signal = 11\r\nsignal = 11 (Segmentation fault: 11)\r\ncode = 0 (software kill())\r\npid = 0, uid = 0\r\nreraise_autonomously = 0\r\nzsh: segmentation fault  ./t_signals catch cause segv/gp\r\nmark@sweet16 139 zsh%\r\n\r\nThis was detected as a software kill(). Although the signal was re-raised, the re-raise was manual and not autonomous, which has resulted in information loss to the crash reporter. Examining the report produced by ReportCrash in ~/Library/Logs/DiagnosticReports for this execution compared to a cause/nocatch version (no in-process signal handler, therefore no manual re-raise, just ordinary SIG_DFL handling the first time the signal appears) reveals differences.\r\n\r\nmark@sweet16 0 zsh% ./t_signals nocatch cause segv/gp\r\nzsh: segmentation fault  ./t_signals nocatch cause segv/gp\r\nmark@sweet16 139 zsh% diff -u ~/Library/Logs/DiagnosticReports/t_signals_2020-09-17-1832{00,59}_sweet16.crash\r\n[…filtered to present only salient differences…]\r\n+Termination Signal:    Segmentation fault: 11\r\n+Termination Reason:    Namespace SIGNAL, Code 0xb\r\n+Terminating Process:   exc handler [35165]\r\n[…]\r\n-Error Code:      0x020000b8\r\n-Trap Number:     133\r\n+Error Code:      0x00000000\r\n+Trap Number:     13\r\n[…]\r\n\r\nBecause the SIGSEGV was incorrectly detected as originating asynchronously from software, (1) the signal handler, if being used as a user-space fault handler, would not have attempted to recover from the fault condition, even though one existed, and (2) it performed manual re-raise, even though the signal would have re-raised autonomously. As a result of the manual re-raise, ReportCrash did not output the “Termination” section further identifying the cause of the crash, and the trap number is presented as 133 (T_SYSCALL) instead of 13 (T_GENERAL_PROTECTION).\r\n\r\nSIGTRAP handling is also incorrect on x86_64. Recalling that SIGTRAP never recurs autonomously, the “code =” (from siginfo::si_code) printed by the test program’s signal handler must be inspected. On x86_64, si_code always appears as 1 (TRAP_BKPT) indicating that a #BP (breakpoint) trap was sustained, such as via the int3 instruction, even when the SIGTRAP was raised asynchronously in software.\r\n\r\nFinally, it’s not possible to distinguish between genuine SIGPIPE and SIGSYS originating in the kernel and those sent from user space by kill(). In all cases, si_code is reported as 0. SIGALRM shares the same problem, although it is presently possible to distinguish genuine SIGALRM as they set si_pid and si_uid.\r\n\r\nResolution:\r\n\r\nImprovements must be made to the sendsig() function in 10.15.6 xnu-6153.141.1/bsd/dev/i386/unix_signal.c (for x86_64).\r\n\r\nFor SIGBUS and SIGTRAP, sendsig() should consider ut->uu_code when setting sinfo64.si_code, setting it to 0 when signals did not arise from a hardware trap. For SIGSEGV, when ut->uu_code is EXC_I386_GPFLT, it should set sinfo64.si_code to a new nonzero positive constant in the SEGV_* domain, or make appropriate reuse of existing SEGV_* constants. In the SIGSEGV ut->uu_code “default” case, FPE_NOOP should be replaced with a literal 0 for clarity. FPE_NOOP, while having value 0, incorrectly conveys that this condition has something to do with SIGFPE, when it does not. (SEGV_NOOP is another alternative.)\r\n\r\nSimilar handling should be applied to the software signals SIGALRM, SIGPIPE, and SIGSYS, setting sinfo.si_code to a positive integer when raised for genuine intended purposes by the kernel, and to 0 when arising from a user space kill().\r\n\r\nOptionally, all cases that set si_code to 0 to indicate an asynchronous software source could be changed to use SI_USER per POSIX. However, maintaining the traditional value of 0 is not problematic.\r\n\r\nAlso optionally, the si_pid and si_uid fields can be populated unconditionally for signals raised asynchronously from software, such as by the kill() system call. This would aid in tracing the origin of such signals. Presently, si_pid and si_uid are inconsistently set.\r\n\r\nAdditional notes:\r\n\r\nI tested on macOS 11.0db6 20A5364e on x86_64, and on macOS 10.15.6 19G2021 on x86_64.\r\n\r\nThe test program is based on library and test code at https://chromium.googlesource.com/crashpad/crashpad/+/refs/heads/master/util/posix/signals.cc and https://chromium.googlesource.com/crashpad/crashpad/+/refs/heads/master/util/posix/signals_test.cc."
    email: mark@chromium.org
    modified: "2020-09-20T04:34:27.522702Z"
    number: FB8707529
    number_intvalue: 8707529
    originated: "2020-09-17"
    parent_number: '&{NULL_VALUE}'
    product: macOS
    product_version: ""
    reproducible: ""
    resolved: ""
    status: Open
    title: 'xnu: For some signals, it’s not possible to distinguish between hardware faults and asynchronous software triggers (kill() and raise()), frustrating user-space fault handling and proper re-raise'
