apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: FB8653320
    labels:
        datastore_id: "4947004086026240"
data:
    classification: ""
    created: "2020-09-08T16:45:35.027048Z"
    description: "I am using a UICollectionView with UICollectionViewDiffableDataSource and fetching data both asynchronously and synchronously to populate the view. The app crashes with this message: \"Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid parameter not satisfying: itemCount'.\"\r\n\r\nI believe it has something to do with the combination of sync and async data fetching, as when I implement one or the other the app runs as expected.\r\n\r\nWhen I set up the collection view layout group like so, it crashes:\r\nlet group = NSCollectionLayoutGroup.vertical(layoutSize: groupSize, subitems: [item])\r\n\r\nA workaround is to set up the collection view layout group like this instead, explicitly providing the count:\r\nlet group = NSCollectionLayoutGroup.vertical(layoutSize: groupSize, subitem: item, count: 1)\r\n\r\nSingle-view app view controller code to reproduce:\r\n\r\nimport UIKit\r\n\r\nstruct Model: Hashable {\r\n  let id: UUID\r\n}\r\n\r\nclass ViewController: UIViewController {\r\n  \r\n  private var collectionView: UICollectionView!\r\n  private var dataSource: DataSource?\r\n  private var asyncItems: [Model] = []\r\n  private var syncItems: [Model] = []\r\n  \r\n  typealias DataSource = UICollectionViewDiffableDataSource<Section, Model>\r\n  typealias Snapshot = NSDiffableDataSourceSnapshot<Section, Model>\r\n  \r\n  enum Section {\r\n    case async\r\n    case sync\r\n  }\r\n  \r\n  override func viewDidLoad() {\r\n    super.viewDidLoad()\r\n    \r\n    setUpCollectionView()\r\n    setUpDataSource()\r\n    \r\n    fetchData()\r\n  }\r\n  \r\n  func setUpCollectionView() {\r\n    let collectionView = UICollectionView(frame: view.bounds, collectionViewLayout: setUpCollectionViewLayout())\r\n    collectionView.translatesAutoresizingMaskIntoConstraints = false\r\n    view.addSubview(collectionView)\r\n    collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive = true\r\n    collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true\r\n    collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true\r\n    collectionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor).isActive = true\r\n    \r\n    collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: \"reuseIdentifier\")\r\n    \r\n    self.collectionView = collectionView\r\n  }\r\n  \r\n  func setUpCollectionViewLayout() -> UICollectionViewLayout {\r\n    return UICollectionViewCompositionalLayout { (sectionIndex: Int,\r\n      layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection? in\r\n      let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0), heightDimension: .fractionalWidth(1.0))\r\n      let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0), heightDimension: .absolute(100))\r\n      \r\n      let item = NSCollectionLayoutItem(layoutSize: itemSize)\r\n      \r\n      let group = NSCollectionLayoutGroup.vertical(layoutSize: groupSize, subitems: [item])\r\n      \r\n      return NSCollectionLayoutSection(group: group)\r\n    }\r\n  }\r\n  \r\n  func setUpDataSource() {\r\n    self.dataSource =  DataSource(collectionView: collectionView) { (collectionView, indexPath, model) -> UICollectionViewCell? in\r\n      let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"reuseIdentifier\", for: indexPath)\r\n      return cell\r\n    }\r\n  }\r\n  \r\n  func fetchData() {\r\n    let dispatchGroup = DispatchGroup()\r\n    \r\n    dispatchGroup.enter()\r\n    DispatchQueue.global(qos: .background).async { [weak self] in\r\n      defer {\r\n        dispatchGroup.leave()\r\n      }\r\n      self?.asyncItems = [Model(id: UUID())]\r\n    }\r\n    \r\n    syncItems = [Model(id: UUID())]\r\n    \r\n    dispatchGroup.notify(queue: .main) { [weak self] in\r\n      self?.applySnapshot()\r\n    }\r\n  }\r\n  \r\n  func applySnapshot() {\r\n    var snapshot = Snapshot()\r\n    snapshot.appendSections([Section.async])\r\n    snapshot.appendItems(asyncItems)\r\n    \r\n    snapshot.appendSections([Section.sync])\r\n    snapshot.appendItems(syncItems)\r\n    \r\n    dataSource?.apply(snapshot)\r\n  }\r\n}"
    email: rachelehyman@gmail.com
    modified: "2020-09-08T16:45:35.02722Z"
    number: FB8653320
    number_intvalue: 8653320
    originated: 9/8/20
    parent_number: '&{NULL_VALUE}'
    product: UIKit
    product_version: ""
    reproducible: ""
    resolved: ""
    status: Open
    title: 'UICollectionViewDiffableDataSource crash: Invalid parameter not satisfying: itemCount, when fetching data both asynchronously and synchronously'
