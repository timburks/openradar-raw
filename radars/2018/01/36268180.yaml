apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "36268180"
    labels:
        datastore_id: "6059025372282880"
data:
    classification: ""
    created: "2018-01-03T02:41:02.82759Z"
    description: "Area:\r\nTerminal\r\n\r\nSummary:\r\n`getattrlistbulk(2)` mistakenly returns `ERANGE` after fully iterating through a directory.  The final call should return zero, indicating that the directory stream has terminated, but it returns an error with `ERANGE` set in `errno`.\r\n\r\nSteps to Reproduce:\r\nRun the attached C program with 88 as its argument. \r\n\r\nTo summarize, create a directory with a single empty file named \"a\" underneath, and call `getattrlistbulk` on it with an `attrlist` containing `ATTR_BIT_MAP_COUNT`, `ATTR_CMN_NAME | ATTR_CMN_OBJTYPE | ATTR_CMN_OBJID | ATTR_CMN_MODTIME | ATTR_CMN_CHGTIME` and `ATTR_FILE_DATALENGTH`, a buffer of 88 bytes, and options set to zero.  The first call will return the metadata for \"a\", and the second call will return -1 with `errno` set to `ERANGE`.\r\n\r\nThis code (https://github.com/apple/darwin-xnu/blob/master/bsd/vfs/vfs_attrlist.c#L3879) looks error-prone; perhaps `eofflag` is not being set in this condition?\r\n\r\nExpected Results:\r\nThe second call should return zero, indicating the directory stream has finished.\r\n\r\nActual Results:\r\nThe second call returns -1, failing with `ERANGE`.\r\n\r\nVersion/Build:\r\n10.13 (17A365)\r\n\r\nConfiguration:\r\nOn an APFS filesystem\r\n\r\nAttached diriterbug.c:\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/stat.h>\r\n#include <sys/attr.h>\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n\r\nstruct _attrbufhdr {\r\n  u_int32_t length;\r\n  attribute_set_t returned;\r\n};\r\n\r\nint main(int argc, char** argv) {\r\n  if (argc != 2) {\r\n    fprintf(stderr, \"Usage: %s <bufsize>\\n\", argv[0]);\r\n    return 1;\r\n  }\r\n  int bufsize = (int) strtol(argv[1], NULL, 10);\r\n\r\n  if (mkdir(\"testdir\", 0777) != 0) {\r\n    perror(\"mkdir testdir failed\");\r\n    return 1;\r\n  }\r\n\r\n  int dirfd = open(\"testdir\", O_RDONLY);\r\n  if (dirfd < 0) {\r\n    perror(\"open testdir failed\");\r\n    return 1;\r\n  }\r\n\r\n  int fd = openat(dirfd, \"a\", O_CREAT);\r\n  if (fd < 0) {\r\n    perror(\"creating testdir/a failed\");\r\n    return 1;\r\n  }\r\n  if (close(fd) < 0) {\r\n    perror(\"closing testdir/a failed\");\r\n    return 1;\r\n  }\r\n\r\n  struct attrlist attrs_req;\r\n  memset(&attrs_req, 0, sizeof(attrs_req));\r\n  attrs_req.bitmapcount = ATTR_BIT_MAP_COUNT;\r\n  attrs_req.commonattr = (ATTR_CMN_RETURNED_ATTRS |\r\n                          ATTR_CMN_NAME |\r\n                          ATTR_CMN_OBJTYPE |\r\n                          ATTR_CMN_OBJID |\r\n                          ATTR_CMN_MODTIME |\r\n                          ATTR_CMN_CHGTIME);\r\n  attrs_req.fileattr = ATTR_FILE_DATALENGTH;\r\n\r\n  void* buf = malloc(bufsize);\r\n  if (buf == NULL) {\r\n    perror(\"malloc failed\");\r\n    return 1;\r\n  }\r\n\r\n  // Call `getattrlistbulk` for the first time to get our single entry.\r\n  int count = getattrlistbulk(dirfd, &attrs_req, buf, bufsize, 0);\r\n\r\n  if (count < 0) {\r\n    perror(\"first getattrlistbulk failed\");\r\n    return 1;\r\n  } else if (count != 1) {\r\n    fprintf(stderr, \"Expected one entry from first getattrlistbulk, received %d\\n\", count);\r\n    return 1;\r\n  }\r\n\r\n  // Parse out the returned attribute set.\r\n  char* cursor = (char*) buf;\r\n  struct _attrbufhdr* hdr = (struct _attrbufhdr*) cursor;\r\n  cursor += sizeof(struct _attrbufhdr);\r\n\r\n  // Parse out each attribute in order.\r\n  if (hdr->returned.commonattr & ATTR_CMN_NAME) {\r\n    attrreference_t *ref = (attrreference_t*) cursor;\r\n    cursor += sizeof(attrreference_t);\r\n    printf(\"  ATTR_CMN_NAME: %.*s\\n\", ref->attr_length, ((char*) ref) + ref->attr_dataoffset);\r\n  }\r\n  if (hdr->returned.commonattr & ATTR_CMN_OBJTYPE) {\r\n    fsobj_type_t *ref = (fsobj_type_t*) cursor;\r\n    cursor += sizeof(fsobj_type_t);\r\n    printf(\"  ATTR_CMN_OBJTYPE: %d\\n\", *ref);\r\n  }\r\n  if (hdr->returned.commonattr & ATTR_CMN_OBJID) {\r\n    fsobj_id_t *ref = (fsobj_id_t*) cursor;\r\n    cursor += sizeof(fsobj_id_t);\r\n    printf(\"  ATTR_CMN_OBJID: %d:%d\\n\", ref->fid_objno, ref->fid_generation);\r\n  }\r\n  if (hdr->returned.commonattr & ATTR_CMN_MODTIME) {\r\n    struct timespec *ref = (struct timespec*) cursor;\r\n    cursor += sizeof(struct timespec);\r\n    printf(\"  ATTR_CMN_MODTIME: %0.4f\\n\", ref->tv_sec + ((double) ref->tv_nsec) / 1e9);\r\n  }\r\n  if (hdr->returned.commonattr & ATTR_CMN_CHGTIME) {\r\n    struct timespec *ref = (struct timespec*) cursor;\r\n    cursor += sizeof(struct timespec);\r\n    printf(\"  ATTR_CMN_CHGTIME: %0.4f\\n\", ref->tv_sec + ((double) ref->tv_nsec) / 1e9);\r\n  }\r\n\r\n  // Zero out the buffer and try again.\r\n  memset(buf, 0, bufsize);\r\n  count = getattrlistbulk(dirfd, &attrs_req, buf, bufsize, 0);\r\n  if (count < 0) {\r\n    perror(\"second getattrlistbulk failed\");\r\n    return 1;\r\n  } else if (count != 0) {\r\n    fprintf(stderr, \"Expected EOF from second getattrlistbulk, received %d\\n\", count);\r\n    return 1;\r\n  }\r\n  printf(\"Success!\\n\");\r\n  return 0;\r\n}\r\n```"
    email: sujayakar@dropbox.com
    modified: "2018-01-03T02:41:02.82792Z"
    number: "36268180"
    number_intvalue: 36268180
    originated: 1/2/2018
    parent_number: '&{NULL_VALUE}'
    product: macOS + SDK
    product_version: "10.13"
    reproducible: Yes
    resolved: ""
    status: Open
    title: '`getattrlistbulk(2)` erroneously returns `ERANGE` on 10.13.'
