apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "14285519"
    labels:
        datastore_id: "5026746088816640"
data:
    classification: ""
    created: "2018-03-24T20:44:29.56797Z"
    description: "Summary:\r\n\r\nIt is important for accessibility tools to know the on-screen position of the text-insertion caret in the focused textfield.\r\n\r\nA tool for low visiiblity users could, for example, show a zoomed-in version of the word being typed. This helper window should appear next to the word; the position would be determined via the position of the text-insertion point.\r\n\r\nWhen text is selected (highlighted), it is easy to get the bounds of the entire selected area with the accessibilityAPI's `kAXBoundsForRangeParameterizedAttribute`. The caret position can then be determined from this bounding rectangle.\r\n\r\nHowever, when text is NOT selected, attempting to get the value of the `kAXBoundsForRangeParameterizedAttribute` attribute returns `kAXErrorNoValue`. Apple docs state this error code means \"The parameterized attribute is not supported by the AXUIElementRef\".\r\n\r\nGetting the value of this attribute, when no text is selected, should instead return the same bounding rectangle as  when text *is* selected. However the length of that rect should be 0 (or perhaps the tiny width of the caret itself). Accessibility tools would then be able to calculate the text-insertion caret position without first \"faking\" a selection.\r\n\r\nSteps to Reproduce:\r\n\r\nThe below code can be used to test a textfield.\r\n\r\nPut your text-insertion caret in a textfield. Then run the selectionRect method.\r\n\r\n    - (AXUIElementRef)focusedApp {\r\n        pid_t pid;\r\n        ProcessSerialNumber psn;\r\n        GetFrontProcess(&psn);\r\n        GetProcessPID(&psn, &pid);\r\n        AXUIElementRef focusedApp = AXUIElementCreateApplication(pid);\r\n        \r\n        return focusedApp;\r\n    }\r\n    \r\n    - (AXUIElementRef)focusedElement\r\n    {\r\n        AXUIElementRef focusedApp = [self focusedApp];\r\n        \r\n        AXUIElementRef focusedElement;\r\n        AXError focusedElementError = AXUIElementCopyAttributeValue(focusedApp, kAXFocusedUIElementAttribute, (CFTypeRef *)&focusedElement);\r\n        if (focusedElementError == kAXErrorSuccess) {\r\n            return focusedElement;\r\n        }\r\n        else {\r\n            return nil;\r\n        }\r\n    }\r\n    \r\n    - (CGRect)selectionRect\r\n    {\r\n        AXUIElementRef focusedElement = [self focusedElement];\r\n        \r\n        AXValueRef selectionRangeValue;\r\n        AXError selectionRangeError = AXUIElementCopyAttributeValue(focusedElement, kAXSelectedTextRangeAttribute, (CFTypeRef *)&selectionRangeValue);\r\n        if (selectionRangeError == kAXErrorSuccess)\r\n        {\r\n            CFRange selectionRange;\r\n            AXValueGetValue(selectionRangeValue, kAXValueCFRangeType, &selectionRange);\r\n            \r\n            //selectionRange.length is 0 for \"no selection\" (aka a bare caret insertion point)\r\n            NSLog(@\"Range: %lu, %lu\", selectionRange.length, selectionRange.location);\r\n            \r\n            AXValueRef selectionBoundsValue;\r\n            AXError selectionBoundsError = AXUIElementCopyParameterizedAttributeValue(focusedElement, kAXBoundsForRangeParameterizedAttribute, selectionRangeValue, (CFTypeRef *)&selectionBoundsValue);\r\n            \r\n            if (selectionRange.length == 0 && selectionBoundsError == kAXErrorSuccess) {\r\n                NSLog(@\"This works in TextMate 2, but nowhere else that I have seen.\");\r\n                \r\n                NSLog(@\"This case is the objective of this bug report\");\r\n            }\r\n            \r\n            if (selectionRange.length > 0 && selectionBoundsError == kAXErrorSuccess) {\r\n                NSLog(@\"It's easy to get the selection bounds rect when text is selected.\");\r\n            }\r\n            \r\n            if (selectionBoundsError == kAXErrorSuccess)\r\n            {\r\n                CGRect selectionBounds;\r\n                AXValueGetValue(selectionBoundsValue, kAXValueCGRectType, &selectionBounds);\r\n                \r\n                NSLog(@\"This will generally only work if text is highlighted\");\r\n                NSLog(@\"Selection rect: (%f, %f) (%f, %f)\", selectionBounds.origin.x, selectionBounds.origin.y, selectionBounds.size.width, selectionBounds.size.height);\r\n                \r\n                return selectionBounds;\r\n            }\r\n            else if (selectionBoundsError == kAXErrorNoValue)\r\n            {\r\n                NSLog(@\"Could not get selection rect. SelectionRange.length == %lu\", selectionRange.length);\r\n                return CGRectMake(0, 0, 0, 0);\r\n            }\r\n        }\r\n        \r\n        return CGRectMake(0, 0, 0, 0);\r\n    }\r\n\r\nExpected Results:\r\n\r\nThe current textfield's `kAXBoundsForRangeParameterizedAttribute` should always get the on-screen rect of the current selection.\r\n\r\nThe text-insertion caret position is, esentially, a 0-length selection.\r\n\r\nThus `kAXBoundsForRangeParameterizedAttribute` should return a 0-length rect when no text is selected.\r\n\r\nImportantly, though, the rect should always contain the origin and height of the (0-length) selection!\r\n\r\nWhen one character is selected:\r\n - returns CGRect(100, 300, 6, 15)\r\n\r\nWhen 0 characters are selected\r\n - should return CGRect(100, 300, 0, 15)\r\n - actually returns `kAXErrorNoValue`!\r\n - in the code above, we fall back to CGRectMake(0, 0, 0, 0)\r\n\r\nActual Results:\r\n\r\n1. Select some text in the textfield.\r\n2. Run the code\r\n3. Notice that the code returns the bounding rect of the highlighted text.\r\n4. The caret position can be calculated as the left or right edge of the bounding rect.\r\n\r\n- vs -\r\n\r\n1. Put the text-insertion caret in the text, but **do not** select any characters. Standard insertion caret.\r\n2. Run the code\r\n3. Attempting to get the bounding rect of the \"selection\" returns `kAXErrorNoValue`\r\n4. No bounding rect can be calculated.\r\n5. Thus the position of the caret cannot be found. This code returns CGRectMake(0, 0, 0, 0).\r\n\r\nRegression:\r\n\r\nUnknown. Behaves this way in 10.6, 10.7, 10.8\r\n\r\nNotes:\r\n\r\nIn the vast majority of OS X text fields, in both Apple and Third Party apps, this bug report is true. Getting the `kAXBoundsForRangeParameterizedAttribute` attribute value fails with `kAXErrorNoValue` when the selection is empty.\r\n\r\nHowever, I have seen that in the app TextMate 2 (2.0-alpha.9427) it actually works. You can get the frame from the bare text insertion point caret, no selection needed. This is the only app or textfield where I have observed this to work.\r\n\r\nIn TextMate 2, the reported no-selection bounds rect is CGRect(1461, 1302, -1, 16)\r\n\r\nNote the \"-1\" as the width, not 0.\r\n\r\nI have not looked into why TextMate is reporting this value. But it is very useful. You can get the text insertion point position at any time, with or without a selection.\r\n\r\nApple's apps and the standard cocoa controls should allow access as well."
    email: peter.kamb@gmail.com
    modified: "2018-03-24T20:44:29.56825Z"
    number: "14285519"
    number_intvalue: 14285519
    originated: June 26 2013
    parent_number: '&{NULL_VALUE}'
    product: Accessibility
    product_version: ""
    reproducible: ""
    resolved: ""
    status: ""
    title: Unable to get position of text-insertion caret from AX when no text is selected
