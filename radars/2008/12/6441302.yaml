apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "6441302"
    labels:
        datastore_id: "127"
data:
    classification: Crash/Hang/Data Loss
    created: "2008-12-12T18:13:10.687184Z"
    description: "Summary:\r\n\r\nThe mach_msg() function always writes at least 32 bytes of the receive buffer even when it is explicitly told that it is smaller, potentially causing buffer overflows and crashes. Conceivably this could be a security hole, although that seems quite unlikely.\r\n\r\n\r\nSteps to Reproduce:\r\n\r\nCompile the following program:\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#include <mach/mach.h>\r\n#include <mach/port.h>\r\n\r\n\r\n#define ASSERT_SUCCESS do { if(result != KERN_SUCCESS) { fprintf(stderr, \"%s:%d: error %x\\n\", __FILE__, __LINE__, result); exit(1); } } while(0)\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    if(argc != 2)\r\n    {\r\n        fprintf(stderr, \"usage: %s <bytes>\\n\", argv[0]);\r\n        exit(1);\r\n    }\r\n    int bytes = atoi(argv[1]);\r\n    if(bytes < 1 || bytes > 255)\r\n    {\r\n        fprintf(stderr, \"error: argument must be between 1 and 255 inclusive (actually passed %d)\\n\", bytes);\r\n        exit(1);\r\n    }\r\n    \r\n    kern_return_t result;\r\n    \r\n    mach_port_t port;\r\n    result = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);\r\n    ASSERT_SUCCESS;\r\n    \r\n    mach_msg_header_t header;\r\n    header.msgh_bits = MACH_MSGH_BITS_REMOTE(MACH_MSG_TYPE_MAKE_SEND);\r\n    header.msgh_size = sizeof(header);\r\n    header.msgh_remote_port = port;\r\n    header.msgh_local_port = MACH_PORT_NULL;\r\n    header.msgh_id = 0;\r\n    result = mach_msg(&header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, header.msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\r\n    ASSERT_SUCCESS;\r\n    \r\n    unsigned char buf[256];\r\n    \r\n    int i;\r\n    for(i = 0; i < sizeof(buf); i++)\r\n        buf[i] = i;\r\n    \r\n    mach_msg_header_t *msg = (mach_msg_header_t *)buf;\r\n    msg->msgh_size = bytes;\r\n    result = mach_msg(msg, MACH_RCV_MSG, 0, msg->msgh_size, port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\r\n    \r\n    int maxChanged = -1;\r\n    for(i = 0; i < sizeof(buf); i++)\r\n        if(buf[i] != (unsigned char)i)\r\n            maxChanged = i;\r\n    \r\n    fprintf(stderr, \"mach_msg modified at least %d bytes\\n\", maxChanged + 1);\r\n    \r\n    ASSERT_SUCCESS;\r\n    \r\n    printf(\"all done\\n\");\r\n    return 0;\r\n}\r\n\r\nRun it with various values in the range from 1 to 255, paying particular attention to the region around 32.\r\n\r\n\r\nExpected Results:\r\n\r\nThe \"modified at least ... bytes\" message should always print a number which is no more than the parameter given to the application. When passing 128, this number should not exceed 128. When passing 12, this number should not exceed 12. When the parameter passed is too small (under 32) then it should also produce an error 10004004 (MACH_RCV_TOO_LARGE) in the ASSERT_SUCCESS.\r\n\r\n\r\nActual Results:\r\n\r\nThe MACH_RCV_TOO_LARGE error when the parameter is under 32 does occur. However the number of bytes written is never smaller than 32. For example:\r\n\r\n$ ./a.out 255\r\nmach_msg modified at least 32 bytes\r\nall done\r\n$ ./a.out 32\r\nmach_msg modified at least 32 bytes\r\nall done\r\n$ ./a.out 31\r\nmach_msg modified at least 32 bytes\r\nmachmsg.c:56: error 10004004\r\n$ ./a.out 1\r\nmach_msg modified at least 32 bytes\r\nmachmsg.c:56: error 10004004\r\n\r\nIn this artificial test case it's not a problem, because the buffer is more than large enough to tolerate the excess. However in a real app where the buffer really is under 32 bytes long, mach_msg will end up overwriting other objects on the stack with unfortuante results.\r\n\r\n\r\nRegression:\r\n\r\nThis was reproduced by at least two people, at least one of which (myself) was on a first-generation Mac Pro. It appears to be 100% reproducible, although the problem went undetected in my software for a long time due to the overflow not smashing anything important on the stack. I don't guess that mach_msg() will behave differently on different hardware but I certainly wouldn't know for sure.\r\n\r\n\r\nNotes:\r\n\r\nSince mach_msg() always wants to write at least a mach_msg_header_t and a mach_msg_trailer_t , passing a buffer that's less than 32 bytes is a bug in the calling code. However this bug should result in an error code, not a smashed stack. Therefore while the caller should certainly be fixed (and I did fix it in the course of tracking down the original problem), mach_msg() should also be fixed never to overrun the buffer that it is given."
    email: michael.ash@gmail.com
    modified: "2011-08-28T05:48:52.044819Z"
    number: "6441302"
    number_intvalue: 6441302
    originated: 12-Dec-2008 10:12 AM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: 10.5.5
    reproducible: Always
    resolved: ""
    status: Open
    title: mach_msg causes buffer overflow when passed small buffers
