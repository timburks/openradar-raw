apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "6332143"
    labels:
        datastore_id: "99"
data:
    classification: Crash
    created: "2008-12-01T20:28:36.980003Z"
    description: "30-Oct-2008 09:32 AM Michael Ash:\r\nSummary:\r\n\r\nWhen enqueueing an NSOperation from inside the action of another NSOperation, while many concurrent NSOperationQueues are executing, the following exception is sometimes thrown:\r\n\r\n*** -[NSInvocationOperation start]: receiver has already started or finished\r\n\r\nSteps to Reproduce:\r\n\r\nCompile and run the following program:\r\n\r\n#import <Foundation/Foundation.h>\r\n\r\n\r\n@interface Tester : NSObject\r\n{\r\n    NSOperationQueue *_queue;\r\n}\r\n\r\n- (void)test;\r\n\r\n@end\r\n\r\n@implementation Tester\r\n\r\n- (id)init\r\n{\r\n    if((self = [super init]))\r\n    {\r\n        _queue = [[NSOperationQueue alloc] init];\r\n        [_queue setMaxConcurrentOperationCount:1];\r\n    }\r\n    return self;\r\n}\r\n\r\n- (void)test\r\n{\r\n    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:_cmd object:nil];\r\n    [_queue addOperation:op];\r\n    [op release];\r\n}\r\n\r\n@end\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    [NSAutoreleasePool new];\r\n    \r\n    NSMutableArray *testers = [NSMutableArray array];\r\n    int i;\r\n    for(i = 0; i < 10; i++)\r\n        [testers addObject:[[[Tester alloc] init] autorelease]];\r\n    \r\n    for(Tester *tester in testers)\r\n        [tester test];\r\n    \r\n    while(1) sleep(1000);\r\n}\r\n\r\nExpected Results:\r\n\r\nThe given program should run indefinitely with no errors.\r\n\r\nActual results:\r\n\r\nAfter a few seconds on my four-core first generation Mac Pro, it throws the above exception with this backtrace:\r\n\r\n#0  0x96480ff4 in ___TERMINATING_DUE_TO_UNCAUGHT_EXCEPTION___ ()\r\n#1  0x9207ee3b in objc_exception_throw ()\r\n#2  0x92db74de in -[NSOperation start] ()\r\n#3  0x92db7112 in __runop ()\r\n#4  0x902ae1f7 in _pthread_wqthread ()\r\n#5  0x902ae0aa in start_wqthread ()\r\n\r\nAnd this is the backtrace of all threads in the program from one example run:\r\n\r\n(gdb) t a a bt\r\n\r\nThread 13 (process 28827 thread 0x3003):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db7366 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 12 (process 28827 thread 0x2f03):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db7366 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 11 (process 28827 thread 0x2e03):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db7366 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 10 (process 28827 thread 0x2d03):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db7260 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 9 (process 28827 thread 0x2c03):\r\n#0  0x96480ff4 in ___TERMINATING_DUE_TO_UNCAUGHT_EXCEPTION___ ()\r\n#1  0x9207ee3b in objc_exception_throw ()\r\n#2  0x92db74de in -[NSOperation start] ()\r\n#3  0x92db7112 in __runop ()\r\n#4  0x902ae1f7 in _pthread_wqthread ()\r\n#5  0x902ae0aa in start_wqthread ()\r\n\r\nThread 8 (process 28827 thread 0x2b03):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db74b5 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 7 (process 28827 thread 0x2a03):\r\n#0  0x902ae07a in __workq_ops ()\r\n#1  0x902af772 in workqueue_exit ()\r\n#2  0x902ae0aa in start_wqthread ()\r\n\r\nThread 6 (process 28827 thread 0x2903):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db74b5 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 5 (process 28827 thread 0x1303):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db7260 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 4 (process 28827 thread 0x1203):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db74b5 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 3 (process 28827 thread 0x1103):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db7502 in -[NSOperation _implicitObservationInfo] ()\r\n#3  0x92d22bbb in -[NSObject(NSKeyValueObserverNotification) willChangeValueForKey:] ()\r\n#4  0x92db7366 in -[NSOperation start] ()\r\n#5  0x92db7112 in __runop ()\r\n#6  0x902ae1f7 in _pthread_wqthread ()\r\n#7  0x902ae0aa in start_wqthread ()\r\n\r\nThread 2 (process 28827 thread 0x1003):\r\n#0  0x902444ee in semaphore_wait_signal_trap ()\r\n#1  0x9024bfc5 in pthread_mutex_lock ()\r\n#2  0x92db5f40 in -[NSOperation init] ()\r\n#3  0x92e757ac in -[NSInvocationOperation initWithInvocation:] ()\r\n#4  0x92e756d7 in -[NSInvocationOperation initWithTarget:selector:object:] ()\r\n#5  0x00001c7e in -[Tester test] (self=0x105d20, _cmd=0x9209a260) at nsoptest.m:27\r\n#6  0x96486a7d in __invoking___ ()\r\n#7  0x96486468 in -[NSInvocation invoke] ()\r\n#8  0x92e75988 in -[NSInvocationOperation main] ()\r\n#9  0x92db7424 in -[NSOperation start] ()\r\n#10 0x92db7112 in __runop ()\r\n#11 0x902ae1f7 in _pthread_wqthread ()\r\n#12 0x902ae0aa in start_wqthread ()\r\n\r\nThread 1 (process 28827 local thread 0x2d03):\r\n#0  0x9024b68e in __semwait_signal ()\r\n#1  0x9024b50f in nanosleep$UNIX2003 ()\r\n#2  0x902a1c59 in sleep$UNIX2003 ()\r\n#3  0x00001ec5 in main (argc=1, argv=0xbffff818) at nsoptest.m:46\r\n(gdb) \r\n\r\nRegression:\r\n\r\nThis problem was reproduced on two MacBook Pros and another Mac Pro. It happens 100% reliably on my Mac pro, the reliability was not tested on the others but is presumed to also be reliable. The test program was also run on a G5 and a MacBook with no problem.\r\n\r\nNotes:\r\n\r\nN/A\r\n\r\n01-Feb-2009 01:30 PM Michael Ash:\r\nI have now come up with a greatly simplified test case which still demonstrates the problem:\r\n\r\n#import <Foundation/Foundation.h>\r\n\r\n@interface MyOperation : NSOperation {} @end\r\n@implementation MyOperation\r\n- (void)main\r\n{\r\n    usleep(10000);\r\n}\r\n@end\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    NSAutoreleasePool *outerPool = [[NSAutoreleasePool alloc] init];\r\n    \r\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\r\n    unsigned count = 0;\r\n    while(1)\r\n    {\r\n        NSAutoreleasePool *innerPool = [[NSAutoreleasePool alloc] init];\r\n        \r\n        MyOperation *op = [[MyOperation alloc] init];\r\n        [queue addOperation:op];\r\n        [op release];\r\n        \r\n        if(++count % 50000 == 0)\r\n            NSLog(@\"%u operations\", count);\r\n        \r\n        [innerPool release];\r\n    }\r\n    \r\n    [outerPool release];\r\n    return 0;\r\n}\r\n\r\nOn my Mac Pro, this crashes with the same NSInvalidArgumentException with great reliability, and often after only a few seconds of execution, although some runs can take much longer."
    email: michael.ash@gmail.com
    modified: "2011-08-28T05:49:30.911447Z"
    number: "6332143"
    number_intvalue: 6332143
    originated: 30-Oct-2008 09:32 AM
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: 10.5.5
    reproducible: Sometimes
    resolved: ""
    status: Open
    title: '[Mac OS X 10.5.5] Exception thrown in busy NSOperationQueues'
