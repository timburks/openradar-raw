apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "23855967"
    labels:
        datastore_id: "4962445244235776"
data:
    classification: Serious Bug
    created: "2015-12-11T09:25:59.36223Z"
    description: "# Summary:\nCIContext render: API to memory buffer crashes when provided with a filter taking 2+ GL-based CIImage.\n\n# Steps to Reproduce:\nHere's the sample code. (imageA & imageB are GL texture-based, GL context is active, etc). Crashes in CIContext render: call.\n\n\tCIImage *imageA = [simage CIImage];\n\tCIImage *imageB = [rimage CIImage];\n\tCIFilter *filter = [CIFilter filterWithName:@\"CIAreaAverage\"];\n\t\n\tCIFilter *diffblend = [CIFilter filterWithName:@\"CISubtractBlendMode\"];\n\tCIImage *image = imageA;\n\t\n\t[diffblend setDefaults];\n\t[diffblend setValue:imageA forKey:kCIInputImageKey];\n\t[diffblend setValue:imageB forKey:kCIInputBackgroundImageKey];\n\t\n\timage = diffblend.outputImage;\n\t\n\t[filter setDefaults];\n\t[filter setValue:image forKey:kCIInputImageKey];\n\t[filter setValue:[CIVector vectorWithCGRect:image.extent] forKey:kCIInputExtentKey];\n\timage = filter.outputImage;\n\t\n\tfloat rgba[4] = {0.0};\n\t\t\n\t[self.CIContext render:image toBitmap:rgba rowBytes:4*sizeof(float) bounds:image.extent format:kCIFormatRGBAf colorSpace:NULL];\n\tEXLog(@\"mean value: %f %f %f %f\", rgba[0], rgba[1], rgba[2], rgba[3]);\n\n\n# Expected Results:\nShould not crash, & should output values in rgba mem buffer.\n\n# Actual Results:\nCrashed in render: call. Here's the stack trace. \n\nThread 8Queue : NSOperationQueue 0x60300009d300 :: NSOperation 0x60400024fc90 (QOS: LEGACY) (serial)\n#0\t0x00007fff87e6586b in std::__1::__tree<std::__1::__value_type<void*, CI::source_info_t*>, std::__1::__map_value_compare<void*, std::__1::__value_type<void*, CI::source_info_t*>, std::__1::less<void*>, true>, std::__1::allocator<std::__1::__value_type<void*, CI::source_info_t*> > >::erase(std::__1::__tree_const_iterator<std::__1::__value_type<void*, CI::source_info_t*>, std::__1::__tree_node<std::__1::__value_type<void*, CI::source_info_t*>, void*>*, long>) ()\n#1\t0x00007fff87e644c8 in CI::TextureManager::remove_lru() ()\n#2\t0x00007fff87e642ca in CI::TextureManager::remove_all() ()\n#3\t0x00007fff87e92fbd in CI::GLContext::after_render() ()\n#4\t0x00007fff87d67793 in CI::_get_bitmap(CI::Context*, CI::Image*, CGRect, CGColorSpace*, CI::Bitmap*) ()\n#5\t0x00007fff87d673b9 in CI::image_get_bitmap(CI::Context*, CI::Image*, CGRect, CGColorSpace*, CI::Bitmap*, unsigned long) ()\n#6\t0x00007fff87d49c54 in -[CIContext render:toBitmap:rowBytes:bounds:format:colorSpace:] ()\n#7\t0x000000010016dae1 in -[HYRenderContext _measurePerfsSourceImage:renderedImage:context:] at /Users/raf/WorkArea/Creacode/Hydra/Hydra/Sources/HYRenderContext.m:1416\n#8\t0x0000000100178c55 in -[HYRenderContext _flatten:exposureRange:context:] at /Users/raf/WorkArea/Creacode/Hydra/Hydra/Sources/HYRenderContext.m:1772\n#9\t0x000000010017d2cd in __60-[HYRenderContext flattenImageForProject:completionHandler:]_block_invoke_2 at /Users/raf/WorkArea/Creacode/Hydra/Hydra/Sources/HYRenderContext.m:1882\n#10\t0x0000000100201f84 in __41-[HYOpenGLRenderContext renderWithBlock:]_block_invoke at /Users/raf/WorkArea/Creacode/Hydra/Hydra/Sources/HYOpenGLRenderContext.m:266\n#11\t0x000000010023767f in __29-[GLQueue executeBlock:wait:]_block_invoke at /Users/raf/WorkArea/Creacode/CeedGL/Sources/GLQueue.m:66\n#12\t0x00007fff8cfae29c in __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ ()\n#13\t0x00007fff8cfae00c in -[NSBlockOperation main] ()\n#14\t0x00007fff8cfad2fb in -[__NSOperationInternal _start:] ()\n#15\t0x00007fff8cfacde7 in __NSOQSchedule_f ()\n#16\t0x00000001012105ce in asan_dispatch_call_block_and_release ()\n\nDescription of the image being rendered at the time of the crash.\n\n(lldb) po image\n<CIImage: 0x603000154810 extent [0 0 1 1]>\n  color_matrix r=(1 0 0 0) g=(0 1 0 0) b=(0 0 1 0) a=(0 0 0 1.67167) extent=[0 0 1 1]\n    kernel _areaAvg8(image) extent=[0 0 1 1]\n      kernel _areaAvg8(image) extent=[0 0 8 6]\n        kernel _areaAvg8(image) extent=[0 0 61 41]\n          kernel _areaAvg8(image) extent=[0 0 484 324]\n            colorkernel _subtractBlendMode(uCf,uCb) extent=[0 0 3872 2592]\n              unpremultiply extent=[0 0 3872 2592]\n                GLTexture 10 extent=[0 0 3872 2592]\n              unpremultiply extent=[0 0 3872 2592]\n                GLTexture 26 extent=[0 0 3872 2592]\n\n(lldb) po self.CIContext\n<CIContext: 0x60200003c0d0 (2) GLContext=0x628000000100>\n\n\n# Regression:\nAny Mac running OS El Capitan.\n\n# Notes:\nBoth GL textures are perfectly valid at the time of render, and appropriate context is active (single thread).\nIf I use only one GL texture-based CIImage -> it does not crash."
    email: raphael@creaceed.com
    modified: "2015-12-11T09:25:59.36263Z"
    number: "23855967"
    number_intvalue: 23855967
    originated: 11-Dec-2015 10:25 AM
    parent_number: '&{NULL_VALUE}'
    product: OS X SDK
    product_version: 10.11.2 (15C50)
    reproducible: Always
    resolved: ""
    status: Open
    title: 'Core Image (OS X El Capitan): Crash when filter has 2 or more GL-based CIImage inputs.'
