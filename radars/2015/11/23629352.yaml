apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "23629352"
    labels:
        datastore_id: "6643080308457472"
data:
    classification: Performance
    created: "2015-11-20T16:33:51.42462Z"
    description: "Summary:\r\nThe attached project demonstrates this issue using the following type:\r\n\r\npublic struct Container<Element> {\r\n    var storage: [Element]\r\n    \r\n    public init() {\r\n        storage = Array()\r\n    }\r\n    \r\n    public mutating func append(value: Element) {\r\n        storage.append(value)\r\n    }\r\n    \r\n    public mutating func append2(value: Element) {\r\n        storage.append(value)\r\n        storage.withUnsafeMutableBufferPointer { _ in }\r\n    }\r\n    \r\n    public mutating func removeLast() {\r\n        storage.removeLast()\r\n    }\r\n    \r\n    public mutating func removeLast2() {\r\n        storage.withUnsafeMutableBufferPointer { _ in }\r\n        storage.removeLast()\r\n    }\r\n}\r\n\r\nThe Container type is a very small wrapper for Array, supporting append and removeLast by passing these along to the underlying array.\r\nThere are two variants of these methods, one with and one without calls to Array.withUnsafeMutableBufferPointer(...) with empty closure bodies.\r\n\r\nThe project tests the performance of these methods by first inserting and then removing a number of elements into a Container.\r\n\r\nAs demonstrated by the 'Bug' target, somewhat surprisingly the (empty) call to Array.withUnsafeMutableBufferPointer(...) leads to a large performance penalty. Profiling indicates that this is due to object allocations, one per call to 'removeLast2()' in fact.\r\n\r\nInterestingly this seems to be caused by an interaction of  'append2()' and 'removeLast2()' since, if the 'withUnsafeMutableBufferPointer()' call is removed in either of the functions the allocations do not occur.\r\n\r\nI also have another weird interaction-leads-to-performance-difference case that is demonstrated in the 'Bug2' target. The code is almost the same as for 'Bug' but now the 'withUnsafeMutableBufferPointer()' call is also used in 'append' and 'removeLast':\r\n\r\npublic struct Container<Element> {\r\n    var storage: [Element]\r\n    \r\n    public init() {\r\n        storage = Array()\r\n    }\r\n    \r\n    public mutating func append(value: Element) {\r\n        storage.append(value)\r\n        storage.withUnsafeMutableBufferPointer { _ in }\r\n    }\r\n    \r\n    public mutating func append2(value: Element) {\r\n        storage.append(value)\r\n        storage.withUnsafeMutableBufferPointer { _ in }\r\n    }\r\n    \r\n    public mutating func removeLast() {\r\n        storage.withUnsafeMutableBufferPointer { _ in }\r\n        storage.removeLast()\r\n    }\r\n    \r\n    public mutating func removeLast2() {\r\n        storage.withUnsafeMutableBufferPointer { _ in }\r\n        storage.removeLast()\r\n    }\r\n}\r\n\r\nIn this case, the test using 'append' and 'removeLast' is much faster than the test using 'append2' and 'removeLast2' even though they are now 'equivalent'.\r\nFor additional fun, if the test using 'append2' and 'removeLast2' is not used (by uncommenting it), the test using 'append' and 'removeLast' now becomes slower.\r\n\r\n\r\nNow I'm filing these two issues as a single bug as they are probably related. However, If you'd rather I file separate bugs, let me know and I will do so.\r\n\r\nSteps to Reproduce:\r\n1. Open the attached project\r\n\r\n2. Build & run the 'Bug' target\r\n3. Comment line '32' in main.swift of Bug -> Build & run\r\n\r\n4. Build & run the 'Bug2' target\r\n5. Comment line '78' in main.swift of Bug2 -> Build & run\r\n\r\nExpected Results:\r\nNow I don't know in which cases the allocation caused by 'withUnsafeMutableBufferPointer()' might actually be necessary, but given the fact that in 'Bug2' the compiler is able to produce code that does not incur the allocation, it should at least be able to do this in all these cases.\r\n\r\n-> In steps 2-4, the printed runtimes should be almost equal.\r\n-> In step 5, the first results should be almost equal to the results in step 4.\r\n\r\nAlso the interactions between the functions are extra weird and should probably? not happen... At least its very confusing when the performance of one function depends on whether another function is compiled along with it... ;-)\r\n\r\nActual Results:\r\nFor reference, these are the results I get on my machine:\r\n\r\nStep 2:\r\n0.13051700592041\r\n2.01244086027145\r\n\r\nStep 3:\r\n0.126521706581116\r\n0.147176027297974\r\n\r\nStep 4:\r\n0.167377114295959\r\n2.01639533042908\r\n\r\nStep 5:\r\n2.00278067588806\r\n0.000157773494720459\r\n\r\n\r\nVersion:\r\nXcode 7.2b4 (7C62b)\r\nApple Swift version 2.1.1 (swiftlang-700.1.101.13 clang-700.1.81)\r\nOS X 10.11.1 (15B42)\r\n\r\nNotes:\r\n\r\n\r\nConfiguration:\r\n-O"
    email: janoschhildebrand@gmail.com
    modified: "2015-11-20T16:33:51.42504Z"
    number: "23629352"
    number_intvalue: 23629352
    originated: 20-Nov-2015
    parent_number: '&{NULL_VALUE}'
    product: Developer Tools
    product_version: Xcode 7.2b4 (7C62b)
    reproducible: Always
    resolved: ""
    status: Open
    title: 'Xcode 7.2b4 (7C62b): [Swift] Array.withUnsafeMutableBufferPointer() leads to unnecessary? allocations'
