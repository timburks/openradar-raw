apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "23454180"
    labels:
        datastore_id: "6559723046305792"
data:
    classification: Enhancement
    created: "2015-11-07T22:17:16.17621Z"
    description: "It is currently impossible to correctly implement the following protocol (or any protocol that approximates it) in a way that does not lead to constant surprise in the face of subclassing.\n\nprotocol Copyable {\n    func copy() -> Self\n}\n\nThis would seem to be about the simplest and most obvious protocol that involves Self, but it is an eternal maze of twisty passages the moment subclasses enter the picture, and Swift provides no mechanism for excluding them. (There is no mirror of “class” protocols that demand “noclass.”)\n\nThis particular version of Copyable is not possible to implement at all. There’s no way to construct the required object:\n\nclass A: Copyable {\n    var x: Int\n    init(x: Int) { self.x = x }\n    func copy() -> Self {\n        return A(x: x)                    // Cannot convert return expression of type 'A' to return type 'Self'\n        return Self(x: x)                  // Use of unresolved identifier 'Self'\n        return self.dynamicType.init(x: x) // Constructing an object of class type 'Self' with a metatype value must use a 'required' initializer\n    }\n}\n\nThis is reasonable given Swift’s strict construction requirements. The problem is when you try to move forward with a required copying init: \n\nprotocol Copyable {\n    init(copying: Self)\n}\n\nextension Copyable {\n    func copy() -> Self {\n        return self.dynamicType.init(copying: self) // This resolves to init(copy: A), never init(copy: B)\n    }\n}\n\nclass A: Copyable {\n    var x: Int\n    init(x: Int) { self.x = x }\n    required init(copying other: A) { x = other.x }\n}\n\nclass B: A {\n    var y: Int\n    init(x: Int, y: Int) {\n        self.y = y\n        super.init(x: x)\n    }\n    required init(copying other: A) {\n        print(\"B.init(copy:A)\")\n        y = 0\n        super.init(copying: other)\n    }\n    required init(copying other: B) { // \"required\" not required here, but it should be according to the protocol, and is ignored by Swift.\n        print(\"B.init(copy:B)\")\n        y = other.y\n        super.init(copying: other)\n    }\n}\n\nlet b = B(x: 1, y: 2)\n\nlet c = b.copy()\n(c.x, c.y)  // (1, 0)! So that's still not right.\n\nlet c2 = B(copying: b)\n(c2.x, c2.y)  // (1, 2), works, but only if b is exactly type B, and not a subclass.\n\nlet c3 = b.dynamicType.init(copying: b)\n(c3.x, c3.y)  // (1, 2), works when done by hand, but lacks enforcement\n\nThe main issue is that the protocol requires init(copying: Self), but B isn’t required to implement init(copying: B). While B can certainly be passed to A, init(copying: B) is not the same type as init(copying: A), and so shouldn’t be sufficient to conform to the protocol. If I replace A’s init(copying: A) with init(copying: Any), that’s not sufficient for A to conform. By the same reasoning, B shouldn’t conform without implementing copying:B.\n\nThe problem is deeper, however. Even though I *do* implement copying:B, it is never called in any code where the type is generic. For example:\n\nextension Copyable {\n    func copy() -> Self {\n        return self.dynamicType.init(copying: self) // This resolves to init(copy: A), never init(copy: B)\n    }\n}\n\nWhen called as “b.copy()”, Self resolves to B. However, init(copying:A) is called rather than init(copying:B). This is extremely surprising to the caller. In a generic function, the same problem occurs:\n\nfunc copy<T: Copyable>(x: T) -> T {\n    return x.dynamicType.init(copying: x)\n}\nfunc bcopy(x: B) -> B {\n    return x.dynamicType.init(copying: x)\n}\n\nlet c4 = copy(b)\n(c4.x, c4.y)  // (1, 0)! So that's still not right.\n\nlet c5 = bcopy(b)\n(c5.x, c5.y) // (1,2) works\n\n\nOne might argue that, for type B, the correct answer is to copy with B(copying:b), but that’s not sufficient to correctly copy. If there is a subclass of B, I may not even know the actual type of b. The only semi-reliable solution is to call b.dynamicType.init(copying: b), though the compiler doesn’t ensure that the subclass correctly overloads the copying init (you’re only required to implement copying:A).\n\nUltimately this is worse than the situation with NSCopying, which drives us back to AnyObject and “x.copy() as! X” which is dangerous and abandons exactly the safety that Swift’s strict (and sometimes tedious) constructors were supposed to provide.\n\nUltimately we need some way to express “let x = y.copy()” such that the resulting x has the same type as y and is promised to be fully initialized. If it is not possible, then Self should be forbidden in non-final classes to avoid the current surprising behavior. Everything looks fine, and seems to work, until suddenly the wrong init() is called for a subclass you didn’t know about during testing."
    email: robnapier@gmail.com
    modified: "2015-11-07T22:17:16.17656Z"
    number: "23454180"
    number_intvalue: 23454180
    originated: 07-Nov-2015 05:17 PM
    parent_number: '&{NULL_VALUE}'
    product: Developer Tools
    product_version: Xcode 7.2 Beta (7C46t)
    reproducible: Not Applicable
    resolved: ""
    status: Open
    title: It is impossible to correctly implement Copyable (returning Self)
