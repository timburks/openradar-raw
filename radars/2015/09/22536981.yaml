apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "22536981"
    labels:
        datastore_id: "4985491669647360"
data:
    classification: ""
    created: "2015-09-02T11:47:25.4971Z"
    description: "Summary:\r\nWhen a combo box is a child of a transient NSPopover and you click outside the popover to dismiss the combo, the NSComboBoxCell dispatches a mousedown but not mouseup.\r\n\r\n---\r\n\r\nI have an NSComboBox child of an NSPopover. The popover is transient and is configured to dismiss when the user clicks outside its bounds.\r\n\r\nWhen its combobox popup is active and displayed, and when the user mouses down on the popovers owning view, the view receives the mouse down as expected, the popover disappears and the combobox dismisses, however the very next mouseUp is never received by the view.\r\n\r\nIt turns out the NSComboBoxCell's trackMouse method (tracking loop) is not returning until it receives a mouseUp but unlike the case of mouseDown where it redispatches it nicely to the view that was clicked on, it never propagates the mouseUp.\r\n\r\nI had to work around the issue with the following NSComboBoxCell trackMouse override.\r\n\r\nSteps to Reproduce:\r\n1. Run Test sample make sure debug console is active and open.\r\n2. Push the button to open NSPopover.\r\n3. Drop the combobox down.\r\n4. Single click outside to the left of the NSPopover to dismiss it, make sure not to move the mouse, then mouse up.\r\n5. 90% of the time you only get mouseDown, not mouseUp reported to console.\r\n\r\nContrast that with the combobox that's parented by the view itself, open the combo there and click outside it ... no mouseDown or mouseUp - this I expect is the desired behavior.\r\n\r\nExpected Results:\r\nShould have either seen mouseUp and mouseDown, or neither (per the normal case with combobox), but NEVER a mouseDown and no mouseUp.\r\n\r\nActual Results:\r\nParent view receivers a mouseDown with no mouseUp...obvious problematic.  NSComboBoxCell trackMouse is dismissing itself with mouseUp but not re-dispatching the mouseUp.\r\n\r\nSome notes:\r\n\r\n// Normally trackMouse eats all mouse events and doesn't let them get to other controls. However, IF we are inside an NSPopover\r\n    // clicking to dismiss the combobox dropdown will send a mouseDown with no matching mouseUp to the view the user clicked on.\r\n    // We need to prevent such asymmetrical mouseDown/Ups to avoid getting the canvas into a bad state.\r\n    //\r\n    // The NSComboBoxCell trackMouse call blocks and runs an event loop, with different lifespan depending on type of interaction:\r\n    //\r\n    // a) Open dropdown & select item in one gesture, via click-drag - starts on the mouseDown that opens the dropdown and ends\r\n    //      after the drag's mouseUp. Last event processed: NSApplicationDefined (presumably the \"select\").\r\n    // b) Open drodown via click, click to select an item - starts on the mouseDown that opens the dropdown, continues past that\r\n    //      mouseUp, continues into 2nd mouseDown, and ends after the mouseUp that finalizes that 2nd click. Last event processed:\r\n    //      NSApplicationDefined.\r\n    // c) Open dropdown via click, click-drag to select an item - same as case B.\r\n    // d) Open dropdown via click, click outside dropdown to close - starts on the mouseDown that opens the dropdown, continues\r\n    //      past that click's mouseUp, continues into 2nd mouseDown*, and ends on the 2nd mouseUp. Last event processed: NSLeftMouseUp.\r\n    //      * IF combobox is inside an NSPopover, the 2nd mouseDown (i.e. the one outside the dropdown) is forwarded to whatever\r\n    //        view the mouse is over, but the 2nd mouseUp that follows it is NOT forwarded. *THIS IS THE BUGGY CASE*\r\n    // e) Open dropdown via click, drag outside dropdown to close - starts on the mouseDown that opens the dropdown, continues\r\n    //      past that click's mouseUp, continues into 2nd mouseDown*, and ends on the *very next mouseMove* - does NOT wait for\r\n    //      mouseUp. Last event processed: NSLeftMouseDragged.\r\n    //      * IF combobox is inside an NSPopover, the 2nd mouseDown is forwarded to whatever view the mouse is over, AND the\r\n    //        subsequent mouseDraggeds (after trackMouse exits) and mouseUp are all sent normally to that view. Normally, none of\r\n    //        those events make it to the view.\r\n    // f) Open dropdown via click, press Enter to select an item - starts on the mouseDown of the click, continues past the mouseUp,\r\n    //      and ends on the keyDown of the Enter key. Last event processed: NSKeyDown.\r\n    // g) Open dropdown via click, press Esc to close - same as case G.\r\n    //\r\n    // The \"*\" behavior in case D is the only reason we need the workaround below - the view the user clicked on gets a mouseDown but\r\n    // no matching mouseUp in that case. Our workaround below ensures the view receives a mouseUp too.\r\n\r\nVersion:\r\nXCode 6.4\r\n\r\nNotes:\r\n\r\n\r\nConfiguration:\r\nLatest OSX SDK - 10.10\r\n\r\nAttachments:\r\n'Combobox in popover test.zip' was successfully uploaded."
    email: corey.lucier@gmail.com
    modified: "2015-09-02T11:47:25.49748Z"
    number: "22536981"
    number_intvalue: 22536981
    originated: 9/2/2015
    parent_number: '&{NULL_VALUE}'
    product: OSX SDK
    product_version: ""
    reproducible: ""
    resolved: ""
    status: Open
    title: NSComboBoxCell eats mouseUp events.
