apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "20186548"
    labels:
        datastore_id: "5289645013204992"
data:
    classification: Feature (new)
    created: "2015-03-17T09:08:30.891135Z"
    description: "Summary:\r\nI'd like Swift to have a well-defined String representation for floating-point numbers.\r\n \r\nThere is a widely used algorithm that could be used: http://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf â€“ \"Printing Floating-Point Numbers Quickly and Accurately\" by Burger & Dybvig.\r\n \r\nIn Cocoa, I'm only aware of JavaScriptCore making use of that algorithm.\r\n\r\n* * *\r\n\r\nCurrently, the REPL, Playground, debugger and the toString functions all print or show floating point number differently. And quite often, two different Double values print as if they were equal.\r\n \r\nA number of programming languages (Python, Java, JavaScript; see e.g. http://www.ecma-international.org/ecma-262/5.1/#sec-9.8.1) require the default string conversion from floating-point numbers to not lose precision while still producing the shortest decimal representation in the number of decimal digits.\r\n \r\nDoing so has the benefit that converting a number to String and back (think JSON, CSV) doesn't lose precision compared to storing the floating-point number as bytes in memory and reading them later:\r\n\r\n```\r\nimport Foundation\r\nfunc arbitrary() -> Double {\r\n  while true {\r\n    let u = UInt64(arc4random()) << 32 | UInt64(arc4random())\r\n    let x = unsafeBitCast(u, Double.self)\r\n    if x.isFinite { return x }\r\n  }\r\n}\r\nfunc toDouble(string: String) -> Double {\r\n  return (string as NSString).doubleValue\r\n}\r\nfor _ in 0 ..< 100000 {\r\n  let x: Double = arbitrary()\r\n  println(x)\r\n  assert(         toDouble(toString(x))  == x)           // FAILS!\r\n  assert(toString(toDouble(toString(x))) == toString(x)) // FAILS!\r\n}\r\n```\r\n\r\nSteps to Reproduce:\r\nSwift (as well as Objective-C and Foundation) have varying standards for representing floating-point numbers. One the one hand, the conversion may lose precision:\r\n\r\n```\r\nlet moreThanOne = nextafter(1, Double.infinity)        //=>  1.0000000000000002\r\nassert(moreThanOne == toDouble(toString(moreThanOne))) // FAILS!\r\ntoString(moreThanOne)                                  //=> \"1.0\"\r\ntoString(moreThanOne as NSNumber)                      //=> \"1\"\r\nNSString(format: \"%lg\", moreThanOne)                   //=> \"1\"\r\n\r\nlet lessThanOne = nextafter(1, -Double.infinity)       //=>  0.99999999999999988\r\nassert(lessThanOne == toDouble(toString(lessThanOne))) // FAILS!\r\ntoString(lessThanOne)                                  //=> \"1.0\"\r\ntoString(lessThanOne as NSNumber)                      //=> \"0.9999999999999999\"\r\nNSString(format: \"%lg\", lessThanOne)                   //=> \"1\"\r\n```\r\n\r\nOn the other hand, none of the conversions use decimal digits sparingly either:\r\n\r\n```\r\nlet oneAndSome = 1 + 1e-15                             //=>  1.0000000000000011 // why not just \"1.000000000000001\"?\r\nassert(oneAndSome == toDouble(toString(oneAndSome)))   // FAILS!\r\n\r\ntoString(oneAndSome)                                   //=> \"1.0\"\r\ntoString(oneAndSome as NSNumber)                       //=> \"1.000000000000001\"\r\nNSString(format: \"%lg\", oneAndSome)                    //=> \"1\"\r\n \r\nlet almostZero = DBL_TRUE_MIN                          //=> 4.9406564584124654E-324 // why not just \"5e-324\"?\r\nassert(almostZero == toDouble(toString(almostZero)))   // pass\r\ntoString(almostZero)                                   // \"4.94065645841247e-324\"\r\ntoString(almostZero as NSNumber)                       // \"4.940656458412465e-324\"\r\nNSString(format: \"%lg\", almostZero)                    // \"4.94066e-324\"\r\n```\r\n\r\nAll of the above string representations for almostZero can be seen as \"wrong\" because the least positive Double value 5e-324 is only succeeded by:\r\n\r\n```\r\nlet stillTiny = nextafter(almostZero, Double.infinity) //=>  9.8813129168249309E-324 // why not just \"1e-323\"\r\ntoString(stillTiny)                                    //=> \"9.88131291682493e-324\"\r\n```\r\n\r\nwhich means that neither of these require more than one significant digit to be distinguishable and to perfectly round trip the conversion to and from String.\r\n\r\nExpected Results:\r\n```\r\ntoString(1.0) //=> \"1\"\r\ntoString(nextafter(1, Double.infinity)) //=> \"1.0000000000000002\"\r\ntoString(nextafter(1, -Double.infinity)) //=> \"0.9999999999999999\"\r\ntoString(1 + 1e-15) //=> \"1.000000000000001\"\r\ntoString(DBL_TRUE_MIN) //=> \"5e-324\"\r\ntoString(2 * DBL_TRUE_MIN) //=> \"1e-323\"\r\n```\r\n\r\nI'd also expect there to be a function for converting a String to a Float or Double:\r\n\r\n```\r\nDouble(string: \"1\") //=> Optional(1.0)\r\nDouble(string: \"nan\") //=> Optional(NaN)\r\nDouble(string: \"1e-323\") //=> Optional(1e-323)\r\nDouble(string: \"-Infinity\") //=> Optional(-Inf)\r\nFloat(string: \"+Infinity\") //=> Optional(+Inf)\r\n```\r\n\r\nActual Results:\r\n```\r\ntoString(1.0) //=> \"1.0\"\r\ntoString(nextafter(1, Double.infinity)) //=> \"1.0\"\r\ntoString(nextafter(1, -Double.infinity)) //=> \"1.0\"\r\ntoString(1 + 1e-15) //=> \"1.0\"\r\ntoString(DBL_TRUE_MIN) //=> \"4.94065645841247e-324\"\r\ntoString(2 * DBL_TRUE_MIN) //=> \"9.88131291682493e-324\"\r\n```\r\n\r\n```\r\nerror: extra argument 'string' in call\r\nDouble(string: \"1.0\")\r\n      ^        ~~~~~\r\n```\r\n\r\n\r\nVersion:\r\n\r\n\r\nNotes:\r\nAs a workaround, JavaScriptCore could be used like so:\r\nlet ctx = JSContext()\r\nfunc toJSString(double: Double) -> String {\r\n    return JSValue(double: double, inContext: ctx).toString()\r\n}\r\n\r\n// All as expected:\r\ntoJSString(1.0)         //=> \"1\"\r\ntoJSString(moreThanOne) //=> \"1.0000000000000002\"\r\ntoJSString(lessThanOne) //=> \"0.9999999999999999\"\r\ntoJSString(oneAndSome)  //=> \"1.000000000000001\"\r\ntoJSString(almostZero)  //=> \"5e-324\"\r\ntoJSString(stillTiny)   //=> \"1e-323\"\r\n\r\nassert(moreThanOne == toDouble(toJSString(moreThanOne)))  // pass\r\nassert(lessThanOne == toDouble(toJSString(lessThanOne)))  // pass\r\nassert(oneAndSome == toDouble(toJSString(oneAndSome)))    // pass\r\nassert(almostZero == toDouble(toJSString(almostZero)))    // pass\r\nassert(stillTiny == toDouble(toJSString(stillTiny)))      // pass\r\nWouldn't it be a good idea to implement this conversion in the Swift standard library as default?\r\n\r\nConfiguration:\r\n\r\n\r\nAttachments:"
    email: pyry.jahkola@gmail.com
    modified: "2015-03-17T09:08:30.891401Z"
    number: "20186548"
    number_intvalue: 20186548
    originated: "2015-03-17"
    parent_number: '&{NULL_VALUE}'
    product: Developer Tools
    product_version: ""
    reproducible: Always
    resolved: ""
    status: Open
    title: 'Swift: String representation for floating-point numbers should be compact and bijective like in e.g. JavaScript'
