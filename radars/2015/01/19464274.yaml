apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "19464274"
    labels:
        datastore_id: "6390137772572672"
data:
    classification: Serious Bug
    created: "2015-01-14T00:24:22.022202Z"
    description: "Summary:\r\nSwift supports static properties on structs with arbitrary initializer expressions and guarantees that the value will be initialized only on first access (similar to a `lazy` instance property). However, it seems to have a bug where it completely skips calling the static property initializer if the property type is `()` and optimizations are turned on (with -O). Instead of calling the initializer, it creates a local `()` value and uses that.\r\n\r\nThis bug seems to only affect zero-sized tuples (`()`, `(())`, `((),())`, etc), and does not affect any other zero-sized values. For example, using `enum Nullary { case Value }` as the type behaves correctly.\r\n\r\nGiven that Swift is not a pure language, and so expressions can have side-effects, it does not seem to ever be valid to replace an expression that's typed as `()` with a literal `()` value unless the expression can be proven at compile-time to be effect-free.\r\n\r\nSteps to Reproduce:\r\nCompile and run the following code, with and without optimizations:\r\n\r\n    class Foo {\r\n        struct Static {\r\n            static let classInit: () = {\r\n                println(\"This should be called the first time Foo.init() is called\")\r\n                return ()\r\n            }()\r\n        }\r\n\r\n        private let _init: () = Static.classInit\r\n    }\r\n\r\n    println(\"Calling Foo.init()\")\r\n    let _ = Foo()\r\n    println(\"Calling Foo.init() again\")\r\n    let _ = Foo()\r\n\r\nExpected Results:\r\nBoth the optimized and unoptimized versions should print the same results:\r\n\r\n\tCalling Foo.init()\r\n\tThis should be called the first time Foo.init() is called\r\n\tCalling Foo.init() again\r\n\r\nActual Results:\r\nOnly the unoptimized version prints that. The optimized version prints:\r\n\r\n\tCalling Foo.init()\r\n\tCalling Foo.init() again\r\n\r\nThe generated SIL for the function `main.Foo.__allocating_init` in the optimized version looks like:\r\n\r\n\t// main.Foo.__allocating_init (main.Foo.Type)() -> main.Foo\r\n\tsil @_TFC4main3FooCfMS0_FT_S0_ : $@thin (@thick Foo.Type) -> @owned Foo {\r\n\tbb0(%0 : $@thick Foo.Type):\r\n\t  %1 = alloc_ref $Foo                             // user: %2\r\n\t  return %1 : $Foo                                // id: %2\r\n\t}\r\n\r\nBy contrast, if I change the type from `()` to `Bool` and have the initializer `return true`, I get the following:\r\n\r\n\t// main.Foo.__allocating_init (main.Foo.Type)() -> main.Foo\r\n\tsil @_TFC4main3FooCfMS0_FT_S0_ : $@thin (@thick Foo.Type) -> @owned Foo {\r\n\tbb0(%0 : $@thick Foo.Type):\r\n\t  %1 = alloc_ref $Foo                             // users: %6, %8\r\n\t  // function_ref main.Foo.Static.classInit.mutableAddressor : Swift.Bool\r\n\t  %2 = function_ref @_TFVC4main3Foo6Statica9classInitSb : $@thin () -> Builtin.RawPointer // user: %3\r\n\t  %3 = apply %2() : $@thin () -> Builtin.RawPointer // user: %4\r\n\t  %4 = pointer_to_address %3 : $Builtin.RawPointer to $*Bool // user: %5\r\n\t  %5 = load %4 : $*Bool                           // user: %7\r\n\t  %6 = ref_element_addr %1 : $Foo, #Foo._init     // user: %7\r\n\t  store %5 to %6 : $*Bool                         // id: %7\r\n\t  return %1 : $Foo                                // id: %8\r\n\t}\r\n\r\nI get the same results if I use the aforementioned zero-size `enum Nullary { case Value }` type.\r\n\r\nVersion:\r\nSwift version 1.1 (swift-600.0.57.3)\r\nTarget: x86_64-apple-darwin14.0.0\r\n\r\nNotes:\r\nThe pattern used in the sample code is very useful when a class or struct needs to have one-time initialization code run before the first instance of the class/struct is created. It's similar to using `+initialize` in obj-c, although it's more clearly defined as being invoked when the first instance is created, rather than being invoked when the first message is sent to the class.\r\n\r\nThis bug also manifests when avoiding init, e.g. with\r\n\r\n    struct Foo {\r\n        static let classInit: () = {\r\n            println(\"Foo.classInit initialization\")\r\n        }()\r\n    }\r\n\r\n    println(\"Accessing Foo.classInit\")\r\n    let a: () = Foo.classInit\r\n    println(\"Accessing Foo.classInit again\")\r\n    let b: () = Foo.classInit\r\n\r\n------------------------------------------------------------------------------\r\n13-Jan-2015 04:21 PM\r\n\r\nIn the second sample code listed under Notes, using `static var` instead of `static let` works around the issue, but in the original sample code it has no effect. I am unsure why this is the case.\r\n\r\nIt also turns out that this bug can affect static lets of non-`()` types if the value of the property isn't used, e.g. `let _ = Static.prop`. A `let _ = expr` statement always exists in order to evaluate `expr` for its side-effects, yet Swift will happily skip the static let initializer when using it. Sample code:\r\n\r\n    struct Foo {\r\n        static let bar: Bool = {\r\n            println(\"Foo.bar\")\r\n            return true\r\n        }()\r\n\r\n        static var baz: Bool {\r\n            get {\r\n                println(\"Foo.baz.get\")\r\n                return true\r\n            }\r\n        }\r\n    }\r\n\r\n    let _ = Foo.bar\r\n    let _ = Foo.baz\r\n    let _ = Foo.bar\r\n    let _ = Foo.baz\r\n\r\nIn a non-optimized build this prints\r\n\r\n    Foo.bar\r\n    Foo.baz.get\r\n    Foo.baz.get\r\n\r\nBut in an optimized build this prints\r\n\r\n    Foo.baz.get\r\n    Foo.baz.get\r\n\r\nIt seems the correct fix is for the compiler to treat static let initializers similarly to computed properties and always call the initializer. The only exceptions that come to mind are either when the static let's initializer expression is a compile-time constant (or the compiler can otherwise prove that the initializer has no side-effects), or when the compiler can prove that the property has already been accessed in the past (e.g. accessing the static let twice within the same block of code)."
    email: kevin@sb.org
    modified: "2015-01-14T00:25:47.703842Z"
    number: "19464274"
    number_intvalue: 19464274
    originated: 1/13/2015
    parent_number: '&{NULL_VALUE}'
    product: Developer Tools
    product_version: ""
    reproducible: Always
    resolved: ""
    status: Open
    title: 'Swift: -O incorrectly assumes access of static property of type () has no side effects'
