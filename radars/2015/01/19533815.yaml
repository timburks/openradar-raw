apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "19533815"
    labels:
        datastore_id: "5898366969970688"
data:
    classification: Serious Bug
    created: "2015-01-20T18:23:21.800923Z"
    description: "Summary:\r\nThe type `Unmanaged<AnyObject>?` is considered to be a 9-byte value even though\r\nother types such as `Unmanaged<NSObject>?` are correctly treated as an 8-byte\r\nvalue. But it's only a 9-byte value part of the time. When wrapped in\r\n`UnsafePointer`, as in `UnsafePointer<Unmanaged<AnyObject>?>` it becomes an\r\n8-byte value. Most of the time. In optimized builds (`-O`) it still ends up\r\nbeing a 9-byte value part of the time.\r\n\r\nThis causes particular trouble when calling C functions that use an out-param\r\nlike `UnsafeMutablePointer<Unmanaged<AnyObject>?>`, such as\r\n`SecItemCopyMatching()`. Passing a reference to a local `Unmanaged<AnyObject>?`\r\nthat is initialized to `nil` seems to work in debug builds, but in optimized\r\nbuilds the local value is considered to be `nil` even though the function wrote\r\na valid pointer to it, because the 9th byte, the discriminant, is still set to\r\n0x01 and the compiler emits code that tests the discriminant instead of testing\r\nthe pointer.\r\n\r\nThis can be reproduced with `SecItemCopyMatching()`, but it can also be tested\r\nby redeclaring `CFArrayGetValues()` as using `Unmanaged<AnyObject>` as well, as\r\nwith the code in the reproduction steps.\r\n\r\nSomething about this that's truly puzzling is the fact that the discriminant is\r\nchosen such that a value of 0x01 indicates `nil` and 0x00 indicates a valid\r\nvalue. This seems quite backwards, one would expect a discriminant of `0x00` be\r\nchosen to represent `nil` so that it can be unified with the bytes used for the\r\npointer.\r\n\r\nAlso puzzling is the fact that `sizeofValue()` always returns 9 for\r\n`Unmanaged<AnyObject>?`, but returns 8 for the expression `x.memory` where `x`\r\nis `UnsafePointer<Unmanaged<AnyObject>?>`. My best guess is that `x.memory` is\r\nactually of the type `@lvalue Unmanaged<AnyObject>?` and this means it's really\r\na pointer, and the compiler is then able to perform the null pointer\r\noptimization. But having the size change like that merely by taking a pointer to\r\nthe value is kind of frightening. It also doesn't explain why `x == nil` changes\r\nbehavior under optimization, as `==` doesn't take lvalues.\r\n\r\nAnd finally, all this weirdness goes away when using `Unmanaged<NSObject>?`\r\ninstead of `Unmanaged<AnyObject>?` (or using any subclass of `NSObject`).\r\n`Unmanaged<NSObject>?` is an 8-byte value and behaves identically in optimized\r\nand non-optimized builds.\r\n\r\nSteps to Reproduce:\r\n1. Compile and run the following code both without optimization and with -O:\r\n\r\nimport Foundation\r\n\r\n@asmname(\"CFArrayGetValues\") func getValues(ary: NSArray, range: CFRange, values: UnsafeMutablePointer<Unmanaged<AnyObject>?>)\r\n\r\n@inline(never)\r\nfunc foo() {\r\n    var x: Unmanaged<AnyObject>?\r\n    println(\"x == nil: \\(x == nil)\")\r\n    println(unsafeBitCast(x, (UInt64,UInt8).self))\r\n    show(&x)\r\n    getValues([\"one\"], CFRange(location: 0, length: 1), &x)\r\n    println(\"set x to: \\(x?.takeRetainedValue() as String?)\")\r\n    println(\"x == nil: \\(x == nil)\")\r\n    println(unsafeBitCast(x, (UInt64,UInt8).self))\r\n    show(&x)\r\n}\r\n\r\nfunc show<T>(x: UnsafePointer<T>) {\r\n    let p = UnsafePointer<UInt8>(x)\r\n    var s = \"<\"\r\n    for i in 0..<sizeofValue(x.memory) {\r\n        if i > 0 && i % 4 == 0 {\r\n            s.extend(\" \")\r\n        }\r\n        let byte = String(p[i], radix: 16)\r\n        if countElements(byte) == 1 {\r\n            s.extend(\"0\")\r\n        }\r\n        s.extend(byte)\r\n    }\r\n    s.extend(\">\")\r\n    println(s)\r\n}\r\nfoo()\r\n\r\nExpected Results:\r\nIdeally, it would correctly understand that Unmanaged<AnyObject> is an 8-byte\r\nvalue. In that case the above program would actually fail at unsafeBitCast()\r\nbecause of the different sizes, but with the casted type replaced by `UInt64`\r\nthen ideally it would print something like:\r\n\r\nx == nil: true\r\n0\r\n<00000000 00000000>\r\nset x to: Optional(\"one\")\r\nx == nil: false\r\n140720087302720\r\n<4002d1f2 fb7f0000>\r\n\r\nIn fact, this is precisely what happens when you edit the code to use\r\n`Unmanaged<NSObject>?` instead of `Unmanaged<AnyObject>?`.\r\n\r\nActual Results:\r\nHowever, it is a 9-byte value, and so the above can't happen. Instead, under\r\noptimization it prints:\r\n\r\nx == nil: true\r\n(0, 1)\r\n<00000000 00000000>\r\nset x to: Optional(\"one\")\r\nx == nil: false\r\n(140720087302720, 1)\r\n<4002d1f2 fb7f0000>\r\n\r\nThree things to note here. First, `x` starts out as `(0, 1)`, which demonstrates\r\nthe oddly swapped discriminants. Second, the size as seen by `show()` is only 8\r\nbytes, and so it prints an 8-byte null pointer for `nil`. Third, even though the\r\ndiscriminant remains as `1` after the value is populated, Swift believes the\r\nvalue to be non-nil.\r\n\r\nWith optimization (using -O):\r\n\r\nx == nil: true\r\n(0, 1)\r\n<00000000 00000000 01>\r\nset x to: nil\r\nx == nil: true\r\n(140498359550960, 1)\r\n<f003d052 c87f0000 01>\r\n\r\nThings to note here: the discrimnant is still 1 for `nil`, but this time\r\n`show()` actually sees a 9-byte value. Not only that, but Swift believes the\r\nvalue to still be `nil` after the call to `getValues()` because it's now testing\r\nthe discriminant.\r\n\r\nVersion:\r\nSwift version 1.1 (swift-600.0.57.3)\r\nTarget: x86_64-apple-darwin14.0.0\r\n\r\nNotes:\r\nThis bug is a very serious problem for anyone using the Keychain APIs, and\r\nanything else that uses `Unmanaged<AnyObject>`. Not only is it obviously broken,\r\nbut it's very oddly only broken for optimized builds, meaning that people who\r\nhit this won't ever see it in their development environment, and perhaps even\r\nworse, won't ever get usable assertion failure messages when they e.g.\r\nforce-unwrap the optional value, because optimization disables those.\r\n\r\nConfiguration:\r\nOS X 10.10.1 (14B25)"
    email: kevin@sb.org
    modified: "2015-01-20T18:23:21.801103Z"
    number: "19533815"
    number_intvalue: 19533815
    originated: 1/20/2015
    parent_number: '&{NULL_VALUE}'
    product: Developer Tools
    product_version: ""
    reproducible: Always
    resolved: ""
    status: Open
    title: 'Swift: Unmanaged<AnyObject>? is a 9-byte value and breaks optimized builds'
