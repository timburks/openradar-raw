apiVersion: openapi/v1alpha1
kind: Radar
metadata:
    name: "8087384"
    labels:
        datastore_id: "426401"
data:
    classification: Crash
    created: "2010-06-13T04:28:44.502012Z"
    description: "### Summary\r\n\r\nIn a garbage-collected environment, the use of a costum NSURLProtocol subclass triggers an underflow error, which can also lead to a crash when the overreleased object is accessed after it was finalized. This problem does not occur in a non-GC environment.\r\n\r\n\r\n### Steps to reproduce\r\n\r\n* Start with Apple's example SpecialPictureProtocol, that can be downloaded from Apple's web site, at the following address:\r\n\r\n\t\thttp://developer.apple.com/mac/library/samplecode/SpecialPictureProtocol/Introduction/Intro.html\r\n\r\n* In the build settings, change the target OS to 10.6 so that it builds with Xcode 3.2\r\n\r\n* In the build settings, turn on garbage-collection to `required`\r\n\r\n* Build and run, type various strings and here is what happens:\r\n\r\n\t* In the console, messages appear as follows:\r\n\t\r\n\t\t\tmalloc: reference count underflow for 0xXXXXXXXXX,\r\n\t\t\tbreak on auto_refcount_underflow_error to debug.`\r\n\t\t\r\n\t\twith the address corresponding to the underflowed/overreleased object\r\n\t\r\n\t* Eventually, it will crash, either with an `EXC_BAD_ACCESS` or an exception pointing to a method call not implemented by the target, both a sign of memory corruption and/or accessing an object that does not exist anymore.\r\n\r\n\r\n### Diagnostics\r\n\r\n* The bug has been reported also on these web pages and mailing lists:\r\n\t* http://stackoverflow.com/questions/1112869/how-to-avoid-reference-count-underflow-in-nscfurlprotocolbridge-in-custom-nsurlp\r\n\t* http://lists.apple.com/archives/cocoa-dev/2008/May/msg01272.html\r\n\t* http://www.cocoabuilder.com/archive/cocoa/195056-options-for-working-around-bug.html#195056\r\n\r\n* Upon further inspection of the address of the underflow, it appears this address corresponds to the `client` opaque object passed to the method `-initWithRequest:cachedResponse:client:` when the costum NSURLProtocol instance is init-ed.\r\n\r\n* We had the chance to discuss this bug directly to an Apple engineer at the WebKit lab at WWDC. The engineer identified a bug in OS X code, consistent with the above description and observations. It appears the client object is passed to some other internal classes using a `void *` argument which is then not properly handled by the garbage collector. Depending on the timing, the client is then randomly finalized at some future point, which may lead to the underflow message and/or a crash.\r\n\r\n### Workaround 1\r\n\r\n* The first workaround is to simply compile and run under non-GC environment, but that's not an option for our actual application, of course.\r\n\r\n\r\n### Workaround 2 under GC\r\n\r\n* With the Apple engineer contacted at WWDC, we devised  a simple workaround to avoid the underflow and the potential crash. It is found in the attached project, which is identical to the original Apple sample project SpecialPictureProtocol except for overriding the `-initWithRequest:cachedResponse:client:` in the NSURLProtocol subclass. In this method, we can retain the client, which is a Core Foundation object, as follows:\r\n\r\n\t\t- (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id <NSURLProtocolClient>)client\r\n\t\t{\r\n\t\t\t// under GC, and unless we retaint the client, we observe the following issues;\r\n\t\t\t//  - error messages in the console 'malloc: reference count underflow for XXX, break on auto_refcount_underflow_error to debug.', where XXX is the address of the cient\r\n\t\t\t//  - crashes on EXC_BAD_ACCESS or exceptions on invocations that could not be done on an object, in both cases indicative of overreleased obejct. The app does not always crash, one needs to hammer it quite hard sometimes\r\n\t\r\n\t\t\t// workaround to avoid underflow and crashes\r\n\t\t\t// BUT THE OBJECT WILL LEAK!!\r\n\t\t\t//CFRetain(client);\r\n\t\r\n\t\t\treturn [super initWithRequest:request cachedResponse:cachedResponse client:client];\r\n\t\t}\r\n\r\n* A problem remains: we could not find yet a good place to release the client, which means the above workaround results in leaking the `client` object, and in turn, due to the object graph, also retain the NSURLProtocol instance. The retain appears in particular to create a retain cycle between the client object and the NSURLProtocol instance."
    email: charles.parnot@gmail.com
    modified: "2013-01-07T08:26:21.850007Z"
    number: "8087384"
    number_intvalue: 8087384
    originated: 06/12/2010
    parent_number: '&{NULL_VALUE}'
    product: Mac OS X
    product_version: "10.6"
    reproducible: Always
    resolved: ""
    status: Duplicate
    title: Underflow with NSURLProtocol in GC environment
